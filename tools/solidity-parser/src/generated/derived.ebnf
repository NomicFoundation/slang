(*
 * Solidity Grammar
 *)

(*
 * First Section: Trivia
 *)

«LeadingTrivia» = { «Whitespace» | «EndOfLine» | «MultilineComment» | «SingleLineComment» } ;

«TrailingTrivia» = [ { «Whitespace» | «MultilineComment» } ( «EndOfLine» | «SingleLineComment» ) ] ;

«EndOfFileTrivia» = { «Whitespace» | «MultilineComment» | «SingleLineComment» } ;

«Whitespace» = 1…*{ '\u{20}' | '\u{9}' } ;

«EndOfLine» = 1…*{ '\u{d}' | '\u{a}' } ;

«MultilineComment» = '/*' { ¬'*' | 1…*{ '*' } ¬( '*' | '/' ) } { '*' } '*/' ;

«SingleLineComment» = '//' { ¬( '\u{d}' | '\u{a}' ) } ;

(*
 * First Section: Solidity File
 *)

SourceUnit = «LeadingTrivia» { Directive | Definition } «EndOfFileTrivia» $ ;

Directive = PragmaDirective | ImportDirective | UsingDirective ;

Definition = ContractDefinition | InterfaceDefinition | LibraryDefinition | FunctionDefinition | ConstantDefinition | StructDefinition | EnumDefinition | UserDefinedValueTypeDefinition | ErrorDefinition ;

ImportDirective = 'import' ( SimpleImportDirective | StarImportDirective | SelectingImportDirective ) ';' ;

SimpleImportDirective = ImportPath { 'as' «Identifier» } ;

StarImportDirective = '*' 'as' «Identifier» 'from' ImportPath ;

SelectingImportDirective = { 1…*{ SelectedImport / ',' } } 'from' ImportPath ;

SelectedImport = «Identifier» [ 'as' «Identifier» ] ;

ImportPath = «AsciiStringLiteral» ;

UsingDirective = 'using' ( IdentifierPath | { 1…*{ IdentifierPath / ',' } } ) 'for' ( '*' | TypeName ) [ 'global' ] ';' ;

(*
 * Todo Section: Todo Topic
 *)

ContractDefinition = [ 'abstract' ] 'contract' «Identifier» [ InheritanceSpecifierList ] { { ContractBodyElement } } ;

InterfaceDefinition = 'interface' «Identifier» [ InheritanceSpecifierList ] { { ContractBodyElement } } ;

InheritanceSpecifierList = 'is' 1…*{ InheritanceSpecifier / ',' } ;

InheritanceSpecifier = IdentifierPath [ ArgumentList ] ;

LibraryDefinition = 'library' «Identifier» { { ContractBodyElement } } ;

FunctionDefinition = 'function' ( «Identifier» | 'fallback' | 'receive' ) ParameterList { FunctionAttribute } [ 'returns' ParameterList ] ( ';' | Block ) ;

FunctionAttribute = ModifierInvocation | OverrideSpecifier | 'external' | 'internal' | 'payable' | 'private' | 'public' | 'pure' | 'view' | 'virtual' ;

ConstantDefinition = TypeName 'constant' «Identifier» '=' Expression ';' ;

StructDefinition = 'struct' «Identifier» '{' 1…*{ StructMember } '}' ;

StructMember = TypeName «Identifier» ';' ;

EnumDefinition = 'enum' «Identifier» { 1…*{ «Identifier» / ',' } } ;

UserDefinedValueTypeDefinition = 'type' «Identifier» 'is' ElementaryType ';' ;

EventDefinition = 'event' «Identifier» ( { EventParameter / ',' } ) [ 'anonymous' ] ';' ;

EventParameter = TypeName [ 'indexed' ] [ «Identifier» ] ;

ErrorDefinition = 'error' «Identifier» ( { ErrorParameter / ',' } ) ';' ;

ErrorParameter = TypeName [ «Identifier» ] ;

ContractBodyElement = UsingDirective | ConstructorDefinition | FunctionDefinition | FallbackFunctionDefinition | ReceiveFunctionDefinition | ModifierDefinition | StructDefinition | EnumDefinition | UserDefinedValueTypeDefinition | EventDefinition | ErrorDefinition | StateVariableDeclaration ;

ConstructorDefinition = 'constructor' ParameterList { ConstructorAttribute } Block ;

ConstructorAttribute = ModifierInvocation | 'internal' | 'payable' | 'public' ;

FallbackFunctionDefinition = 'fallback' ParameterList { FallbackFunctionAttribute } [ 'returns' ParameterList ] ( ';' | Block ) ;

FallbackFunctionAttribute = ModifierInvocation | OverrideSpecifier | 'external' | 'payable' | 'pure' | 'view' | 'virtual' ;

ReceiveFunctionDefinition = 'receive' ParameterList { ReceiveFunctionAttribute } ( ';' | Block ) ;

ReceiveFunctionAttribute = ModifierInvocation | OverrideSpecifier | 'external' | 'payable' | 'virtual' ;

ModifierDefinition = 'modifier' «Identifier» [ ParameterList ] { ModifierAttribute } ( ';' | Block ) ;

ModifierAttribute = OverrideSpecifier | 'virtual' ;

StateVariableDeclaration = TypeName { StateVariableAttribute } «Identifier» [ '=' Expression ] ';' ;

StateVariableAttribute = OverrideSpecifier | 'constant' | 'immutable' | 'internal' | 'private' | 'public' ;

ArgumentList = ( [ PositionalArgumentList | NamedArgumentList ] ) ;

PositionalArgumentList = 1…*{ Expression / ',' } ;

NamedArgumentList = { { NamedArgument / ',' } } ;

NamedArgument = «Identifier» ':' Expression ;

ModifierInvocation = IdentifierPath [ ArgumentList ] ;

ParameterList = ( { ParameterDeclaration / ',' } ) ;

ParameterDeclaration = TypeName [ DataLocation ] [ «Identifier» ] ;

OverrideSpecifier = 'override' [ '(' 1…*{ IdentifierPath / ',' } ')' ] ;

IdentifierPath = 1…*{ «Identifier» / '.' } ;

TypeName = ( ElementaryType | FunctionType | MappingType | IdentifierPath ) { '[' [ Expression ] ']' } ElementaryType ;

ElementaryType = 'bool' | 'string' | AddressType | «FixedBytesType» | «SignedIntegerType» | «UnsignedIntegerType» | «SignedFixedType» | «UnsignedFixedType» ;

AddressType = 'address' [ 'payable' ] ;

FunctionType = 'function' ParameterList { 'internal' | 'external' | 'private' | 'public' | 'pure' | 'view' | 'payable' } [ 'returns' ParameterList ] ;

MappingType = 'mapping' '(' ( ElementaryType | IdentifierPath ) '=>' TypeName ')' ;

DataLocation = 'memory' | 'storage' | 'calldata' ;

Expression = AssignmentExpression | ConditionalExpression | OrExpression | AndExpression | EqualityComparisonExpression | OrderComparisonExpression | BitOrExpression | BitXOrExpression | BitAndExpression | ShiftExpression | AddSubExpression | MulDivModExpression | ExponentiationExpression | UnarySuffixExpression | UnaryPrefixExpression | FunctionCallExpression | FunctionCallOptionsExpression | MemberAccessExpression | IndexAccessExpression | PrimaryExpression ;

AssignmentExpression = Expression ( '=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '>>>=' | '+=' | '-=' | '*=' | '/=' | '%=' ) Expression ;

ConditionalExpression = Expression '?' Expression ':' Expression ;

OrExpression = Expression '||' Expression ;

AndExpression = Expression '&&' Expression ;

EqualityComparisonExpression = Expression ( '==' | '!=' ) Expression ;

OrderComparisonExpression = Expression ( '<' | '>' | '<=' | '>=' ) Expression ;

BitOrExpression = Expression '|' Expression ;

BitXOrExpression = Expression '^' Expression ;

BitAndExpression = Expression '&' Expression ;

ShiftExpression = Expression ( '<<' | '>>' | '>>>' ) Expression ;

AddSubExpression = Expression ( '+' | '-' ) Expression ;

MulDivModExpression = Expression ( '*' | '/' | '%' ) Expression ;

ExponentiationExpression = Expression '**' Expression ;

UnarySuffixExpression = Expression ( '++' | '--' ) ;

UnaryPrefixExpression = ( '++' | '--' | '!' | '~' | '-' ) Expression ;

FunctionCallExpression = Expression ArgumentList ;

FunctionCallOptionsExpression = Expression { 1…*{ NamedArgument / ',' } } ;

MemberAccessExpression = Expression '.' ( «Identifier» | 'address' ) ;

IndexAccessExpression = Expression [ [ Expression ] [ ':' [ Expression ] ] ] ;

PrimaryExpression = PayableExpression | TypeExpression | NewExpression | ParenthesisExpression | ArrayLiteral | «AsciiStringLiteral» | «UnicodeStringLiteral» | «HexStringLiteral» | «NumericLiteral» | «BooleanLiteral» | «Identifier» ;

PayableExpression = 'payable' ArgumentList ;

TypeExpression = 'type' '(' TypeName ')' ;

NewExpression = 'new' IdentifierPath ArgumentList ;

ParenthesisExpression = '(' 1…*{ [ Expression ] / ',' } ')' ;

ArrayLiteral = '[' 1…*{ Expression / ',' } ']' ;

«NumericLiteral» = ( «DecimalNumber» | «HexNumber» ) [ «NumberUnit» ] ;

Block = { { Statement | UncheckedBlock } } ;

UncheckedBlock = 'unchecked' Block ;

Statement = Block | SimpleStatement | IfStatement | ForStatement | WhileStatement | DoWhileStatement | ContinueStatement | BreakStatement | TryStatement | ReturnStatement | EmitStatement | RevertStatement | DeleteStatement | AssemblyStatement ;

SimpleStatement = TupleDeconstructionStatement | VariableDeclarationStatement | ExpressionStatement ;

IfStatement = 'if' ( Expression ) Statement [ 'else' Statement ] ;

ForStatement = 'for' ( ( SimpleStatement | ';' ) ( ExpressionStatement | ';' ) [ Expression ] ) Statement ;

WhileStatement = 'while' ( Expression ) Statement ;

DoWhileStatement = 'do' Statement 'while' ( Expression ) ';' ;

ContinueStatement = 'continue' ';' ;

BreakStatement = 'break' ';' ;

TryStatement = 'try' Expression [ 'returns' ParameterList ] Block 1…*{ CatchClause } ;

CatchClause = 'catch' [ [ «Identifier» ] ParameterList ] Block ;

ReturnStatement = 'return' [ Expression ] ';' ;

EmitStatement = 'emit' IdentifierPath ArgumentList ';' ;

RevertStatement = 'revert' [ IdentifierPath ] ArgumentList ';' ;

DeleteStatement = 'delete' «Identifier» ';' ;

TupleDeconstructionStatement = '(' { [ [ TypeName ] «Identifier» ] / ',' } ')' '=' Expression ';' ;

VariableDeclarationStatement = TypeName [ DataLocation ] «Identifier» [ '=' Expression ] ';' ;

ExpressionStatement = Expression ';' ;

AssemblyStatement = 'assembly' [ '"evmasm"' ] [ AssemblyFlags ] YulBlock ;

AssemblyFlags = ( 1…*{ «DoubleQuotedAsciiStringLiteral» / ',' } ) ;

«Identifier» = «RawIdentifier» - «Keyword» ;

«Keyword» = «BooleanLiteral» | «FixedBytesType» | «NumberUnit» | «ReservedKeyword» | «SignedIntegerType» | «UnsignedIntegerType» | 'abstract' | 'address' | 'anonymous' | 'as' | 'assembly' | 'bool' | 'break' | 'calldata' | 'catch' | 'constant' | 'constructor' | 'continue' | 'contract' | 'delete' | 'do' | 'else' | 'emit' | 'enum' | 'event' | 'external' | 'fallback' | 'false' | 'fixed' | 'for' | 'function' | 'hex' | 'if' | 'immutable' | 'import' | 'indexed' | 'interface' | 'internal' | 'is' | 'library' | 'mapping' | 'memory' | 'modifier' | 'new' | 'override' | 'payable' | 'pragma' | 'private' | 'public' | 'pure' | 'receive' | 'return' | 'returns' | 'storage' | 'string' | 'struct' | 'true' | 'try' | 'type' | 'ufixed' | 'unchecked' | 'using' | 'view' | 'virtual' | 'while' ;

«ReservedKeyword» = 'after' | 'alias' | 'apply' | 'auto' | 'byte' | 'case' | 'copyof' | 'default' | 'define' | 'final' | 'implements' | 'in' | 'inline' | 'let' | 'macro' | 'match' | 'mutable' | 'null' | 'of' | 'partial' | 'promise' | 'reference' | 'relocatable' | 'sealed' | 'sizeof' | 'static' | 'supports' | 'switch' | 'typedef' | 'typeof' | 'var' ;

PragmaDirective = 'pragma' ( VersionPragmaSpecifier | ABICoderPragmaSpecifier | ExperimentalPragmaSpecifier ) ';' ;

VersionPragmaSpecifier = 'solidity' 1…*{ «VersionPragmaOperator» «VersionPragmaValue» } ;

«VersionPragmaOperator» = '^' | '~' | '=' | '<' | '>' | '<=' | '>=' ;

«VersionPragmaValue» = 1…*{ 1…*{ '0'…'9' | 'x' | 'X' | '*' } / '.' } ;

ABICoderPragmaSpecifier = 'abicoder' «Identifier» ;

ExperimentalPragmaSpecifier = 'experimental' «Identifier» ;

«RawIdentifier» = «IdentifierStart» { «IdentifierPart» } ;

«IdentifierStart» = '_' | '$' | 'a'…'z' | 'A'…'Z' ;

«IdentifierPart» = «IdentifierStart» | '0'…'9' ;

«SignedIntegerType» = 'int' [ '8' | '16' | '24' | '32' | '40' | '48' | '56' | '64' | '72' | '80' | '88' | '96' | '104' | '112' | '120' | '128' | '136' | '144' | '152' | '160' | '168' | '176' | '184' | '192' | '200' | '208' | '216' | '224' | '232' | '240' | '248' | '256' ] ;

«UnsignedIntegerType» = 'u' «SignedIntegerType» ;

«FixedBytesType» = 'bytes' [ '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' ] ;

«SignedFixedType» = 'fixed' [ 1…*{ '0'…'9' } 'x' 1…*{ '0'…'9' } ] ;

«UnsignedFixedType» = 'u' «SignedFixedType» ;

«BooleanLiteral» = 'true' | 'false' ;

«DecimalNumber» = ( «DecimalInteger» | «DecimalFloat» ) [ «DecimalExponent» ] ;

«DecimalInteger» = 1…*{ '0'…'9' / [ '_' ] } ;

«DecimalFloat» = [ «DecimalInteger» ] '.' «DecimalInteger» ;

«DecimalExponent» = ( 'e' | 'E' ) [ '-' ] «DecimalInteger» ;

«HexNumber» = '0x' 1…*{ «HexCharacter» / [ '_' ] } ;

«NumberUnit» = 'days' | 'ether' | 'finney' | 'gwei' | 'hours' | 'minutes' | 'seconds' | 'szabo' | 'weeks' | 'wei' | 'years' ;

«HexStringLiteral» = 'hex' ( " [ «PossiblySeparatedPairsOfHexDigits» ] " | ' [ «PossiblySeparatedPairsOfHexDigits» ] ' ) ;

«PossiblySeparatedPairsOfHexDigits» = 1…*{ 2…2*{ «HexCharacter» } / [ '_' ] } ;

«HexCharacter» = '0'…'9' | 'a'…'f' | 'A'…'F' ;

«AsciiStringLiteral» = «SingleQuotedAsciiStringLiteral» | «DoubleQuotedAsciiStringLiteral» ;

«SingleQuotedAsciiStringLiteral» = ' { 1…*{ '\u{20}'…'~' - ( '\'' | '\\' ) } | «EscapeSequence» } ' ;

«DoubleQuotedAsciiStringLiteral» = " { 1…*{ '\u{20}'…'~' - ( '"' | '\\' ) } | «EscapeSequence» } " ;

«UnicodeStringLiteral» = «SingleQuotedUnicodeStringLiteral» | «DoubleQuotedUnicodeStringLiteral» ;

«SingleQuotedUnicodeStringLiteral» = unicode' { 1…*{ ¬( '\'' | '\\' | '\u{a}' | '\u{d}' ) } | «EscapeSequence» } ' ;

«DoubleQuotedUnicodeStringLiteral» = unicode" { 1…*{ ¬( '"' | '\\' | '\u{a}' | '\u{d}' ) } | «EscapeSequence» } " ;

«EscapeSequence» = '\\' ( «AsciiEscape» | «HexByteEscape» | «UnicodeEscape» ) ;

«AsciiEscape» = 'n' | 'r' | 't' | '\'' | '"' | '\\' | '\u{a}' | '\u{d}' ;

«HexByteEscape» = 'x' 2…2*{ «HexCharacter» } ;

«UnicodeEscape» = 'u' 4…4*{ «HexCharacter» } ;

YulBlock = { { YulStatement } } ;

YulStatement = YulBlock | YulVariableDeclaration | YulFunctionDefinition | YulAssignmentStatement | YulFunctionCall | YulIfStatement | YulForStatement | YulSwitchStatement | YulLeaveStatement | YulBreakStatement | YulContinueStatement ;

YulVariableDeclaration = 'let' 1…*{ YulIdentifierPath / ',' } [ ':=' YulExpression ] ;

YulFunctionDefinition = 'function' «YulIdentifier» ( { «YulIdentifier» / ',' } ) [ '->' 1…*{ «YulIdentifier» / ',' } ] YulBlock ;

YulAssignmentStatement = 1…*{ YulIdentifierPath / ',' } ':=' YulExpression ;

YulFunctionCall = «YulIdentifier» '(' { YulExpression / ',' } ')' ;

YulIfStatement = 'if' YulExpression YulBlock ;

YulLeaveStatement = 'leave' ;

YulBreakStatement = 'break' ;

YulContinueStatement = 'continue' ;

YulForStatement = 'for' YulBlock YulExpression YulBlock YulBlock ;

YulSwitchStatement = 'switch' YulExpression 1…*{ ( 'case' YulLiteral | 'default' ) YulBlock } ;

YulExpression = YulIdentifierPath | YulFunctionCall | YulLiteral ;

YulIdentifierPath = 1…*{ «YulIdentifier» / '.' } ;

YulLiteral = «YulDecimalNumberLiteral» | «YulHexLiteral» | «AsciiStringLiteral» | «BooleanLiteral» | «HexStringLiteral» ;

«YulIdentifier» = «RawIdentifier» - «YulKeyword» ;

«YulKeyword» = «BooleanLiteral» | 'break' | 'case' | 'continue' | 'default' | 'for' | 'function' | 'hex' | 'if' | 'leave' | 'let' | 'switch' ;

«YulDecimalNumberLiteral» = '0' | '1'…'9' { '0'…'9' } ;

«YulHexLiteral» = '0x' 1…*{ «HexCharacter» } ;
