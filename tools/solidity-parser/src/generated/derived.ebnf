(*
 * Solidity Grammar
 *)

(*
 * First Section: Trivia
 *)

«LeadingTrivia» = { «Whitespace» | «EndOfLine» | «MultilineComment» | «SingleLineComment» } ;

«TrailingTrivia» = [ { «Whitespace» | «MultilineComment» } ( «EndOfLine» | «SingleLineComment» ) ] ;

«EndOfFileTrivia» = { «Whitespace» | «MultilineComment» | «SingleLineComment» } ;

«Whitespace» = 1…*{ '\u{20}' | '\u{9}' } ;

«EndOfLine» = 1…*{ '\u{d}' | '\u{a}' } ;

«MultilineComment» = '/*' { ¬'*' | 1…*{ '*' } ¬( '*' | '/' ) } { '*' } '*/' ;

«SingleLineComment» = '//' { ¬( '\u{d}' | '\u{a}' ) } ;

(*
 * First Section: Solidity File
 *)

SourceUnit = «LeadingTrivia» { Directive | Definition } «EndOfFileTrivia» $ ;

Directive = «PragmaDirective» | ImportDirective | UsingDirective ;

Definition = ContractDefinition | InterfaceDefinition | LibraryDefinition | FunctionDefinition | ConstantDefinition | StructDefinition | EnumDefinition | UserDefinedValueTypeDefinition | ErrorDefinition ;

ImportDirective = 'import' ( SimpleImportDirective | StarImportDirective | SelectingImportDirective ) ';' ;

SimpleImportDirective = ImportPath { 'as' «Identifier» } ;

StarImportDirective = '*' 'as' «Identifier» 'from' ImportPath ;

SelectingImportDirective = '{' 1…*{ SelectedImport / ',' } '}' 'from' ImportPath ;

SelectedImport = «Identifier» [ 'as' «Identifier» ] ;

ImportPath = «AsciiStringLiteral» ;

UsingDirective = 'using' ( IdentifierPath | '{' 1…*{ IdentifierPath / ',' } '}' ) 'for' ( '*' | TypeName ) [ 'global' ] ';' ;

(*
 * Todo Section: Todo Topic
 *)

ContractDefinition = [ 'abstract' ] 'contract' «Identifier» [ InheritanceSpecifierList ] '{' { ContractBodyElement } '}' ;

InterfaceDefinition = 'interface' «Identifier» [ InheritanceSpecifierList ] '{' { ContractBodyElement } '}' ;

InheritanceSpecifierList = 'is' 1…*{ InheritanceSpecifier / ',' } ;

InheritanceSpecifier = IdentifierPath [ ArgumentList ] ;

LibraryDefinition = 'library' «Identifier» '{' { ContractBodyElement } '}' ;

FunctionDefinition = 'function' ( «Identifier» | 'fallback' | 'receive' ) ParameterList { FunctionAttribute } [ 'returns' NonEmptyParameterList ] ( ';' | Block ) ;

FunctionAttribute = VisibilitySpecifier | StateMutabilitySpecifier | ModifierInvocation | 'virtual' | OverrideSpecifier ;

ConstantDefinition = TypeName 'constant' «Identifier» '=' Expression ';' ;

StructDefinition = 'struct' «Identifier» '{' 1…*{ TypeName «Identifier» ';' } '}' ;

EnumDefinition = 'enum' «Identifier» '{' 1…*{ «Identifier» / ',' } '}' ;

UserDefinedValueTypeDefinition = 'type' «Identifier» 'is' ElementaryTypeWithPayable ';' ;

EventDefinition = 'event' «Identifier» '(' { EventParameter / ',' } ')' [ 'anonymous' ] ';' ;

EventParameter = TypeName [ 'indexed' ] [ «Identifier» ] ;

ErrorDefinition = 'error' «Identifier» '(' { ErrorParameter / ',' } ')' ';' ;

ErrorParameter = TypeName [ «Identifier» ] ;

ContractBodyElement = UsingDirective | ConstructorDefinition | FunctionDefinition | FallbackFunctionDefinition | ReceiveFunctionDefinition | ModifierDefinition | StructDefinition | EnumDefinition | UserDefinedValueTypeDefinition | EventDefinition | ErrorDefinition | StateVariableDeclaration ;

ConstructorDefinition = 'constructor' ParameterList { ConstructorAttribute } Block ;

ConstructorAttribute = ModifierInvocation | 'payable' | 'internal' | 'public' ;

FallbackFunctionDefinition = 'fallback' ParameterList { FallbackFunctionAttribute } [ 'returns' NonEmptyParameterList ] ( ';' | Block ) ;

FallbackFunctionAttribute = 'external' | StateMutabilitySpecifier | ModifierInvocation | 'virtual' | OverrideSpecifier ;

ReceiveFunctionDefinition = 'receive' '(' ')' { ReceiveFunctionAttribute } ( ';' | Block ) ;

ReceiveFunctionAttribute = 'external' | 'payable' | ModifierInvocation | 'virtual' | OverrideSpecifier ;

ModifierDefinition = 'modifier' «Identifier» [ ParameterList ] { MethodAttribute } ( ';' | Block ) ;

MethodAttribute = 'virtual' | OverrideSpecifier ;

StateVariableDeclaration = TypeName { StateVariableAttribute } «Identifier» [ '=' Expression ] ';' ;

StateVariableAttribute = 'public' | 'private' | 'internal' | 'constant' | OverrideSpecifier | 'immutable' ;

ArgumentList = '(' [ PositionalArgumentList | NamedArgumentList ] ')' ;

PositionalArgumentList = 1…*{ Expression / ',' } ;

NamedArgumentList = '{' { NamedArgument / ',' } '}' ;

NamedArgument = «Identifier» ':' Expression ;

ModifierInvocation = IdentifierPath [ ArgumentList ] ;

ParameterList = '(' { ParameterDeclaration / ',' } ')' ;

NonEmptyParameterList = '(' 1…*{ ParameterDeclaration / ',' } ')' ;

ParameterDeclaration = TypeName [ DataLocation ] [ «Identifier» ] ;

VisibilitySpecifier = 'internal' | 'external' | 'private' | 'public' ;

StateMutabilitySpecifier = 'pure' | 'view' | 'payable' ;

OverrideSpecifier = 'override' [ '(' 1…1*{ IdentifierPath / ',' } ')' ] ;

IdentifierPath = 1…*{ «Identifier» / '.' } ;

TypeName = ( ElementaryTypeWithPayable | FunctionType | MappingType | IdentifierPath ) { '[' [ Expression ] ']' } ;

ElementaryTypeWithPayable = 'address' [ 'payable' ] | ElementaryType ;

ElementaryTypeWithoutPayable = 'address' | ElementaryType ;

ElementaryType = 'bool' | 'string' | 'bytes' | «SignedIntegerType» | «UnsignedIntegerType» | «FixedBytesType» | «FixedType» | «UfixedType» ;

FunctionType = 'function' ParameterList { VisibilitySpecifier | StateMutabilitySpecifier } [ 'returns' NonEmptyParameterList ] ;

MappingType = 'mapping' '(' ( ElementaryTypeWithoutPayable | IdentifierPath ) '=>' TypeName ')' ;

DataLocation = 'memory' | 'storage' | 'calldata' ;

Expression = AssignmentExpression | ConditionalExpression | OrExpression | AndExpression | EqualityComparisonExpression | OrderComparisonExpression | BitOrExpression | BitXOrExpression | BitAndExpression | ShiftExpression | AddSubExpression | MulDivModExpression | ExponentiationExpression | UnarySuffixExpression | UnaryPrefixExpression | FunctionCallExpression | FunctionCallOptionsExpression | MemberAccessExpression | IndexAccessExpression | PrimaryExpression ;

AssignmentExpression = Expression ( '=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '>>>=' | '+=' | '-=' | '*=' | '/=' | '%=' ) Expression ;

ConditionalExpression = Expression '?' Expression ':' Expression ;

OrExpression = Expression '||' Expression ;

AndExpression = Expression '&&' Expression ;

EqualityComparisonExpression = Expression ( '==' | '!=' ) Expression ;

OrderComparisonExpression = Expression ( '<' | '>' | '<=' | '>=' ) Expression ;

BitOrExpression = Expression '|' Expression ;

BitXOrExpression = Expression '^' Expression ;

BitAndExpression = Expression '&' Expression ;

ShiftExpression = Expression ( '<<' | '>>' | '>>>' ) Expression ;

AddSubExpression = Expression ( '+' | '-' ) Expression ;

MulDivModExpression = Expression ( '*' | '/' | '%' ) Expression ;

ExponentiationExpression = Expression '**' Expression ;

UnarySuffixExpression = Expression ( '++' | '--' ) ;

UnaryPrefixExpression = ( '++' | '--' | '!' | '~' | 'delete' | '-' ) Expression ;

FunctionCallExpression = Expression ArgumentList ;

FunctionCallOptionsExpression = Expression '{' 1…*{ NamedArgument / ',' } '}' ;

MemberAccessExpression = Expression '.' ( «Identifier» | 'address' ) ;

IndexAccessExpression = Expression '[' [ Expression ] [ ':' [ Expression ] ] ']' ;

PrimaryExpression = 'payable' ArgumentList | 'type' '(' TypeName ')' | 'new' TypeName | '(' 1…*{ [ Expression ] / ',' } ')' | '[' 1…*{ Expression / ',' } ']' | «Identifier» | Literal | ElementaryTypeWithoutPayable ;

Literal = «AsciiStringLiteral» | «UnicodeStringLiteral» | NumericLiteral | «HexStringLiteral» | «BooleanLiteral» ;

NumericLiteral = ( «DecimalNumber» | «HexNumber» ) [ «NumberUnit» ] ;

Block = '{' { Statement | UncheckedBlock } '}' ;

UncheckedBlock = 'unchecked' Block ;

Statement = Block | SimpleStatement | IfStatement | ForStatement | WhileStatement | DoWhileStatement | ContinueStatement | BreakStatement | TryStatement | ReturnStatement | EmitStatement | RevertStatement | AssemblyStatement ;

SimpleStatement = VariableDeclarationStatement | ExpressionStatement ;

IfStatement = 'if' '(' Expression ')' Statement [ 'else' Statement ] ;

ForStatement = 'for' '(' ( SimpleStatement | ';' ) ( ExpressionStatement | ';' ) [ Expression ] ')' Statement ;

WhileStatement = 'while' '(' Expression ')' Statement ;

DoWhileStatement = 'do' Statement 'while' '(' Expression ')' ';' ;

ContinueStatement = 'continue' ';' ;

BreakStatement = 'break' ';' ;

TryStatement = 'try' Expression [ 'returns' NonEmptyParameterList ] Block 1…*{ CatchClause } ;

CatchClause = 'catch' [ [ «Identifier» ] NonEmptyParameterList ] Block ;

ReturnStatement = 'return' [ Expression ] ';' ;

EmitStatement = 'emit' Expression ArgumentList ';' ;

RevertStatement = 'revert' Expression ArgumentList ';' ;

TupleVariableDeclaration = '(' { ',' } VariableDeclaration { ',' [ VariableDeclaration ] } ')' ;

VariableDeclarationStatement = ( VariableDeclaration [ '=' Expression ] | TupleVariableDeclaration '=' Expression ) ';' ;

VariableDeclaration = TypeName [ DataLocation ] «Identifier» ;

ExpressionStatement = Expression ';' ;

AssemblyStatement = 'assembly' [ '"evmasm"' ] [ AssemblyFlags ] YulBlock ;

AssemblyFlags = '(' 1…*{ «DoubleQuotedAsciiStringLiteral» / ',' } ')' ;

«Identifier» = «RawIdentifier» - «ReservedWord» ;

«ReservedWord» = «Keyword» | «ReservedKeyword» | «NumberUnit» | «BooleanLiteral» ;

«Keyword» = 'pragma' | 'abstract' | 'anonymous' | 'address' | 'as' | 'assembly' | 'bool' | 'break' | 'bytes' | 'calldata' | 'catch' | 'constant' | 'constructor' | 'continue' | 'contract' | 'delete' | 'do' | 'else' | 'emit' | 'enum' | 'event' | 'external' | 'fallback' | 'false' | 'for' | 'function' | 'hex' | 'if' | 'immutable' | 'import' | 'indexed' | 'interface' | 'internal' | 'is' | 'library' | 'mapping' | 'memory' | 'modifier' | 'new' | 'override' | 'payable' | 'private' | 'public' | 'pure' | 'receive' | 'return' | 'returns' | 'storage' | 'string' | 'struct' | 'true' | 'try' | 'type' | 'unchecked' | 'using' | 'view' | 'virtual' | 'while' | «SignedIntegerType» | «UnsignedIntegerType» | «FixedBytesType» | 'fixed' | 'ufixed' ;

«ReservedKeyword» = 'after' | 'alias' | 'apply' | 'auto' | 'byte' | 'case' | 'copyof' | 'default' | 'define' | 'final' | 'implements' | 'in' | 'inline' | 'let' | 'macro' | 'match' | 'mutable' | 'null' | 'of' | 'partial' | 'promise' | 'reference' | 'relocatable' | 'sealed' | 'sizeof' | 'static' | 'supports' | 'switch' | 'typedef' | 'typeof' | 'var' ;

«PragmaDirective» = 'pragma' 1…*{ ¬';' } ';' ;

«RawIdentifier» = «IdentifierStart» { «IdentifierPart» } ;

«IdentifierStart» = '_' | '$' | 'a'…'z' | 'A'…'Z' ;

«IdentifierPart» = «IdentifierStart» | '0'…'9' ;

«SignedIntegerType» = 'int' ( '8' | '16' | '24' | '32' | '40' | '48' | '56' | '64' | '72' | '80' | '88' | '96' | '104' | '112' | '120' | '128' | '136' | '144' | '152' | '160' | '168' | '176' | '184' | '192' | '200' | '208' | '216' | '224' | '232' | '240' | '248' | '256' ) ;

«UnsignedIntegerType» = 'u' «SignedIntegerType» ;

«FixedBytesType» = 'bytes' ( '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32' ) ;

«FixedType» = 'fixed' [ '1'…'9' { '0'…'9' } 'x' '1'…'9' { '0'…'9' } ] ;

«UfixedType» = 'u' «FixedType» ;

«BooleanLiteral» = 'true' | 'false' ;

«DecimalNumber» = ( «DecimalInteger» | «DecimalFloat» ) [ «DecimalExponent» ] ;

«DecimalInteger» = 1…*{ '0'…'9' / [ '_' ] } ;

«DecimalFloat» = [ «DecimalInteger» ] '.' «DecimalInteger» ;

«DecimalExponent» = ( 'e' | 'E' ) [ '-' ] «DecimalInteger» ;

«HexNumber» = '0x' 1…*{ «HexCharacter» / [ '_' ] } ;

«NumberUnit» = 'wei' | 'gwei' | 'ether' | 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years' ;

«HexStringLiteral» = 'hex' ( '"' [ «PossiblySeparatedPairsOfHexDigits» ] '"' | '\'' [ «PossiblySeparatedPairsOfHexDigits» ] '\'' ) ;

«PossiblySeparatedPairsOfHexDigits» = 1…*{ 2…2*{ «HexCharacter» } / [ '_' ] } ;

«HexCharacter» = '0'…'9' | 'a'…'f' | 'A'…'F' ;

«AsciiStringLiteral» = «SingleQuotedAsciiStringLiteral» | «DoubleQuotedAsciiStringLiteral» ;

«SingleQuotedAsciiStringLiteral» = '\'' { 1…*{ '\u{20}'…'~' - ( '\'' | '\\' ) } | «EscapeSequence» } '\'' ;

«DoubleQuotedAsciiStringLiteral» = '"' { 1…*{ '\u{20}'…'~' - ( '"' | '\\' ) } | «EscapeSequence» } '"' ;

«UnicodeStringLiteral» = «SingleQuotedUnicodeStringLiteral» | «DoubleQuotedUnicodeStringLiteral» ;

«SingleQuotedUnicodeStringLiteral» = 'unicode\'' { 1…*{ ¬( '\'' | '\\' | '\u{a}' | '\u{d}' ) } | «EscapeSequence» } '\'' ;

«DoubleQuotedUnicodeStringLiteral» = 'unicode"' { 1…*{ ¬( '"' | '\\' | '\u{a}' | '\u{d}' ) } | «EscapeSequence» } '"' ;

«EscapeSequence» = '\\' ( «AsciiEscape» | «HexByteEscape» | «UnicodeEscape» ) ;

«AsciiEscape» = 'n' | 'r' | 't' | '\'' | '"' | '\\' | '\u{a}' | '\u{d}' ;

«HexByteEscape» = 'x' 2…2*{ «HexCharacter» } ;

«UnicodeEscape» = 'u' 4…4*{ «HexCharacter» } ;

YulBlock = '{' { YulStatement } '}' ;

YulStatement = YulBlock | YulVariableDeclaration | YulFunctionDefinition | YulAssignment | YulFunctionCall | YulIfStatement | YulForStatement | YulSwitchStatement | YulLeaveStatement | YulBreakStatement | YulContinueStatement ;

YulVariableDeclaration = 'let' «YulIdentifier» [ ':=' YulExpression | [ ',' «YulIdentifier» ] [ ':=' YulFunctionCall ] ] ;

YulFunctionDefinition = 'function' «YulIdentifier» '(' { «YulIdentifier» / ',' } ')' [ '->' 1…*{ «YulIdentifier» / ',' } ] YulBlock ;

YulAssignment = YulPath ( ':=' YulExpression | 1…*{ ',' YulPath } ':=' YulFunctionCall ) ;

YulFunctionCall = ( «YulIdentifier» | «YulEVMBuiltinFunctionName» ) '(' { YulExpression / ',' } ')' ;

YulIfStatement = 'if' YulExpression YulBlock ;

YulLeaveStatement = 'leave' ;

YulBreakStatement = 'break' ;

YulContinueStatement = 'continue' ;

YulForStatement = 'for' YulBlock YulExpression YulBlock YulBlock ;

YulSwitchStatement = 'switch' YulExpression ( 1…*{ 'case' YulLiteral YulBlock } [ 'default' YulBlock ] | 'default' YulBlock ) ;

YulExpression = YulPath | YulFunctionCall | YulLiteral ;

YulPath = «YulIdentifier» { '.' ( «YulIdentifier» | «YulEVMBuiltinFunctionName» ) } ;

YulLiteral = «YulDecimalNumberLiteral» | «YulHexLiteral» | «AsciiStringLiteral» | «BooleanLiteral» | «HexStringLiteral» ;

«YulIdentifier» = «RawIdentifier» - «YulReservedWord» ;

«YulReservedWord» = «YulKeyword» | «YulEVMBuiltinFunctionName» | «BooleanLiteral» ;

«YulKeyword» = 'break' | 'case' | 'continue' | 'default' | 'for' | 'function' | 'if' | 'leave' | 'let' | 'switch' | 'hex' ;

«YulEVMBuiltinFunctionName» = 'stop' | 'add' | 'sub' | 'mul' | 'div' | 'sdiv' | 'mod' | 'smod' | 'exp' | 'not' | 'lt' | 'gt' | 'slt' | 'sgt' | 'eq' | 'iszero' | 'and' | 'or' | 'xor' | 'byte' | 'shl' | 'shr' | 'sar' | 'addmod' | 'mulmod' | 'signextend' | 'keccak256' | 'pop' | 'mload' | 'mstore' | 'mstore8' | 'sload' | 'sstore' | 'msize' | 'gas' | 'address' | 'balance' | 'selfbalance' | 'caller' | 'callvalue' | 'calldataload' | 'calldatasize' | 'calldatacopy' | 'extcodesize' | 'extcodecopy' | 'returndatasize' | 'returndatacopy' | 'extcodehash' | 'create' | 'create2' | 'call' | 'callcode' | 'delegatecall' | 'staticcall' | 'return' | 'revert' | 'selfdestruct' | 'invalid' | 'log0' | 'log1' | 'log2' | 'log3' | 'log4' | 'chainid' | 'origin' | 'gasprice' | 'Blockhash' | 'coinbase' | 'timestamp' | 'number' | 'difficulty' | 'gaslimit' | 'basefee' ;

«YulDecimalNumberLiteral» = '0' | '1'…'9' { '0'…'9' } ;

«YulHexLiteral» = '0x' 1…*{ '0'…'9' | 'a'…'f' | 'A'…'F' } ;
