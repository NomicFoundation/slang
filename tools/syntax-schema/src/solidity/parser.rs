use chumsky::{prelude::*, Parser};

use super::builder;
pub type SourceUnitParserResultType = ();

pub fn create_source_unit_parser(
) -> impl Parser<char, SourceUnitParserResultType, Error = Simple<char>> {
    let mut yul_function_call_parser = Recursive::declare();
    let mut yul_block_parser = Recursive::declare();
    let mut type_name_parser = Recursive::declare();
    let mut statement_parser = Recursive::declare();
    let mut block_parser = Recursive::declare();
    let mut expression_parser = Recursive::declare();
    let ascii_escape_parser = choice((
        just('n').ignored(),
        just('r').ignored(),
        just('t').ignored(),
        just('\'').ignored(),
        just('"').ignored(),
        just('\\').ignored(),
        just('\n').ignored(),
        just('\r').ignored(),
    ))
    .ignored();
    let boolean_literal_parser =
        choice((just("true").ignored(), just("false").ignored())).ignored();
    let comment_parser = just("/*")
        .ignored()
        .ignore_then(
            choice((
                filter(|&c: &char| c != '*').ignored(),
                just('*')
                    .repeated()
                    .at_least(1usize)
                    .ignored()
                    .then(none_of("*/").ignored())
                    .ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .then(just('*').repeated().at_least(1usize).ignored())
        .then_ignore(just('/').ignored())
        .ignored();
    let decimal_integer_parser = filter(|&c: &char| c.is_ascii_digit())
        .separated_by(just('_').or_not())
        .at_least(1usize)
        .ignored();
    let fixed_parser = just("fixed")
        .ignored()
        .ignore_then(
            filter(|&c: &char| ('1' <= c && c <= '9'))
                .ignored()
                .then(filter(|&c: &char| c.is_ascii_digit()).repeated().ignored())
                .then_ignore(just('x').ignored())
                .then(filter(|&c: &char| ('1' <= c && c <= '9')).ignored())
                .then(filter(|&c: &char| c.is_ascii_digit()).repeated().ignored())
                .or_not()
                .ignored(),
        )
        .ignored();
    let fixed_bytes_parser = just("bytes")
        .ignored()
        .ignore_then(
            choice((
                just('1').ignored(),
                just('2').ignored(),
                just('3').ignored(),
                just('4').ignored(),
                just('5').ignored(),
                just('6').ignored(),
                just('7').ignored(),
                just('8').ignored(),
                just('9').ignored(),
                just("10").ignored(),
                just("11").ignored(),
                just("12").ignored(),
                just("13").ignored(),
                just("14").ignored(),
                just("15").ignored(),
                just("16").ignored(),
                just("17").ignored(),
                just("18").ignored(),
                just("19").ignored(),
                just("20").ignored(),
                just("21").ignored(),
                just("22").ignored(),
                just("23").ignored(),
                just("24").ignored(),
                just("25").ignored(),
                just("26").ignored(),
                just("27").ignored(),
                just("28").ignored(),
                just("29").ignored(),
                just("30").ignored(),
                just("31").ignored(),
                just("32").ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let hex_character_parser = choice((
        filter(|&c: &char| c.is_ascii_digit()).ignored(),
        filter(|&c: &char| ('a' <= c && c <= 'f')).ignored(),
        filter(|&c: &char| ('A' <= c && c <= 'F')).ignored(),
    ))
    .ignored();
    let identifier_start_parser = choice((
        just('_').ignored(),
        just('$').ignored(),
        filter(|&c: &char| c.is_ascii_lowercase()).ignored(),
        filter(|&c: &char| c.is_ascii_uppercase()).ignored(),
    ))
    .ignored();
    let line_comment_parser = just("//")
        .ignored()
        .ignore_then(none_of("\n\r").repeated().ignored())
        .ignored();
    let number_unit_parser = choice((
        just("wei").ignored(),
        just("gwei").ignored(),
        just("ether").ignored(),
        just("seconds").ignored(),
        just("minutes").ignored(),
        just("hours").ignored(),
        just("days").ignored(),
        just("weeks").ignored(),
        just("years").ignored(),
    ))
    .ignored();
    let signed_integer_type_parser = just("int")
        .ignored()
        .ignore_then(
            choice((
                just('8').ignored(),
                just("16").ignored(),
                just("24").ignored(),
                just("32").ignored(),
                just("40").ignored(),
                just("48").ignored(),
                just("56").ignored(),
                just("64").ignored(),
                just("72").ignored(),
                just("80").ignored(),
                just("88").ignored(),
                just("96").ignored(),
                just("104").ignored(),
                just("112").ignored(),
                just("120").ignored(),
                just("128").ignored(),
                just("136").ignored(),
                just("144").ignored(),
                just("152").ignored(),
                just("160").ignored(),
                just("168").ignored(),
                just("176").ignored(),
                just("184").ignored(),
                just("192").ignored(),
                just("200").ignored(),
                just("208").ignored(),
                just("216").ignored(),
                just("224").ignored(),
                just("232").ignored(),
                just("240").ignored(),
                just("248").ignored(),
                just("256").ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let whitespace_parser = choice((
        just(' ').ignored(),
        just('\t').ignored(),
        just('\r').ignored(),
        just('\n').ignored(),
    ))
    .ignored();
    let yul_decimal_number_literal_parser = choice((
        just('0').ignored(),
        filter(|&c: &char| ('1' <= c && c <= '9'))
            .ignored()
            .then(filter(|&c: &char| c.is_ascii_digit()).repeated().ignored())
            .ignored(),
    ))
    .ignored();
    let yul_hex_literal_parser = just("0x")
        .ignored()
        .ignore_then(
            choice((
                filter(|&c: &char| c.is_ascii_digit()).ignored(),
                filter(|&c: &char| ('a' <= c && c <= 'f')).ignored(),
                filter(|&c: &char| ('A' <= c && c <= 'F')).ignored(),
            ))
            .ignored(),
        )
        .then(
            choice((
                filter(|&c: &char| c.is_ascii_digit()).ignored(),
                filter(|&c: &char| ('a' <= c && c <= 'f')).ignored(),
                filter(|&c: &char| ('A' <= c && c <= 'F')).ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .ignored();
    let pragma_directive_parser = just("pragma")
        .ignored()
        .ignore_then(filter(|&c: &char| c != ';').ignored())
        .then(filter(|&c: &char| c != ';').repeated().ignored())
        .then_ignore(just(';').ignored())
        .ignored();
    let decimal_exponent_parser = choice((just('e').ignored(), just('E').ignored()))
        .ignored()
        .then(just('-').or_not().ignored())
        .then(decimal_integer_parser.clone().ignored())
        .ignored();
    let decimal_float_parser = decimal_integer_parser
        .clone()
        .or_not()
        .ignored()
        .then_ignore(just('.').ignored())
        .then(decimal_integer_parser.clone().ignored())
        .ignored();
    let hex_byte_escape_parser = just('x')
        .ignored()
        .ignore_then(
            hex_character_parser
                .clone()
                .repeated()
                .at_least(2usize)
                .at_most(2usize)
                .ignored(),
        )
        .ignored();
    let hex_number_parser = just('0')
        .ignored()
        .ignore_then(just('x').ignored())
        .ignore_then(
            hex_character_parser
                .clone()
                .separated_by(just('_').or_not())
                .at_least(1usize)
                .ignored(),
        )
        .ignored();
    let ignore_parser = choice((
        whitespace_parser.clone().ignored(),
        comment_parser.clone().ignored(),
        line_comment_parser.clone().ignored(),
    ))
    .repeated()
    .ignored();
    let identifier_part_parser = choice((
        identifier_start_parser.clone().ignored(),
        filter(|&c: &char| c.is_ascii_digit()).ignored(),
    ))
    .ignored();
    let possibly_separated_pairs_of_hex_digits_parser = hex_character_parser
        .clone()
        .repeated()
        .at_least(2usize)
        .at_most(2usize)
        .separated_by(just('_').or_not())
        .at_least(1usize)
        .ignored();
    let ufixed_parser = just('u')
        .ignored()
        .ignore_then(fixed_parser.clone().ignored())
        .ignored();
    let unicode_escape_parser = just('u')
        .ignored()
        .ignore_then(
            hex_character_parser
                .clone()
                .repeated()
                .at_least(4usize)
                .at_most(4usize)
                .ignored(),
        )
        .ignored();
    let unsigned_integer_type_parser = just('u')
        .ignored()
        .ignore_then(signed_integer_type_parser.clone().ignored())
        .ignored();
    let decimal_number_parser = choice((
        decimal_integer_parser.clone().ignored(),
        decimal_float_parser.clone().ignored(),
    ))
    .ignored()
    .then(decimal_exponent_parser.clone().or_not().ignored())
    .ignored();
    let escape_sequence_parser = just('\\')
        .ignored()
        .ignore_then(
            choice((
                ascii_escape_parser.clone().ignored(),
                hex_byte_escape_parser.clone().ignored(),
                unicode_escape_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let hex_string_literal_parser = just("hex")
        .ignored()
        .ignore_then(
            choice((
                just('"')
                    .ignored()
                    .ignore_then(
                        possibly_separated_pairs_of_hex_digits_parser
                            .clone()
                            .or_not()
                            .ignored(),
                    )
                    .then_ignore(just('"').ignored())
                    .ignored(),
                just('\'')
                    .ignored()
                    .ignore_then(
                        possibly_separated_pairs_of_hex_digits_parser
                            .clone()
                            .or_not()
                            .ignored(),
                    )
                    .then_ignore(just('\'').ignored())
                    .ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let raw_identifier_parser = identifier_start_parser
        .clone()
        .ignored()
        .then(identifier_part_parser.clone().repeated().ignored())
        .ignored();
    let break_statement_parser = just("break")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let continue_statement_parser = just("continue")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let data_location_parser = choice((
        just("memory").then_ignore(ignore_parser.clone()).ignored(),
        just("storage").then_ignore(ignore_parser.clone()).ignored(),
        just("calldata")
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let elementary_type_parser = choice((
        just("bool").then_ignore(ignore_parser.clone()).ignored(),
        just("string").then_ignore(ignore_parser.clone()).ignored(),
        just("bytes").then_ignore(ignore_parser.clone()).ignored(),
        signed_integer_type_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        unsigned_integer_type_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        fixed_bytes_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        fixed_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        ufixed_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let inline_array_expression_parser = just('[')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            expression_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just(']').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let keyword_parser = choice((
        just("pragma").then_ignore(ignore_parser.clone()).ignored(),
        just("abstract")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("anonymous")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("address").then_ignore(ignore_parser.clone()).ignored(),
        just("as").then_ignore(ignore_parser.clone()).ignored(),
        just("assembly")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("bool").then_ignore(ignore_parser.clone()).ignored(),
        just("break").then_ignore(ignore_parser.clone()).ignored(),
        just("bytes").then_ignore(ignore_parser.clone()).ignored(),
        just("calldata")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("catch").then_ignore(ignore_parser.clone()).ignored(),
        just("constant")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("constructor")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("continue")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("contract")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("delete").then_ignore(ignore_parser.clone()).ignored(),
        just("do").then_ignore(ignore_parser.clone()).ignored(),
        just("else").then_ignore(ignore_parser.clone()).ignored(),
        just("emit").then_ignore(ignore_parser.clone()).ignored(),
        just("enum").then_ignore(ignore_parser.clone()).ignored(),
        just("event").then_ignore(ignore_parser.clone()).ignored(),
        just("external")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("fallback")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("false").then_ignore(ignore_parser.clone()).ignored(),
        just("for").then_ignore(ignore_parser.clone()).ignored(),
        just("function")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("hex").then_ignore(ignore_parser.clone()).ignored(),
        just("if").then_ignore(ignore_parser.clone()).ignored(),
        just("immutable")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("import").then_ignore(ignore_parser.clone()).ignored(),
        just("indexed").then_ignore(ignore_parser.clone()).ignored(),
        just("interface")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("internal")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("is").then_ignore(ignore_parser.clone()).ignored(),
        just("library").then_ignore(ignore_parser.clone()).ignored(),
        just("mapping").then_ignore(ignore_parser.clone()).ignored(),
        just("memory").then_ignore(ignore_parser.clone()).ignored(),
        just("modifier")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("new").then_ignore(ignore_parser.clone()).ignored(),
        just("override")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("payable").then_ignore(ignore_parser.clone()).ignored(),
        just("private").then_ignore(ignore_parser.clone()).ignored(),
        just("public").then_ignore(ignore_parser.clone()).ignored(),
        just("pure").then_ignore(ignore_parser.clone()).ignored(),
        just("receive").then_ignore(ignore_parser.clone()).ignored(),
        just("return").then_ignore(ignore_parser.clone()).ignored(),
        just("returns").then_ignore(ignore_parser.clone()).ignored(),
        just("storage").then_ignore(ignore_parser.clone()).ignored(),
        just("string").then_ignore(ignore_parser.clone()).ignored(),
        just("struct").then_ignore(ignore_parser.clone()).ignored(),
        just("true").then_ignore(ignore_parser.clone()).ignored(),
        just("try").then_ignore(ignore_parser.clone()).ignored(),
        just("type").then_ignore(ignore_parser.clone()).ignored(),
        just("unchecked")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("using").then_ignore(ignore_parser.clone()).ignored(),
        just("view").then_ignore(ignore_parser.clone()).ignored(),
        just("virtual").then_ignore(ignore_parser.clone()).ignored(),
        just("while").then_ignore(ignore_parser.clone()).ignored(),
        signed_integer_type_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        unsigned_integer_type_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        fixed_bytes_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("fixed").then_ignore(ignore_parser.clone()).ignored(),
        just("ufixed").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let positional_argument_list_parser = expression_parser
        .clone()
        .separated_by(just(',').then_ignore(ignore_parser.clone()))
        .at_least(1usize)
        .ignored();
    let reserved_keyword_parser = choice((
        just("after").then_ignore(ignore_parser.clone()).ignored(),
        just("alias").then_ignore(ignore_parser.clone()).ignored(),
        just("apply").then_ignore(ignore_parser.clone()).ignored(),
        just("auto").then_ignore(ignore_parser.clone()).ignored(),
        just("byte").then_ignore(ignore_parser.clone()).ignored(),
        just("case").then_ignore(ignore_parser.clone()).ignored(),
        just("copyof").then_ignore(ignore_parser.clone()).ignored(),
        just("default").then_ignore(ignore_parser.clone()).ignored(),
        just("define").then_ignore(ignore_parser.clone()).ignored(),
        just("final").then_ignore(ignore_parser.clone()).ignored(),
        just("implements")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("in").then_ignore(ignore_parser.clone()).ignored(),
        just("inline").then_ignore(ignore_parser.clone()).ignored(),
        just("let").then_ignore(ignore_parser.clone()).ignored(),
        just("macro").then_ignore(ignore_parser.clone()).ignored(),
        just("match").then_ignore(ignore_parser.clone()).ignored(),
        just("mutable").then_ignore(ignore_parser.clone()).ignored(),
        just("null").then_ignore(ignore_parser.clone()).ignored(),
        just("of").then_ignore(ignore_parser.clone()).ignored(),
        just("partial").then_ignore(ignore_parser.clone()).ignored(),
        just("promise").then_ignore(ignore_parser.clone()).ignored(),
        just("reference")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("relocatable")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("sealed").then_ignore(ignore_parser.clone()).ignored(),
        just("sizeof").then_ignore(ignore_parser.clone()).ignored(),
        just("static").then_ignore(ignore_parser.clone()).ignored(),
        just("supports")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("switch").then_ignore(ignore_parser.clone()).ignored(),
        just("typedef").then_ignore(ignore_parser.clone()).ignored(),
        just("typeof").then_ignore(ignore_parser.clone()).ignored(),
        just("var").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let state_mutability_specifier_parser = choice((
        just("pure").then_ignore(ignore_parser.clone()).ignored(),
        just("view").then_ignore(ignore_parser.clone()).ignored(),
        just("payable").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let tuple_expression_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            expression_parser
                .clone()
                .or_not()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let unchecked_block_parser = just("unchecked")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(block_parser.clone().ignored())
        .ignored();
    let visibility_specifier_parser = choice((
        just("internal")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("external")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("private").then_ignore(ignore_parser.clone()).ignored(),
        just("public").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let yul_break_statement_parser = just("break").then_ignore(ignore_parser.clone()).ignored();
    let yul_continue_statement_parser = just("continue")
        .then_ignore(ignore_parser.clone())
        .ignored();
    let yul_evm_builtin_function_name_parser = choice((
        just("stop").then_ignore(ignore_parser.clone()).ignored(),
        just("add").then_ignore(ignore_parser.clone()).ignored(),
        just("sub").then_ignore(ignore_parser.clone()).ignored(),
        just("mul").then_ignore(ignore_parser.clone()).ignored(),
        just("div").then_ignore(ignore_parser.clone()).ignored(),
        just("sdiv").then_ignore(ignore_parser.clone()).ignored(),
        just("mod").then_ignore(ignore_parser.clone()).ignored(),
        just("smod").then_ignore(ignore_parser.clone()).ignored(),
        just("exp").then_ignore(ignore_parser.clone()).ignored(),
        just("not").then_ignore(ignore_parser.clone()).ignored(),
        just("lt").then_ignore(ignore_parser.clone()).ignored(),
        just("gt").then_ignore(ignore_parser.clone()).ignored(),
        just("slt").then_ignore(ignore_parser.clone()).ignored(),
        just("sgt").then_ignore(ignore_parser.clone()).ignored(),
        just("eq").then_ignore(ignore_parser.clone()).ignored(),
        just("iszero").then_ignore(ignore_parser.clone()).ignored(),
        just("and").then_ignore(ignore_parser.clone()).ignored(),
        just("or").then_ignore(ignore_parser.clone()).ignored(),
        just("xor").then_ignore(ignore_parser.clone()).ignored(),
        just("byte").then_ignore(ignore_parser.clone()).ignored(),
        just("shl").then_ignore(ignore_parser.clone()).ignored(),
        just("shr").then_ignore(ignore_parser.clone()).ignored(),
        just("sar").then_ignore(ignore_parser.clone()).ignored(),
        just("addmod").then_ignore(ignore_parser.clone()).ignored(),
        just("mulmod").then_ignore(ignore_parser.clone()).ignored(),
        just("signextend")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("keccak256")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("pop").then_ignore(ignore_parser.clone()).ignored(),
        just("mload").then_ignore(ignore_parser.clone()).ignored(),
        just("mstore").then_ignore(ignore_parser.clone()).ignored(),
        just("mstore8").then_ignore(ignore_parser.clone()).ignored(),
        just("sload").then_ignore(ignore_parser.clone()).ignored(),
        just("sstore").then_ignore(ignore_parser.clone()).ignored(),
        just("msize").then_ignore(ignore_parser.clone()).ignored(),
        just("gas").then_ignore(ignore_parser.clone()).ignored(),
        just("address").then_ignore(ignore_parser.clone()).ignored(),
        just("balance").then_ignore(ignore_parser.clone()).ignored(),
        just("selfbalance")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("caller").then_ignore(ignore_parser.clone()).ignored(),
        just("callvalue")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("calldataload")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("calldatasize")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("calldatacopy")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("extcodesize")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("extcodecopy")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("returndatasize")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("returndatacopy")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("extcodehash")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("create").then_ignore(ignore_parser.clone()).ignored(),
        just("create2").then_ignore(ignore_parser.clone()).ignored(),
        just("call").then_ignore(ignore_parser.clone()).ignored(),
        just("callcode")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("delegatecall")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("staticcall")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("return").then_ignore(ignore_parser.clone()).ignored(),
        just("revert").then_ignore(ignore_parser.clone()).ignored(),
        just("selfdestruct")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("invalid").then_ignore(ignore_parser.clone()).ignored(),
        just("log0").then_ignore(ignore_parser.clone()).ignored(),
        just("log1").then_ignore(ignore_parser.clone()).ignored(),
        just("log2").then_ignore(ignore_parser.clone()).ignored(),
        just("log3").then_ignore(ignore_parser.clone()).ignored(),
        just("log4").then_ignore(ignore_parser.clone()).ignored(),
        just("chainid").then_ignore(ignore_parser.clone()).ignored(),
        just("origin").then_ignore(ignore_parser.clone()).ignored(),
        just("gasprice")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("blockhash")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("coinbase")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("timestamp")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("number").then_ignore(ignore_parser.clone()).ignored(),
        just("difficulty")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("gaslimit")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("basefee").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let yul_keyword_parser = choice((
        just("break").then_ignore(ignore_parser.clone()).ignored(),
        just("case").then_ignore(ignore_parser.clone()).ignored(),
        just("continue")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("default").then_ignore(ignore_parser.clone()).ignored(),
        just("for").then_ignore(ignore_parser.clone()).ignored(),
        just("function")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("if").then_ignore(ignore_parser.clone()).ignored(),
        just("leave").then_ignore(ignore_parser.clone()).ignored(),
        just("let").then_ignore(ignore_parser.clone()).ignored(),
        just("switch").then_ignore(ignore_parser.clone()).ignored(),
        just("hex").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let yul_leave_statement_parser = just("leave").then_ignore(ignore_parser.clone()).ignored();
    let double_quoted_ascii_string_literal_parser = just('"')
        .ignored()
        .ignore_then(
            choice((todo().ignored(), escape_sequence_parser.clone().ignored()))
                .repeated()
                .ignored(),
        )
        .then_ignore(just('"').ignored())
        .ignored();
    let double_quoted_unicode_string_literal_parser = just("unicode\"")
        .ignored()
        .ignore_then(
            choice((
                none_of("\"\\\n\r").ignored(),
                escape_sequence_parser.clone().ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .then_ignore(just('"').ignored())
        .ignored();
    let single_quoted_ascii_string_literal_parser = just('\'')
        .ignored()
        .ignore_then(
            choice((todo().ignored(), escape_sequence_parser.clone().ignored()))
                .repeated()
                .ignored(),
        )
        .then_ignore(just('\'').ignored())
        .ignored();
    let single_quoted_unicode_string_literal_parser = just("unicode'")
        .ignored()
        .ignore_then(
            choice((
                none_of("'\\\n\r").ignored(),
                escape_sequence_parser.clone().ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .then_ignore(just('\'').ignored())
        .ignored();
    let elementary_type_with_payable_parser = choice((
        just("address")
            .then_ignore(ignore_parser.clone())
            .ignored()
            .ignore_then(
                just("payable")
                    .then_ignore(ignore_parser.clone())
                    .or_not()
                    .ignored(),
            )
            .ignored(),
        elementary_type_parser.clone().ignored(),
    ))
    .ignored();
    let elementary_type_without_payable_parser = choice((
        just("address").then_ignore(ignore_parser.clone()).ignored(),
        elementary_type_parser.clone().ignored(),
    ))
    .ignored();
    let numeric_literal_parser = choice((
        decimal_number_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        hex_number_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored()
    .then(
        number_unit_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .or_not()
            .ignored(),
    )
    .ignored();
    let reserved_word_parser = choice((
        keyword_parser.clone().ignored(),
        reserved_keyword_parser.clone().ignored(),
        number_unit_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        boolean_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let yul_reserved_word_parser = choice((
        yul_keyword_parser.clone().ignored(),
        yul_evm_builtin_function_name_parser.clone().ignored(),
        boolean_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let ascii_string_literal_parser = choice((
        single_quoted_ascii_string_literal_parser.clone().ignored(),
        double_quoted_ascii_string_literal_parser.clone().ignored(),
    ))
    .ignored();
    let unicode_string_literal_parser = choice((
        single_quoted_unicode_string_literal_parser
            .clone()
            .ignored(),
        double_quoted_unicode_string_literal_parser
            .clone()
            .ignored(),
    ))
    .ignored();
    let assembly_flags_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            double_quoted_ascii_string_literal_parser
                .clone()
                .then_ignore(ignore_parser.clone())
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let identifier_parser = todo().ignored();
    let yul_identifier_parser = todo().ignored();
    let ascii_string_literal_parser = ascii_string_literal_parser
        .clone()
        .then_ignore(ignore_parser.clone())
        .repeated()
        .at_least(1usize)
        .ignored();
    let enum_definition_parser = just("enum")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
        .then(
            identifier_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let identifier_path_parser = identifier_parser
        .clone()
        .separated_by(just('.').then_ignore(ignore_parser.clone()))
        .at_least(1usize)
        .ignored();
    let named_argument_parser = identifier_parser
        .clone()
        .ignored()
        .then_ignore(just(':').then_ignore(ignore_parser.clone()).ignored())
        .then(expression_parser.clone().ignored())
        .ignored();
    let parameter_declaration_parser = type_name_parser
        .clone()
        .ignored()
        .then(data_location_parser.clone().or_not().ignored())
        .then(identifier_parser.clone().or_not().ignored())
        .ignored();
    let selected_import_parser = identifier_parser
        .clone()
        .ignored()
        .then(
            just("as")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(identifier_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .ignored();
    let unicode_string_literal_parser = unicode_string_literal_parser
        .clone()
        .then_ignore(ignore_parser.clone())
        .repeated()
        .at_least(1usize)
        .ignored();
    let user_defined_value_type_definition_parser = just("type")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just("is").then_ignore(ignore_parser.clone()).ignored())
        .then(elementary_type_with_payable_parser.clone().ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let yul_function_definition_parser = just("function")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(yul_identifier_parser.clone().ignored())
        .then_ignore(just('(').then_ignore(ignore_parser.clone()).ignored())
        .then(
            yul_identifier_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then(
            just("->")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(
                    yul_identifier_parser
                        .clone()
                        .separated_by(just(',').then_ignore(ignore_parser.clone()))
                        .at_least(1usize)
                        .ignored(),
                )
                .or_not()
                .ignored(),
        )
        .then(yul_block_parser.clone().ignored())
        .ignored();
    let yul_path_parser = yul_identifier_parser
        .clone()
        .ignored()
        .then(
            just('.')
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(
                    choice((
                        yul_identifier_parser.clone().ignored(),
                        yul_evm_builtin_function_name_parser.clone().ignored(),
                    ))
                    .ignored(),
                )
                .repeated()
                .ignored(),
        )
        .ignored();
    let import_path_parser = ascii_string_literal_parser.clone().ignored();
    let literal_parser = choice((
        ascii_string_literal_parser.clone().ignored(),
        unicode_string_literal_parser.clone().ignored(),
        numeric_literal_parser.clone().ignored(),
        hex_string_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        boolean_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let mapping_type_parser = just("mapping")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(
            choice((
                elementary_type_without_payable_parser.clone().ignored(),
                identifier_path_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .then_ignore(just("=>").then_ignore(ignore_parser.clone()).ignored())
        .then(type_name_parser.clone().ignored())
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let named_argument_list_parser = just('{')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            named_argument_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let non_empty_parameter_list_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            parameter_declaration_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let override_specifier_parser = just("override")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            just('(')
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(
                    identifier_path_parser
                        .clone()
                        .separated_by(just(',').then_ignore(ignore_parser.clone()))
                        .at_least(1usize)
                        .at_most(1usize)
                        .ignored(),
                )
                .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
                .or_not()
                .ignored(),
        )
        .ignored();
    let parameter_list_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            parameter_declaration_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let yul_literal_parser = choice((
        yul_decimal_number_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        yul_hex_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        ascii_string_literal_parser.clone().ignored(),
        boolean_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        hex_string_literal_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let argument_list_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            choice((
                positional_argument_list_parser.clone().ignored(),
                named_argument_list_parser.clone().ignored(),
            ))
            .or_not()
            .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let catch_clause_parser = just("catch")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            identifier_parser
                .clone()
                .or_not()
                .ignored()
                .then(non_empty_parameter_list_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .then(block_parser.clone().ignored())
        .ignored();
    let function_type_parser = just("function")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(parameter_list_parser.clone().ignored())
        .then(
            choice((
                visibility_specifier_parser.clone().ignored(),
                state_mutability_specifier_parser.clone().ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .then(
            just("returns")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(non_empty_parameter_list_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .ignored();
    let method_attribute_parser = choice((
        just("virtual").then_ignore(ignore_parser.clone()).ignored(),
        override_specifier_parser.clone().ignored(),
    ))
    .ignored();
    let selecting_import_directive_parser = just('{')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            selected_import_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .then_ignore(just("from").then_ignore(ignore_parser.clone()).ignored())
        .then(import_path_parser.clone().ignored())
        .ignored();
    let simple_import_directive_parser = import_path_parser
        .clone()
        .ignored()
        .then(
            just("as")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(identifier_parser.clone().ignored())
                .repeated()
                .ignored(),
        )
        .ignored();
    let star_import_directive_parser = just('*')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just("as").then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just("from").then_ignore(ignore_parser.clone()).ignored())
        .then(import_path_parser.clone().ignored())
        .ignored();
    let state_variable_attribute_parser = choice((
        just("public").then_ignore(ignore_parser.clone()).ignored(),
        just("private").then_ignore(ignore_parser.clone()).ignored(),
        just("internal")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("constant")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        override_specifier_parser.clone().ignored(),
        just("immutable")
            .then_ignore(ignore_parser.clone())
            .ignored(),
    ))
    .ignored();
    let yul_expression_parser = choice((
        yul_path_parser.clone().ignored(),
        yul_function_call_parser.clone().ignored(),
        yul_literal_parser.clone().ignored(),
    ))
    .ignored();
    expression_parser.define(
        choice((
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('[').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().or_not().ignored())
                .then(
                    just(':')
                        .then_ignore(ignore_parser.clone())
                        .ignored()
                        .ignore_then(expression_parser.clone().or_not().ignored())
                        .or_not()
                        .ignored(),
                )
                .then_ignore(just(']').then_ignore(ignore_parser.clone()).ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('.').then_ignore(ignore_parser.clone()).ignored())
                .then(
                    choice((
                        identifier_parser.clone().ignored(),
                        just("address").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
                .then(
                    named_argument_parser
                        .clone()
                        .separated_by(just(',').then_ignore(ignore_parser.clone()))
                        .at_least(1usize)
                        .ignored(),
                )
                .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(argument_list_parser.clone().ignored())
                .ignored(),
            just("payable")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(argument_list_parser.clone().ignored())
                .ignored(),
            just("type")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
                .ignore_then(type_name_parser.clone().ignored())
                .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
                .ignored(),
            choice((
                just("++").then_ignore(ignore_parser.clone()).ignored(),
                just("--").then_ignore(ignore_parser.clone()).ignored(),
                just('!').then_ignore(ignore_parser.clone()).ignored(),
                just('~').then_ignore(ignore_parser.clone()).ignored(),
                just("delete").then_ignore(ignore_parser.clone()).ignored(),
                just('-').then_ignore(ignore_parser.clone()).ignored(),
            ))
            .ignored()
            .then(expression_parser.clone().ignored())
            .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just("++").then_ignore(ignore_parser.clone()).ignored(),
                        just("--").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just("**").then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just('*').then_ignore(ignore_parser.clone()).ignored(),
                        just('/').then_ignore(ignore_parser.clone()).ignored(),
                        just('%').then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just('+').then_ignore(ignore_parser.clone()).ignored(),
                        just('-').then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just("<<").then_ignore(ignore_parser.clone()).ignored(),
                        just(">>").then_ignore(ignore_parser.clone()).ignored(),
                        just(">>>").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('&').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('^').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('|').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just('<').then_ignore(ignore_parser.clone()).ignored(),
                        just('>').then_ignore(ignore_parser.clone()).ignored(),
                        just("<=").then_ignore(ignore_parser.clone()).ignored(),
                        just(">=").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just("==").then_ignore(ignore_parser.clone()).ignored(),
                        just("!=").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just("&&").then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just("||").then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then_ignore(just('?').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .then_ignore(just(':').then_ignore(ignore_parser.clone()).ignored())
                .then(expression_parser.clone().ignored())
                .ignored(),
            expression_parser
                .clone()
                .ignored()
                .then(
                    choice((
                        just('=').then_ignore(ignore_parser.clone()).ignored(),
                        just("|=").then_ignore(ignore_parser.clone()).ignored(),
                        just("^=").then_ignore(ignore_parser.clone()).ignored(),
                        just("&=").then_ignore(ignore_parser.clone()).ignored(),
                        just("<<=").then_ignore(ignore_parser.clone()).ignored(),
                        just(">>=").then_ignore(ignore_parser.clone()).ignored(),
                        just(">>>=").then_ignore(ignore_parser.clone()).ignored(),
                        just("+=").then_ignore(ignore_parser.clone()).ignored(),
                        just("-=").then_ignore(ignore_parser.clone()).ignored(),
                        just("*=").then_ignore(ignore_parser.clone()).ignored(),
                        just("/=").then_ignore(ignore_parser.clone()).ignored(),
                        just("%=").then_ignore(ignore_parser.clone()).ignored(),
                    ))
                    .ignored(),
                )
                .then(expression_parser.clone().ignored())
                .ignored(),
            just("new")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(type_name_parser.clone().ignored())
                .ignored(),
            tuple_expression_parser.clone().ignored(),
            inline_array_expression_parser.clone().ignored(),
            choice((
                identifier_parser.clone().ignored(),
                literal_parser.clone().ignored(),
                elementary_type_without_payable_parser.clone().ignored(),
            ))
            .ignored(),
        ))
        .ignored(),
    );
    let import_directive_parser = just("import")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            choice((
                simple_import_directive_parser.clone().ignored(),
                star_import_directive_parser.clone().ignored(),
                selecting_import_directive_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let inheritance_specifier_parser = identifier_path_parser
        .clone()
        .ignored()
        .then(argument_list_parser.clone().or_not().ignored())
        .ignored();
    let modifier_invocation_parser = identifier_path_parser
        .clone()
        .ignored()
        .then(argument_list_parser.clone().or_not().ignored())
        .ignored();
    let yul_for_statement_parser = just("for")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(yul_block_parser.clone().ignored())
        .then(yul_expression_parser.clone().ignored())
        .then(yul_block_parser.clone().ignored())
        .then(yul_block_parser.clone().ignored())
        .ignored();
    yul_function_call_parser.define(
        choice((
            yul_identifier_parser.clone().ignored(),
            yul_evm_builtin_function_name_parser.clone().ignored(),
        ))
        .ignored()
        .then_ignore(just('(').then_ignore(ignore_parser.clone()).ignored())
        .then(
            yul_expression_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored(),
    );
    let yul_if_statement_parser = just("if")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(yul_expression_parser.clone().ignored())
        .then(yul_block_parser.clone().ignored())
        .ignored();
    let yul_switch_statement_parser = just("switch")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(yul_expression_parser.clone().ignored())
        .then(
            choice((
                just("case")
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_literal_parser.clone().ignored())
                    .then(yul_block_parser.clone().ignored())
                    .repeated()
                    .at_least(1usize)
                    .ignored()
                    .then(
                        just("default")
                            .then_ignore(ignore_parser.clone())
                            .ignored()
                            .ignore_then(yul_block_parser.clone().ignored())
                            .or_not()
                            .ignored(),
                    )
                    .ignored(),
                just("default")
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_block_parser.clone().ignored())
                    .ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let constructor_attribute_parser = choice((
        modifier_invocation_parser.clone().ignored(),
        just("payable").then_ignore(ignore_parser.clone()).ignored(),
        just("internal")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("public").then_ignore(ignore_parser.clone()).ignored(),
    ))
    .ignored();
    let do_while_statement_parser = just("do")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(statement_parser.clone().ignored())
        .then_ignore(just("while").then_ignore(ignore_parser.clone()).ignored())
        .then_ignore(just('(').then_ignore(ignore_parser.clone()).ignored())
        .then(expression_parser.clone().ignored())
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let emit_statement_parser = just("emit")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(expression_parser.clone().ignored())
        .then(argument_list_parser.clone().ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let expression_statement_parser = expression_parser
        .clone()
        .ignored()
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let fallback_function_attribute_parser = choice((
        just("external")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        state_mutability_specifier_parser.clone().ignored(),
        modifier_invocation_parser.clone().ignored(),
        just("virtual").then_ignore(ignore_parser.clone()).ignored(),
        override_specifier_parser.clone().ignored(),
    ))
    .ignored();
    let function_attribute_parser = choice((
        visibility_specifier_parser.clone().ignored(),
        state_mutability_specifier_parser.clone().ignored(),
        modifier_invocation_parser.clone().ignored(),
        just("virtual").then_ignore(ignore_parser.clone()).ignored(),
        override_specifier_parser.clone().ignored(),
    ))
    .ignored();
    let if_statement_parser = just("if")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(expression_parser.clone().ignored())
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then(statement_parser.clone().ignored())
        .then(
            just("else")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(statement_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .ignored();
    let inheritance_specifier_list_parser = just("is")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            inheritance_specifier_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .at_least(1usize)
                .ignored(),
        )
        .ignored();
    let receive_function_attribute_parser = choice((
        just("external")
            .then_ignore(ignore_parser.clone())
            .ignored(),
        just("payable").then_ignore(ignore_parser.clone()).ignored(),
        modifier_invocation_parser.clone().ignored(),
        just("virtual").then_ignore(ignore_parser.clone()).ignored(),
        override_specifier_parser.clone().ignored(),
    ))
    .ignored();
    let return_statement_parser = just("return")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(expression_parser.clone().or_not().ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let revert_statement_parser = just("revert")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(expression_parser.clone().ignored())
        .then(argument_list_parser.clone().ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let try_statement_parser = just("try")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(expression_parser.clone().ignored())
        .then(
            just("returns")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(non_empty_parameter_list_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .then(block_parser.clone().ignored())
        .then(catch_clause_parser.clone().ignored())
        .then(catch_clause_parser.clone().repeated().ignored())
        .ignored();
    type_name_parser.define(
        choice((
            elementary_type_with_payable_parser.clone().ignored(),
            function_type_parser.clone().ignored(),
            mapping_type_parser.clone().ignored(),
            identifier_path_parser.clone().ignored(),
        ))
        .ignored()
        .then(
            just('[')
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(expression_parser.clone().or_not().ignored())
                .then_ignore(just(']').then_ignore(ignore_parser.clone()).ignored())
                .repeated()
                .ignored(),
        )
        .ignored(),
    );
    let while_statement_parser = just("while")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(expression_parser.clone().ignored())
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then(statement_parser.clone().ignored())
        .ignored();
    let yul_assignment_parser = yul_path_parser
        .clone()
        .ignored()
        .then(
            choice((
                just(":=")
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_expression_parser.clone().ignored())
                    .ignored(),
                just(',')
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_path_parser.clone().ignored())
                    .repeated()
                    .at_least(1usize)
                    .ignored()
                    .then_ignore(just(":=").then_ignore(ignore_parser.clone()).ignored())
                    .then(yul_function_call_parser.clone().ignored())
                    .ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let yul_variable_declaration_parser = just("let")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(yul_identifier_parser.clone().ignored())
        .then(
            choice((
                just(":=")
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_expression_parser.clone().ignored())
                    .ignored(),
                just(',')
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(yul_identifier_parser.clone().ignored())
                    .or_not()
                    .ignored()
                    .then(
                        just(":=")
                            .then_ignore(ignore_parser.clone())
                            .ignored()
                            .ignore_then(yul_function_call_parser.clone().ignored())
                            .or_not()
                            .ignored(),
                    )
                    .ignored(),
            ))
            .or_not()
            .ignored(),
        )
        .ignored();
    let constant_definition_parser = type_name_parser
        .clone()
        .ignored()
        .then_ignore(
            just("constant")
                .then_ignore(ignore_parser.clone())
                .ignored(),
        )
        .then(identifier_parser.clone().ignored())
        .then_ignore(just('=').then_ignore(ignore_parser.clone()).ignored())
        .then(expression_parser.clone().ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let error_parameter_parser = type_name_parser
        .clone()
        .ignored()
        .then(identifier_parser.clone().or_not().ignored())
        .ignored();
    let event_parameter_parser = type_name_parser
        .clone()
        .ignored()
        .then(
            just("indexed")
                .then_ignore(ignore_parser.clone())
                .or_not()
                .ignored(),
        )
        .then(identifier_parser.clone().or_not().ignored())
        .ignored();
    let state_variable_declaration_parser = type_name_parser
        .clone()
        .ignored()
        .then(state_variable_attribute_parser.clone().repeated().ignored())
        .then(identifier_parser.clone().ignored())
        .then(
            just('=')
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(expression_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let struct_definition_parser = just("struct")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
        .then(
            type_name_parser
                .clone()
                .ignored()
                .then(identifier_parser.clone().ignored())
                .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
                .repeated()
                .at_least(1usize)
                .ignored(),
        )
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let using_directive_parser = just("using")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            choice((
                identifier_path_parser.clone().ignored(),
                just('{')
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(
                        identifier_path_parser
                            .clone()
                            .separated_by(just(',').then_ignore(ignore_parser.clone()))
                            .at_least(1usize)
                            .ignored(),
                    )
                    .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
                    .ignored(),
            ))
            .ignored(),
        )
        .then_ignore(just("for").then_ignore(ignore_parser.clone()).ignored())
        .then(
            choice((
                just('*').then_ignore(ignore_parser.clone()).ignored(),
                type_name_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .then(
            just("global")
                .then_ignore(ignore_parser.clone())
                .or_not()
                .ignored(),
        )
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let variable_declaration_parser = type_name_parser
        .clone()
        .ignored()
        .then(data_location_parser.clone().or_not().ignored())
        .then(identifier_parser.clone().ignored())
        .ignored();
    let yul_statement_parser = choice((
        yul_block_parser.clone().ignored(),
        yul_variable_declaration_parser.clone().ignored(),
        yul_function_definition_parser.clone().ignored(),
        yul_assignment_parser.clone().ignored(),
        yul_function_call_parser.clone().ignored(),
        yul_if_statement_parser.clone().ignored(),
        yul_for_statement_parser.clone().ignored(),
        yul_switch_statement_parser.clone().ignored(),
        yul_leave_statement_parser.clone().ignored(),
        yul_break_statement_parser.clone().ignored(),
        yul_continue_statement_parser.clone().ignored(),
    ))
    .ignored();
    let directive_parser = choice((
        pragma_directive_parser
            .clone()
            .then_ignore(ignore_parser.clone())
            .ignored(),
        import_directive_parser.clone().ignored(),
        using_directive_parser.clone().ignored(),
    ))
    .ignored();
    let error_definition_parser = just("error")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just('(').then_ignore(ignore_parser.clone()).ignored())
        .then(
            error_parameter_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let event_definition_parser = just("event")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just('(').then_ignore(ignore_parser.clone()).ignored())
        .then(
            event_parameter_parser
                .clone()
                .separated_by(just(',').then_ignore(ignore_parser.clone()))
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then(
            just("anonymous")
                .then_ignore(ignore_parser.clone())
                .or_not()
                .ignored(),
        )
        .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let variable_declaration_tuple_parser = just('(')
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            just(',')
                .then_ignore(ignore_parser.clone())
                .repeated()
                .ignored(),
        )
        .then(variable_declaration_parser.clone().ignored())
        .then(
            just(',')
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(variable_declaration_parser.clone().or_not().ignored())
                .repeated()
                .ignored(),
        )
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    yul_block_parser.define(
        just('{')
            .then_ignore(ignore_parser.clone())
            .ignored()
            .ignore_then(yul_statement_parser.clone().repeated().ignored())
            .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
            .ignored(),
    );
    let assembly_statement_parser = just("assembly")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            just("\"evmasm\"")
                .then_ignore(ignore_parser.clone())
                .or_not()
                .ignored(),
        )
        .then(assembly_flags_parser.clone().or_not().ignored())
        .then(yul_block_parser.clone().ignored())
        .ignored();
    let variable_declaration_statement_parser = choice((
        variable_declaration_parser
            .clone()
            .ignored()
            .then(
                just('=')
                    .then_ignore(ignore_parser.clone())
                    .ignored()
                    .ignore_then(expression_parser.clone().ignored())
                    .or_not()
                    .ignored(),
            )
            .ignored(),
        variable_declaration_tuple_parser
            .clone()
            .ignored()
            .then_ignore(just('=').then_ignore(ignore_parser.clone()).ignored())
            .then(expression_parser.clone().ignored())
            .ignored(),
    ))
    .ignored()
    .then_ignore(just(';').then_ignore(ignore_parser.clone()).ignored())
    .ignored();
    let simple_statement_parser = choice((
        variable_declaration_statement_parser.clone().ignored(),
        expression_statement_parser.clone().ignored(),
    ))
    .ignored();
    let for_statement_parser = just("for")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(
            choice((
                simple_statement_parser.clone().ignored(),
                just(';').then_ignore(ignore_parser.clone()).ignored(),
            ))
            .ignored(),
        )
        .then(
            choice((
                expression_statement_parser.clone().ignored(),
                just(';').then_ignore(ignore_parser.clone()).ignored(),
            ))
            .ignored(),
        )
        .then(expression_parser.clone().or_not().ignored())
        .then_ignore(just(')').then_ignore(ignore_parser.clone()).ignored())
        .then(statement_parser.clone().ignored())
        .ignored();
    statement_parser.define(
        choice((
            block_parser.clone().ignored(),
            simple_statement_parser.clone().ignored(),
            if_statement_parser.clone().ignored(),
            for_statement_parser.clone().ignored(),
            while_statement_parser.clone().ignored(),
            do_while_statement_parser.clone().ignored(),
            continue_statement_parser.clone().ignored(),
            break_statement_parser.clone().ignored(),
            try_statement_parser.clone().ignored(),
            return_statement_parser.clone().ignored(),
            emit_statement_parser.clone().ignored(),
            revert_statement_parser.clone().ignored(),
            assembly_statement_parser.clone().ignored(),
        ))
        .ignored(),
    );
    block_parser.define(
        just('{')
            .then_ignore(ignore_parser.clone())
            .ignored()
            .ignore_then(
                choice((
                    statement_parser.clone().ignored(),
                    unchecked_block_parser.clone().ignored(),
                ))
                .repeated()
                .ignored(),
            )
            .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
            .ignored(),
    );
    let constructor_definition_parser = just("constructor")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(parameter_list_parser.clone().ignored())
        .then(constructor_attribute_parser.clone().repeated().ignored())
        .then(block_parser.clone().ignored())
        .ignored();
    let fallback_function_definition_parser = just("fallback")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(parameter_list_parser.clone().ignored())
        .then(
            fallback_function_attribute_parser
                .clone()
                .repeated()
                .ignored(),
        )
        .then(
            just("returns")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(non_empty_parameter_list_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .then(
            choice((
                just(';').then_ignore(ignore_parser.clone()).ignored(),
                block_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let function_definition_parser = just("function")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(
            choice((
                identifier_parser.clone().ignored(),
                just("fallback")
                    .then_ignore(ignore_parser.clone())
                    .ignored(),
                just("receive").then_ignore(ignore_parser.clone()).ignored(),
            ))
            .ignored(),
        )
        .then(parameter_list_parser.clone().ignored())
        .then(function_attribute_parser.clone().repeated().ignored())
        .then(
            just("returns")
                .then_ignore(ignore_parser.clone())
                .ignored()
                .ignore_then(non_empty_parameter_list_parser.clone().ignored())
                .or_not()
                .ignored(),
        )
        .then(
            choice((
                just(';').then_ignore(ignore_parser.clone()).ignored(),
                block_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let modifier_definition_parser = just("modifier")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then(parameter_list_parser.clone().or_not().ignored())
        .then(method_attribute_parser.clone().repeated().ignored())
        .then(
            choice((
                just(';').then_ignore(ignore_parser.clone()).ignored(),
                block_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let receive_function_definition_parser = just("receive")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(just('(').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(just(')').then_ignore(ignore_parser.clone()).ignored())
        .ignore_then(
            receive_function_attribute_parser
                .clone()
                .repeated()
                .ignored(),
        )
        .then(
            choice((
                just(';').then_ignore(ignore_parser.clone()).ignored(),
                block_parser.clone().ignored(),
            ))
            .ignored(),
        )
        .ignored();
    let contract_body_element_parser = choice((
        using_directive_parser.clone().ignored(),
        constructor_definition_parser.clone().ignored(),
        function_definition_parser.clone().ignored(),
        fallback_function_definition_parser.clone().ignored(),
        receive_function_definition_parser.clone().ignored(),
        modifier_definition_parser.clone().ignored(),
        struct_definition_parser.clone().ignored(),
        enum_definition_parser.clone().ignored(),
        user_defined_value_type_definition_parser.clone().ignored(),
        event_definition_parser.clone().ignored(),
        error_definition_parser.clone().ignored(),
        state_variable_declaration_parser.clone().ignored(),
    ))
    .ignored();
    let contract_definition_parser = just("abstract")
        .then_ignore(ignore_parser.clone())
        .or_not()
        .ignored()
        .then_ignore(
            just("contract")
                .then_ignore(ignore_parser.clone())
                .ignored(),
        )
        .then(identifier_parser.clone().ignored())
        .then(inheritance_specifier_list_parser.clone().or_not().ignored())
        .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
        .then(contract_body_element_parser.clone().repeated().ignored())
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let interface_definition_parser = just("interface")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then(inheritance_specifier_list_parser.clone().or_not().ignored())
        .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
        .then(contract_body_element_parser.clone().repeated().ignored())
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let library_definition_parser = just("library")
        .then_ignore(ignore_parser.clone())
        .ignored()
        .ignore_then(identifier_parser.clone().ignored())
        .then_ignore(just('{').then_ignore(ignore_parser.clone()).ignored())
        .then(contract_body_element_parser.clone().repeated().ignored())
        .then_ignore(just('}').then_ignore(ignore_parser.clone()).ignored())
        .ignored();
    let definition_parser = choice((
        contract_definition_parser.clone().ignored(),
        interface_definition_parser.clone().ignored(),
        library_definition_parser.clone().ignored(),
        function_definition_parser.clone().ignored(),
        constant_definition_parser.clone().ignored(),
        struct_definition_parser.clone().ignored(),
        enum_definition_parser.clone().ignored(),
        user_defined_value_type_definition_parser.clone().ignored(),
        error_definition_parser.clone().ignored(),
    ))
    .ignored();
    let source_unit_parser = ignore_parser
        .clone()
        .then_ignore(ignore_parser.clone())
        .ignored()
        .then(
            choice((
                directive_parser.clone().ignored(),
                definition_parser.clone().ignored(),
            ))
            .repeated()
            .ignored(),
        )
        .then_ignore(end().ignored())
        .ignored();
    source_unit_parser.recover_with(skip_then_retry_until([]))
}
