// This file is generated via `cargo build`. Please don't edit by hand.

use chumsky::prelude::{BoxedParser, Simple};
pub type ErrorType = Simple<char>;
pub type ParserType<T> = BoxedParser<'static, char, T, ErrorType>;
use super::cst::*;

#[allow(dead_code)]
pub struct Parsers {
    pub boolean_literal: ParserType<NodeRef>,
    pub decimal_integer: ParserType<NodeRef>,
    pub end_of_line: ParserType<NodeRef>,
    pub fixed_bytes_type: ParserType<NodeRef>,
    pub hex_byte_escape: ParserType<NodeRef>,
    pub hex_number: ParserType<NodeRef>,
    pub multiline_comment: ParserType<NodeRef>,
    pub number_unit: ParserType<NodeRef>,
    pub possibly_separated_pairs_of_hex_digits: ParserType<NodeRef>,
    pub raw_identifier: ParserType<NodeRef>,
    pub reserved_keyword: ParserType<NodeRef>,
    pub signed_fixed_type: ParserType<NodeRef>,
    pub signed_integer_type: ParserType<NodeRef>,
    pub single_line_comment: ParserType<NodeRef>,
    pub unicode_escape: ParserType<NodeRef>,
    pub version_pragma_operator: ParserType<NodeRef>,
    pub version_pragma_value: ParserType<NodeRef>,
    pub whitespace: ParserType<NodeRef>,
    pub yul_decimal_number_literal: ParserType<NodeRef>,
    pub yul_hex_literal: ParserType<NodeRef>,
    pub decimal_exponent: ParserType<NodeRef>,
    pub decimal_float: ParserType<NodeRef>,
    pub end_of_file_trivia: ParserType<NodeRef>,
    pub escape_sequence: ParserType<NodeRef>,
    pub hex_string_literal: ParserType<NodeRef>,
    pub leading_trivia: ParserType<NodeRef>,
    pub trailing_trivia: ParserType<NodeRef>,
    pub unsigned_fixed_type: ParserType<NodeRef>,
    pub unsigned_integer_type: ParserType<NodeRef>,
    pub yul_keyword: ParserType<NodeRef>,
    pub address_type: ParserType<NodeRef>,
    pub array_literal: ParserType<NodeRef>,
    pub break_statement: ParserType<NodeRef>,
    pub continue_statement: ParserType<NodeRef>,
    pub data_location: ParserType<NodeRef>,
    pub decimal_number: ParserType<NodeRef>,
    pub double_quoted_ascii_string_literal: ParserType<NodeRef>,
    pub double_quoted_unicode_string_literal: ParserType<NodeRef>,
    pub keyword: ParserType<NodeRef>,
    pub parenthesis_expression: ParserType<NodeRef>,
    pub positional_argument_list: ParserType<NodeRef>,
    pub single_quoted_ascii_string_literal: ParserType<NodeRef>,
    pub single_quoted_unicode_string_literal: ParserType<NodeRef>,
    pub unchecked_block: ParserType<NodeRef>,
    pub version_pragma_specifier: ParserType<NodeRef>,
    pub yul_break_statement: ParserType<NodeRef>,
    pub yul_continue_statement: ParserType<NodeRef>,
    pub yul_identifier: ParserType<NodeRef>,
    pub yul_leave_statement: ParserType<NodeRef>,
    pub ascii_string_literal: ParserType<NodeRef>,
    pub assembly_flags: ParserType<NodeRef>,
    pub elementary_type: ParserType<NodeRef>,
    pub identifier: ParserType<NodeRef>,
    pub numeric_literal: ParserType<NodeRef>,
    pub unicode_string_literal: ParserType<NodeRef>,
    pub yul_function_call: ParserType<NodeRef>,
    pub yul_function_definition: ParserType<NodeRef>,
    pub yul_identifier_path: ParserType<NodeRef>,
    pub abi_coder_pragma_specifier: ParserType<NodeRef>,
    pub delete_statement: ParserType<NodeRef>,
    pub enum_definition: ParserType<NodeRef>,
    pub experimental_pragma_specifier: ParserType<NodeRef>,
    pub identifier_path: ParserType<NodeRef>,
    pub import_path: ParserType<NodeRef>,
    pub named_argument: ParserType<NodeRef>,
    pub parameter_declaration: ParserType<NodeRef>,
    pub selected_import: ParserType<NodeRef>,
    pub user_defined_value_type_definition: ParserType<NodeRef>,
    pub yul_literal: ParserType<NodeRef>,
    pub mapping_type: ParserType<NodeRef>,
    pub named_argument_list: ParserType<NodeRef>,
    pub override_specifier: ParserType<NodeRef>,
    pub parameter_list: ParserType<NodeRef>,
    pub pragma_directive: ParserType<NodeRef>,
    pub selecting_import_directive: ParserType<NodeRef>,
    pub simple_import_directive: ParserType<NodeRef>,
    pub star_import_directive: ParserType<NodeRef>,
    pub yul_expression: ParserType<NodeRef>,
    pub argument_list: ParserType<NodeRef>,
    pub catch_clause: ParserType<NodeRef>,
    pub function_type: ParserType<NodeRef>,
    pub import_directive: ParserType<NodeRef>,
    pub modifier_attribute: ParserType<NodeRef>,
    pub state_variable_attribute: ParserType<NodeRef>,
    pub yul_assignment_statement: ParserType<NodeRef>,
    pub yul_for_statement: ParserType<NodeRef>,
    pub yul_if_statement: ParserType<NodeRef>,
    pub yul_switch_statement: ParserType<NodeRef>,
    pub yul_variable_declaration: ParserType<NodeRef>,
    pub emit_statement: ParserType<NodeRef>,
    pub inheritance_specifier: ParserType<NodeRef>,
    pub modifier_invocation: ParserType<NodeRef>,
    pub new_expression: ParserType<NodeRef>,
    pub payable_expression: ParserType<NodeRef>,
    pub revert_statement: ParserType<NodeRef>,
    pub type_name: ParserType<NodeRef>,
    pub yul_statement: ParserType<NodeRef>,
    pub constructor_attribute: ParserType<NodeRef>,
    pub error_parameter: ParserType<NodeRef>,
    pub event_parameter: ParserType<NodeRef>,
    pub fallback_function_attribute: ParserType<NodeRef>,
    pub function_attribute: ParserType<NodeRef>,
    pub inheritance_specifier_list: ParserType<NodeRef>,
    pub receive_function_attribute: ParserType<NodeRef>,
    pub struct_member: ParserType<NodeRef>,
    pub type_expression: ParserType<NodeRef>,
    pub using_directive: ParserType<NodeRef>,
    pub yul_block: ParserType<NodeRef>,
    pub assembly_statement: ParserType<NodeRef>,
    pub directive: ParserType<NodeRef>,
    pub error_definition: ParserType<NodeRef>,
    pub event_definition: ParserType<NodeRef>,
    pub primary_expression: ParserType<NodeRef>,
    pub struct_definition: ParserType<NodeRef>,
    pub index_access_expression: ParserType<NodeRef>,
    pub member_access_expression: ParserType<NodeRef>,
    pub function_call_expression: ParserType<NodeRef>,
    pub unary_prefix_expression: ParserType<NodeRef>,
    pub unary_suffix_expression: ParserType<NodeRef>,
    pub exponentiation_expression: ParserType<NodeRef>,
    pub mul_div_mod_expression: ParserType<NodeRef>,
    pub add_sub_expression: ParserType<NodeRef>,
    pub shift_expression: ParserType<NodeRef>,
    pub bit_and_expression: ParserType<NodeRef>,
    pub bit_x_or_expression: ParserType<NodeRef>,
    pub bit_or_expression: ParserType<NodeRef>,
    pub order_comparison_expression: ParserType<NodeRef>,
    pub equality_comparison_expression: ParserType<NodeRef>,
    pub and_expression: ParserType<NodeRef>,
    pub or_expression: ParserType<NodeRef>,
    pub conditional_expression: ParserType<NodeRef>,
    pub assignment_expression: ParserType<NodeRef>,
    pub expression: ParserType<NodeRef>,
    pub constant_definition: ParserType<NodeRef>,
    pub do_while_statement: ParserType<NodeRef>,
    pub expression_statement: ParserType<NodeRef>,
    pub if_statement: ParserType<NodeRef>,
    pub return_statement: ParserType<NodeRef>,
    pub state_variable_declaration: ParserType<NodeRef>,
    pub try_statement: ParserType<NodeRef>,
    pub tuple_deconstruction_statement: ParserType<NodeRef>,
    pub variable_declaration_statement: ParserType<NodeRef>,
    pub while_statement: ParserType<NodeRef>,
    pub simple_statement: ParserType<NodeRef>,
    pub for_statement: ParserType<NodeRef>,
    pub statement: ParserType<NodeRef>,
    pub block: ParserType<NodeRef>,
    pub constructor_definition: ParserType<NodeRef>,
    pub fallback_function_definition: ParserType<NodeRef>,
    pub function_definition: ParserType<NodeRef>,
    pub modifier_definition: ParserType<NodeRef>,
    pub receive_function_definition: ParserType<NodeRef>,
    pub contract_body_element: ParserType<NodeRef>,
    pub contract_definition: ParserType<NodeRef>,
    pub interface_definition: ParserType<NodeRef>,
    pub library_definition: ParserType<NodeRef>,
    pub definition: ParserType<NodeRef>,
    pub source_unit: ParserType<NodeRef>,
}
