/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum NodeType {
  Rule = 0,
  Token = 1,
  Group = 2
}
export const enum Token {
  Abicoder = 0,
  Abstract = 1,
  Address = 2,
  After = 3,
  Alias = 4,
  Ampersand = 5,
  AmpersandAmpersand = 6,
  AmpersandEqual = 7,
  Anonymous = 8,
  Apply = 9,
  As = 10,
  AsciiEscape = 11,
  AsciiStringLiteral = 12,
  Assembly = 13,
  Auto = 14,
  Backslash = 15,
  Bang = 16,
  BangEqual = 17,
  Bool = 18,
  BooleanLiteral = 19,
  Break = 20,
  Byte = 21,
  Bytes = 22,
  Calldata = 23,
  Caret = 24,
  CaretEqual = 25,
  CarriageReturn = 26,
  Case = 27,
  Catch = 28,
  Char = 29,
  Chars = 30,
  CloseBrace = 31,
  CloseBracket = 32,
  CloseParen = 33,
  Colon = 34,
  ColonEqual = 35,
  Comma = 36,
  Constant = 37,
  Constructor = 38,
  Content = 39,
  Continue = 40,
  Contract = 41,
  Copyof = 42,
  Days = 43,
  DecimalExponent = 44,
  DecimalFloat = 45,
  DecimalInteger = 46,
  DecimalNumber = 47,
  Default = 48,
  Define = 49,
  Delete = 50,
  DelimitedPossiblySeparatedPairsOfHexDigits = 51,
  Do = 52,
  DoubleQuote = 53,
  DoubleQuoteEvmasmDoubleQuote = 54,
  DoubleQuotedAsciiStringLiteral = 55,
  DoubleQuotedUnicodeStringLiteral = 56,
  Eight = 57,
  EightEight = 58,
  EightZero = 59,
  Else = 60,
  Emit = 61,
  EndOfLine = 62,
  Enum = 63,
  Equal = 64,
  EqualEqual = 65,
  EqualGreater = 66,
  Error = 67,
  EscapeSequence = 68,
  Ether = 69,
  Event = 70,
  Experimental = 71,
  External = 72,
  Fallback = 73,
  False = 74,
  Final = 75,
  Finney = 76,
  Five = 77,
  FiveSix = 78,
  Fixed = 79,
  FixedBytesType = 80,
  For = 81,
  Four = 82,
  FourEight = 83,
  FourZero = 84,
  From = 85,
  Function = 86,
  Global = 87,
  Greater = 88,
  GreaterEqual = 89,
  GreaterGreater = 90,
  GreaterGreaterEqual = 91,
  GreaterGreaterGreater = 92,
  GreaterGreaterGreaterEqual = 93,
  Gwei = 94,
  Hex = 95,
  HexByteEscape = 96,
  HexCharacter = 97,
  HexNumber = 98,
  HexStringLiteral = 99,
  Hours = 100,
  Identifier = 101,
  IdentifierPart = 102,
  IdentifierStart = 103,
  If = 104,
  Immutable = 105,
  Implements = 106,
  Import = 107,
  In = 108,
  Indexed = 109,
  Inline = 110,
  Int = 111,
  Interface = 112,
  Internal = 113,
  Is = 114,
  Keyword = 115,
  LatinSmallLetterN = 116,
  LatinSmallLetterR = 117,
  LatinSmallLetterT = 118,
  LatinSmallLetterU = 119,
  LatinSmallLetterX = 120,
  Leave = 121,
  Less = 122,
  LessEqual = 123,
  LessLess = 124,
  LessLessEqual = 125,
  Let = 126,
  Library = 127,
  Linefeed = 128,
  Macro = 129,
  Mapping = 130,
  Match = 131,
  Memory = 132,
  Minus = 133,
  MinusEqual = 134,
  MinusGreater = 135,
  MinusMinus = 136,
  Minutes = 137,
  Modifier = 138,
  MultilineComment = 139,
  Mutable = 140,
  New = 141,
  Nine = 142,
  NineSix = 143,
  NotSlash = 144,
  NotStar = 145,
  Null = 146,
  NumberUnit = 147,
  NumericLiteral = 148,
  Of = 149,
  One = 150,
  OneEight = 151,
  OneEightFour = 152,
  OneFive = 153,
  OneFiveTwo = 154,
  OneFour = 155,
  OneFourFour = 156,
  OneNine = 157,
  OneNineTwo = 158,
  OneOne = 159,
  OneOneTwo = 160,
  OneSeven = 161,
  OneSevenSix = 162,
  OneSix = 163,
  OneSixEight = 164,
  OneSixZero = 165,
  OneThree = 166,
  OneThreeSix = 167,
  OneTwo = 168,
  OneTwoEight = 169,
  OneTwoZero = 170,
  OneZero = 171,
  OneZeroFour = 172,
  OpenBrace = 173,
  OpenBracket = 174,
  OpenParen = 175,
  Override = 176,
  Partial = 177,
  Payable = 178,
  Percent = 179,
  PercentEqual = 180,
  Period = 181,
  Pipe = 182,
  PipeEqual = 183,
  PipePipe = 184,
  Plus = 185,
  PlusEqual = 186,
  PlusPlus = 187,
  PossiblySeparatedPairsOfHexDigits = 188,
  Pragma = 189,
  Private = 190,
  Promise = 191,
  Public = 192,
  Pure = 193,
  Question = 194,
  Quote = 195,
  RawIdentifier = 196,
  Receive = 197,
  Reference = 198,
  Relocatable = 199,
  ReservedKeyword = 200,
  Return = 201,
  Returns = 202,
  Revert = 203,
  Run = 204,
  Runs = 205,
  Sealed = 206,
  Seconds = 207,
  Semicolon = 208,
  Seven = 209,
  SevenTwo = 210,
  SignedFixedType = 211,
  SignedIntegerType = 212,
  SingleLineComment = 213,
  SingleQuotedAsciiStringLiteral = 214,
  SingleQuotedUnicodeStringLiteral = 215,
  Six = 216,
  SixFour = 217,
  Sizeof = 218,
  Slash = 219,
  SlashEqual = 220,
  SlashSlash = 221,
  SlashStar = 222,
  Solidity = 223,
  Star = 224,
  StarEqual = 225,
  StarSlash = 226,
  StarStar = 227,
  Static = 228,
  Storage = 229,
  String = 230,
  Struct = 231,
  Supports = 232,
  Switch = 233,
  Szabo = 234,
  Three = 235,
  ThreeOne = 236,
  ThreeTwo = 237,
  ThreeZero = 238,
  Tilde = 239,
  True = 240,
  Try = 241,
  Two = 242,
  TwoEight = 243,
  TwoFive = 244,
  TwoFiveSix = 245,
  TwoFour = 246,
  TwoFourEight = 247,
  TwoFourZero = 248,
  TwoNine = 249,
  TwoOne = 250,
  TwoOneSix = 251,
  TwoSeven = 252,
  TwoSix = 253,
  TwoThree = 254,
  TwoThreeTwo = 255,
  TwoTwo = 256,
  TwoTwoFour = 257,
  TwoZero = 258,
  TwoZeroEight = 259,
  TwoZeroZero = 260,
  Type = 261,
  Typedef = 262,
  Typeof = 263,
  Unchecked = 264,
  Underscore = 265,
  UnicodeDoubleQuote = 266,
  UnicodeEscape = 267,
  UnicodeQuote = 268,
  UnicodeStringLiteral = 269,
  UnsignedFixedType = 270,
  UnsignedIntegerType = 271,
  Using = 272,
  Var = 273,
  VersionPragmaOperator = 274,
  VersionPragmaValue = 275,
  View = 276,
  Virtual = 277,
  Weeks = 278,
  Wei = 279,
  While = 280,
  Whitespace = 281,
  Years = 282,
  YulDecimalNumberLiteral = 283,
  YulHexLiteral = 284,
  YulIdentifier = 285,
  YulKeyword = 286,
  Zero = 287,
  ZeroX = 288
}
export const enum Rule {
  AbicoderPragma = 0,
  AddSubExpression = 1,
  AddressType = 2,
  AndExpression = 3,
  ArgumentList = 4,
  Arguments = 5,
  ArrayLiteral = 6,
  AssemblyFlags = 7,
  AssemblyStatement = 8,
  AssignmentExpression = 9,
  BitAndExpression = 10,
  BitOrExpression = 11,
  BitXOrExpression = 12,
  Block = 13,
  BreakStatement = 14,
  CatchClause = 15,
  CatchClauses = 16,
  ConditionalExpression = 17,
  ConstantDefinition = 18,
  ConstructorAttribute = 19,
  ConstructorAttributes = 20,
  ConstructorDefinition = 21,
  ContinueStatement = 22,
  ContractBodyElement = 23,
  ContractBodyElements = 24,
  ContractDefinition = 25,
  DataLocation = 26,
  Definition = 27,
  DeleteStatement = 28,
  DelimitedArguments = 29,
  DelimitedContractBodyElements = 30,
  DelimitedExpression = 31,
  DelimitedExpressions = 32,
  DelimitedSeparatedErrorParameters = 33,
  DelimitedSeparatedEventParameters = 34,
  DelimitedSeparatedIdentifierPaths = 35,
  DelimitedSeparatedIdentifiers = 36,
  DelimitedSeparatedNamedArguments = 37,
  DelimitedSeparatedSelectedImports = 38,
  DelimitedSeparatedYulExpressions = 39,
  DelimitedStructMembers = 40,
  DelimitedTypeName = 41,
  Directive = 42,
  DoWhileStatement = 43,
  ElementaryType = 44,
  EmitStatement = 45,
  EndOfFileTrivia = 46,
  EnumDefinition = 47,
  EqualityComparisonExpression = 48,
  ErrorDefinition = 49,
  ErrorParameter = 50,
  EventDefinition = 51,
  EventParameter = 52,
  ExperimentalPragma = 53,
  ExponentiationExpression = 54,
  Expression = 55,
  ExpressionStatement = 56,
  FallbackFunctionAttribute = 57,
  FallbackFunctionAttributes = 58,
  FallbackFunctionDefinition = 59,
  ForStatement = 60,
  FunctionAttribute = 61,
  FunctionAttributes = 62,
  FunctionCallExpression = 63,
  FunctionDefinition = 64,
  FunctionType = 65,
  IdentifierPath = 66,
  IfStatement = 67,
  ImportDirective = 68,
  ImportPath = 69,
  IndexAccessExpression = 70,
  InheritanceSpecifier = 71,
  InheritanceSpecifierList = 72,
  InterfaceDefinition = 73,
  LeadingTrivia = 74,
  LibraryDefinition = 75,
  MappingType = 76,
  MemberAccessExpression = 77,
  ModifierAttribute = 78,
  ModifierAttributes = 79,
  ModifierDefinition = 80,
  ModifierInvocation = 81,
  MulDivModExpression = 82,
  NamedArgument = 83,
  NamedArgumentList = 84,
  NewExpression = 85,
  OrExpression = 86,
  OrderComparisonExpression = 87,
  OverrideSpecifier = 88,
  ParameterDeclaration = 89,
  ParameterList = 90,
  ParenthesisExpression = 91,
  PayableExpression = 92,
  PositionalArgumentList = 93,
  PragmaDirective = 94,
  PrimaryExpression = 95,
  ReceiveFunctionAttribute = 96,
  ReceiveFunctionAttributes = 97,
  ReceiveFunctionDefinition = 98,
  Results = 99,
  ReturnStatement = 100,
  RevertStatement = 101,
  SelectedImport = 102,
  SelectingImportDirective = 103,
  SeparatedDoubleQuotedAsciiStringLiterals = 104,
  SeparatedErrorParameters = 105,
  SeparatedEventParameters = 106,
  SeparatedExpressions = 107,
  SeparatedIdentifierPaths = 108,
  SeparatedIdentifiers = 109,
  SeparatedInheritanceSpecifiers = 110,
  SeparatedNamedArguments = 111,
  SeparatedParameterDeclarations = 112,
  SeparatedSelectedImports = 113,
  SeparatedVersionPragmaValues = 114,
  SeparatedYulExpressions = 115,
  SeparatedYulIdentifierPaths = 116,
  ShiftExpression = 117,
  SimpleImportDirective = 118,
  SimpleStatement = 119,
  SourceUnit = 120,
  StarImportDirective = 121,
  StateVariableAttribute = 122,
  StateVariableAttributes = 123,
  StateVariableDeclaration = 124,
  Statement = 125,
  StructDefinition = 126,
  StructMember = 127,
  StructMembers = 128,
  TrailingTrivia = 129,
  TryStatement = 130,
  TupleDeconstructionStatement = 131,
  TypeExpression = 132,
  TypeName = 133,
  UnaryPrefixExpression = 134,
  UnarySuffixExpression = 135,
  UncheckedBlock = 136,
  UserDefinedValueTypeDefinition = 137,
  UsingDirective = 138,
  VariableDeclarationStatement = 139,
  VersionPragma = 140,
  VersionPragmaSpecifier = 141,
  VersionPragmaSpecifiers = 142,
  WhileStatement = 143,
  YulAssignmentStatement = 144,
  YulBlock = 145,
  YulBreakStatement = 146,
  YulContinueStatement = 147,
  YulExpression = 148,
  YulForStatement = 149,
  YulFunctionCall = 150,
  YulFunctionDefinition = 151,
  YulIdentifierPath = 152,
  YulIfStatement = 153,
  YulLeaveStatement = 154,
  YulLiteral = 155,
  YulStatement = 156,
  YulStatements = 157,
  YulSwitchStatement = 158,
  YulVariableDeclaration = 159
}
export const enum LexNodeType {
  Chars = 0,
  Choice = 1,
  Sequence = 2,
  Named = 3
}
export interface TokenRange {
  start: number
  end: number
}
export class RuleNode {
  get type(): NodeType.Rule
  get kind(): Rule
  children(): (RuleNode | TokenNode | GroupNode)[]
}
export class TokenNode {
  get type(): NodeType.Token
  get kind(): Token
  lexNode(): LexCharsNode | LexChoiceNode | LexSequenceNode | LexNamedNode
  trivia(): (RuleNode | TokenNode | GroupNode)[]
}
export class GroupNode {
  get type(): NodeType.Group
  children(): (RuleNode | TokenNode | GroupNode)[]
}
export class Language {
  constructor(version: string)
  version(): string
  parseAbiCoderPragma(source: string): ParserOutput
  parseAddSubExpression(source: string): ParserOutput
  parseAddressType(source: string): ParserOutput
  parseAndExpression(source: string): ParserOutput
  parseArgumentList(source: string): ParserOutput
  parseArrayLiteral(source: string): ParserOutput
  parseAsciiEscape(source: string): ParserOutput
  parseAsciiStringLiteral(source: string): ParserOutput
  parseAssemblyFlags(source: string): ParserOutput
  parseAssemblyStatement(source: string): ParserOutput
  parseAssignmentExpression(source: string): ParserOutput
  parseBitAndExpression(source: string): ParserOutput
  parseBitOrExpression(source: string): ParserOutput
  parseBitXOrExpression(source: string): ParserOutput
  parseBlock(source: string): ParserOutput
  parseBooleanLiteral(source: string): ParserOutput
  parseBreakStatement(source: string): ParserOutput
  parseCatchClause(source: string): ParserOutput
  parseConditionalExpression(source: string): ParserOutput
  parseConstantDefinition(source: string): ParserOutput
  parseConstructorAttribute(source: string): ParserOutput
  parseConstructorDefinition(source: string): ParserOutput
  parseContinueStatement(source: string): ParserOutput
  parseContractBodyElement(source: string): ParserOutput
  parseContractDefinition(source: string): ParserOutput
  parseDataLocation(source: string): ParserOutput
  parseDecimalExponent(source: string): ParserOutput
  parseDecimalFloat(source: string): ParserOutput
  parseDecimalInteger(source: string): ParserOutput
  parseDecimalNumber(source: string): ParserOutput
  parseDefinition(source: string): ParserOutput
  parseDeleteStatement(source: string): ParserOutput
  parseDirective(source: string): ParserOutput
  parseDoWhileStatement(source: string): ParserOutput
  parseDoubleQuotedAsciiStringLiteral(source: string): ParserOutput
  parseDoubleQuotedUnicodeStringLiteral(source: string): ParserOutput
  parseElementaryType(source: string): ParserOutput
  parseEmitStatement(source: string): ParserOutput
  parseEndOfFileTrivia(source: string): ParserOutput
  parseEndOfLine(source: string): ParserOutput
  parseEnumDefinition(source: string): ParserOutput
  parseEqualityComparisonExpression(source: string): ParserOutput
  parseErrorDefinition(source: string): ParserOutput
  parseErrorParameter(source: string): ParserOutput
  parseEscapeSequence(source: string): ParserOutput
  parseEventDefinition(source: string): ParserOutput
  parseEventParameter(source: string): ParserOutput
  parseExperimentalPragma(source: string): ParserOutput
  parseExponentiationExpression(source: string): ParserOutput
  parseExpression(source: string): ParserOutput
  parseExpressionStatement(source: string): ParserOutput
  parseFallbackFunctionAttribute(source: string): ParserOutput
  parseFallbackFunctionDefinition(source: string): ParserOutput
  parseFixedBytesType(source: string): ParserOutput
  parseForStatement(source: string): ParserOutput
  parseFunctionAttribute(source: string): ParserOutput
  parseFunctionCallExpression(source: string): ParserOutput
  parseFunctionDefinition(source: string): ParserOutput
  parseFunctionType(source: string): ParserOutput
  parseHexByteEscape(source: string): ParserOutput
  parseHexCharacter(source: string): ParserOutput
  parseHexNumber(source: string): ParserOutput
  parseHexStringLiteral(source: string): ParserOutput
  parseIdentifier(source: string): ParserOutput
  parseIdentifierPart(source: string): ParserOutput
  parseIdentifierPath(source: string): ParserOutput
  parseIdentifierStart(source: string): ParserOutput
  parseIfStatement(source: string): ParserOutput
  parseImportDirective(source: string): ParserOutput
  parseImportPath(source: string): ParserOutput
  parseIndexAccessExpression(source: string): ParserOutput
  parseInheritanceSpecifier(source: string): ParserOutput
  parseInheritanceSpecifierList(source: string): ParserOutput
  parseInterfaceDefinition(source: string): ParserOutput
  parseKeyword(source: string): ParserOutput
  parseLeadingTrivia(source: string): ParserOutput
  parseLibraryDefinition(source: string): ParserOutput
  parseMappingType(source: string): ParserOutput
  parseMemberAccessExpression(source: string): ParserOutput
  parseModifierAttribute(source: string): ParserOutput
  parseModifierDefinition(source: string): ParserOutput
  parseModifierInvocation(source: string): ParserOutput
  parseMulDivModExpression(source: string): ParserOutput
  parseMultilineComment(source: string): ParserOutput
  parseNamedArgument(source: string): ParserOutput
  parseNamedArgumentList(source: string): ParserOutput
  parseNewExpression(source: string): ParserOutput
  parseNumberUnit(source: string): ParserOutput
  parseNumericLiteral(source: string): ParserOutput
  parseOrExpression(source: string): ParserOutput
  parseOrderComparisonExpression(source: string): ParserOutput
  parseOverrideSpecifier(source: string): ParserOutput
  parseParameterDeclaration(source: string): ParserOutput
  parseParameterList(source: string): ParserOutput
  parseParenthesisExpression(source: string): ParserOutput
  parsePayableExpression(source: string): ParserOutput
  parsePositionalArgumentList(source: string): ParserOutput
  parsePossiblySeparatedPairsOfHexDigits(source: string): ParserOutput
  parsePragmaDirective(source: string): ParserOutput
  parsePrimaryExpression(source: string): ParserOutput
  parseRawIdentifier(source: string): ParserOutput
  parseReceiveFunctionAttribute(source: string): ParserOutput
  parseReceiveFunctionDefinition(source: string): ParserOutput
  parseReservedKeyword(source: string): ParserOutput
  parseReturnStatement(source: string): ParserOutput
  parseRevertStatement(source: string): ParserOutput
  parseSelectedImport(source: string): ParserOutput
  parseSelectingImportDirective(source: string): ParserOutput
  parseShiftExpression(source: string): ParserOutput
  parseSignedFixedType(source: string): ParserOutput
  parseSignedIntegerType(source: string): ParserOutput
  parseSimpleImportDirective(source: string): ParserOutput
  parseSimpleStatement(source: string): ParserOutput
  parseSingleLineComment(source: string): ParserOutput
  parseSingleQuotedAsciiStringLiteral(source: string): ParserOutput
  parseSingleQuotedUnicodeStringLiteral(source: string): ParserOutput
  parseSourceUnit(source: string): ParserOutput
  parseStarImportDirective(source: string): ParserOutput
  parseStateVariableAttribute(source: string): ParserOutput
  parseStateVariableDeclaration(source: string): ParserOutput
  parseStatement(source: string): ParserOutput
  parseStructDefinition(source: string): ParserOutput
  parseStructMember(source: string): ParserOutput
  parseTrailingTrivia(source: string): ParserOutput
  parseTryStatement(source: string): ParserOutput
  parseTupleDeconstructionStatement(source: string): ParserOutput
  parseTypeExpression(source: string): ParserOutput
  parseTypeName(source: string): ParserOutput
  parseUnaryPrefixExpression(source: string): ParserOutput
  parseUnarySuffixExpression(source: string): ParserOutput
  parseUncheckedBlock(source: string): ParserOutput
  parseUnicodeEscape(source: string): ParserOutput
  parseUnicodeStringLiteral(source: string): ParserOutput
  parseUnsignedFixedType(source: string): ParserOutput
  parseUnsignedIntegerType(source: string): ParserOutput
  parseUserDefinedValueTypeDefinition(source: string): ParserOutput
  parseUsingDirective(source: string): ParserOutput
  parseVariableDeclarationStatement(source: string): ParserOutput
  parseVersionPragma(source: string): ParserOutput
  parseVersionPragmaOperator(source: string): ParserOutput
  parseVersionPragmaSpecifier(source: string): ParserOutput
  parseVersionPragmaValue(source: string): ParserOutput
  parseWhileStatement(source: string): ParserOutput
  parseWhitespace(source: string): ParserOutput
  parseYulAssignmentStatement(source: string): ParserOutput
  parseYulBlock(source: string): ParserOutput
  parseYulBreakStatement(source: string): ParserOutput
  parseYulContinueStatement(source: string): ParserOutput
  parseYulDecimalNumberLiteral(source: string): ParserOutput
  parseYulExpression(source: string): ParserOutput
  parseYulForStatement(source: string): ParserOutput
  parseYulFunctionCall(source: string): ParserOutput
  parseYulFunctionDefinition(source: string): ParserOutput
  parseYulHexLiteral(source: string): ParserOutput
  parseYulIdentifier(source: string): ParserOutput
  parseYulIdentifierPath(source: string): ParserOutput
  parseYulIfStatement(source: string): ParserOutput
  parseYulKeyword(source: string): ParserOutput
  parseYulLeaveStatement(source: string): ParserOutput
  parseYulLiteral(source: string): ParserOutput
  parseYulStatement(source: string): ParserOutput
  parseYulSwitchStatement(source: string): ParserOutput
  parseYulVariableDeclaration(source: string): ParserOutput
  parse(parserName: string, source: string): ParserOutput | null
}
export class ParserOutput {
  parseTree(): RuleNode | TokenNode | null
  errorCount(): bigint
  errorsAsStrings(source: string, withColour: boolean): Array<string>
  isValid(): boolean
}
export class LexCharsNode {
  get type(): LexNodeType.Chars
  get range(): TokenRange
}
export class LexChoiceNode {
  get type(): LexNodeType.Choice
  get range(): TokenRange
  get index(): bigint
  child(): LexCharsNode | LexChoiceNode | LexSequenceNode | LexNamedNode
}
export class LexSequenceNode {
  get type(): LexNodeType.Sequence
  get range(): TokenRange
  children(): (LexCharsNode | LexChoiceNode | LexSequenceNode | LexNamedNode)[]
}
export class LexNamedNode {
  get type(): LexNodeType.Named
  get range(): TokenRange
  get kind(): Token
  child(): LexCharsNode | LexChoiceNode | LexSequenceNode | LexNamedNode
}
