{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"slang","text":""},{"location":"#solidity-compiler-tooling-by-nomicfoundation","title":"Solidity compiler tooling by @NomicFoundation","text":"<p>A modular set of compiler APIs empowering the next generation of Solidity code analysis and developer tooling. Written in Rust and distributed in multiple languages.</p> <ul> <li>Announcement Post</li> <li>How to write your own Solidity linter using Slang, in 25 lines of code!</li> <li>Slang Internals</li> </ul> <p>This repository maintains the source code and release process for these projects:</p> <ul> <li>Slang Rust Crate + CLI</li> <li>Slang TypeScript Package</li> <li>Solidity Language Specification</li> </ul> <p>\u2757 This project is still in alpha, and is under active development. If you are planning on using it, please reach out to us on Telegram so we can help you get started.</p> <ul> <li>Slang Telegram Group</li> <li>We are hiring!</li> </ul>"},{"location":"internals/","title":"Internals","text":"<ul> <li>Repository Structure</li> <li>Development</li> <li>Design Docs</li> </ul>"},{"location":"internals/development/","title":"Development","text":""},{"location":"internals/development/#dev-containers","title":"Dev Containers","text":"<p>To make the developer experience as seamless and consistent as possible, we recommend using the VS Code devcontainer included in this repository. It is a light image that has the minimum required tools to build this project. If you are not familiar with containerized development, I recommend taking a look at the official VS Code guide. Using a devcontainer allows us to quickly setup/teardown the environment, and install/setup different dependencies for different projects, without polluting the local environment. In the future, it will enable us to include Windows and Mac OS specific images for cross-platform testing.</p> <p>If you would like to still develop outside a container, this should still be possible, as the CI will guarantee that your changes are safe. We intend to keep the images to a bare minimum, and install most dependencies through scripts you can run locally. However, using a common development container means sharing and standardizing useful settings and extensions for the editor (VS Code), the terminal (zsh), and any other tools.</p> <p>In the future, if we decide to enable code spaces, we can have a 1-click button to create and warm up a powerful dev machine to use in seconds, and running completely remote in a browser tab. It will make it trivial to switch between different versions and branches, or even use and debug multiple ones at the same time from different tabs.</p>"},{"location":"internals/development/#hermit","title":"Hermit","text":"<p>To install language-specific binaries and packages, we use Hermit, which installs all tools only when it is first needed/invoked, so you can quickly setup and build different projects quickly. It also takes care of updating your <code>$PATH</code> as you <code>cd</code> in and out of different projects, to make sure you are using the right tools every time. Follow this guide to install it locally to your machine, or simply build any included project, and it will bootstrap itself if it is missing.</p>"},{"location":"internals/development/#infra-cli","title":"Infra CLI","text":"<p>To ensure consistency, and a good experience for first-time developers, all build/test/run/debug commands should be written, versioned, and documented inside the <code>infra_cli</code> crate. This means that any dev instructions are well documented, versioned, and verified/executed with every build. It also means that we can minimize any manual setup or teardown steps during development, and just rely on that cli.</p> <p>You can access all such commands (from the hermit environment) by just running the <code>infra</code> script, which just refers to <code>$REPO_ROOT/scripts/bin/infra</code>. If this is your first time contributing, we recommend starting with <code>infra --help</code> to familiarize yourself with its capabilities.</p>"},{"location":"internals/development/#versioning-and-publishing","title":"Versioning and Publishing","text":"<p>We manage versioning through changesets. Each pull request can describe what user facing changes it is introducing, and include this information as a \"changeset\" markdown file along with source changes. These changeset files are analyzed and used to create another pull request to bump the repository version and update dependencies. Once the version bump is merged, artifacts are built and released to all registries.</p>"},{"location":"internals/development/#managing-dependencies","title":"Managing Dependencies","text":"<p>Our <code>$REPO_ROOT/.github/dependabot.yml</code> config runs automatic updates to our dependencies on a weekly basis. This handles <code>github-actions</code>, <code>npm</code>, <code>cargo</code>, and <code>pip</code> packages. However, two kinds of dependencies still need to be updated manually for now:</p> <ol> <li>Rust toolchains: <code>$RUST_STABLE_VERSION</code> and <code>$RUST_NIGHTLY_VERSION</code> defined in <code>hermit.hcl</code> and updated via <code>rustup install</code>.</li> <li>Hermit binaries defined in <code>$REPO_ROOT/bin/XXX.pkg</code>, and updated via <code>hermit install</code>.</li> </ol>"},{"location":"internals/repository-structure/","title":"Repository Structure","text":"<p>This repository is split into multiple projects at the root folder. Each project has its own dependencies and tools used to build, test, and ship different parts of the repository. For example, a Rust environment for the compiler, a Python environment for documentation, and a NodeJS environment for linters. This allows us to implement different binaries, APIs, and internal tools/scripts, and package/version them together, while having minimal inter-dependencies.</p> <p>All dependencies should have exact full versions, and we can rely on tooling to automatically upgrade it over time. It allows us to have perfectly reproducible builds for every commit, a critical aspect for compilers, and developer tools in general.</p>"},{"location":"internals/repository-structure/#directory-structure","title":"Directory Structure","text":"<p>Currently, the repository has the following projects:</p> <ul> <li><code>.changeset/</code>: pending user visible changes not released yet.</li> <li><code>.devcontainer/</code>: self-contained Docker image to develop, build, test, and publish.</li> <li><code>crates/</code>:<ul> <li><code>infra/</code>: contains the CLI used for development, and utilities to build/test/run/debug all other projects.</li> <li><code>codegen/</code>: language analysis APs that convert input crates to output crates below.</li> <li><code>solidity/</code>:<ul> <li><code>inputs/</code>: Solidity language definition.</li> <li><code>outputs/</code>: different packages and artifacts produced from it.</li> </ul> </li> </ul> </li> <li><code>documentation/</code>: mkdocs site to render project documentation.</li> </ul>"},{"location":"internals/design-docs/","title":"Design Docs","text":"<ul> <li>Language Definition v2</li> </ul>"},{"location":"internals/design-docs/language-definition-v2/","title":"Language Definition v2","text":"<p>This document describes the new language definition model (AKA DSL v2), and the features/possibilities it enables for both syntax and semantic analysis. Each section describes a part of the definition model, and how it can affect the scanner, parser, CST, and AST.</p> <p>This is a collection of different discussions we had over the last few weeks, and can (and should) be broken down into smaller work items if needed. It should be possible to map the current definition to the old one, so that we do incremental progress, instead of rewriting everything at once.</p>"},{"location":"internals/design-docs/language-definition-v2/#cst","title":"CST","text":"<p>We currently produce an untyped tree of nodes. It holds all parts of the input (byte for byte), even whitespace, comments, and unrecognized (skipped) parts. We can reconstruct the original input back from the CST, just by iterating on nodes in order. For memory/performance reasons, we don't hold positions/location information in the tree, but they are calculated during iterating/visiting the tree.</p> <p>The CST is useful for many use cases:</p> <ul> <li>Tools that only want to deal with document contents, like formatters, and syntax-only linters.</li> <li>For visitors/rewriters that want to run on certain nodes, regardless of their position/parent types.</li> <li>Reconstructing the original input, including trivia/whitespace, and any skipped (unrecognized) parts.</li> </ul> <p>Here is an example of the node type, similar to what we have now:</p> <pre><code>pub enum Node {\n    Terminal { node: Rc&lt;TerminalNode&gt; },\n    Nonterminal { node: Rc&lt;NonterminalNode&gt; },\n}\n\npub struct TerminalNode {\n    pub kind: TerminalKind,\n    pub text: String,\n}\n\npub struct NonterminalNode {\n    pub kind: NonterminalKind,\n    pub text_length: TextIndex,\n    pub children: Vec&lt;Node&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#ast","title":"AST","text":"<p>We intend to also produce a strongly typed tree (structs and enums). Having strong types provides safety/correctness guarantees for users. It also allows us to generate visitor and rewriter APIs automatically.</p> <p>Each AST node should provide an API to get the underlying CST node, where users can iterate over the actual terminals as they appear in input, and get their position in the source code. However, this is a one-way operation. CST nodes don't hold references to their AST nodes.</p> <p>Note: some compilers drop syntactic elements that don't carry semantic information from their AST (like semicolons, or commas). However, we don't make that distinction, as we intend to implement further analysis in the form of micro-passes, that each can rewrite and pick parts of the tree that are relevant to them. So our initial tree (AST) should be complete.</p>"},{"location":"internals/design-docs/language-definition-v2/#versioning","title":"Versioning","text":"<p>The biggest benefit of the new language definition is that it allows scanners and parsers to attempt parsing input belonging to any language version, and report errors afterwards if the input is not valid for the selected version. This is a huge benefit over existing parsers, where they will either parse an inaccurate superset of all versions, or they parse a specific version, and produce unhelpful errors like <code>Unrecognized 'abstract' keyword</code> when the current language version doesn't support it.</p> <p>Not only we will be able to recover from such errors and continue parsing, producing an accurate/complete tree at the end, but we will also be able to produce much better errors like: <code>The 'abstract' keyword is not supported in the current version X. Please upgrade to version Y instead to be able to use it</code>.</p>"},{"location":"internals/design-docs/language-definition-v2/#terminals","title":"Terminals","text":""},{"location":"internals/design-docs/language-definition-v2/#token-items","title":"Token Items","text":"<p>Tokens consist of one or more <code>TokenDefinition</code>. Each definition is separate/unique, but produces the same <code>TerminalKind</code>. This is useful for tokens like <code>DecimalLiteral</code> and <code>HexLiteral</code> who can have multiple forms, but each form is enabled or disabled in certain versions of the language.</p> <p>All definitions have a unique <code>Scanner</code>, and they can be combined in the same trie/FSM to produce a single token at each position in the input. Afterwards, the scanner can compare the definition's <code>enabled</code> property with the current language version, adding an error if they don't match, but continue parsing anyway.</p>"},{"location":"internals/design-docs/language-definition-v2/#keyword-items","title":"Keyword Items","text":"<p>Keywords also contribute a <code>TerminalKind</code>, and consist of one or more <code>KeywordDefinition</code>. But they have additional semantics:</p> <p>First, instead of defining a regular <code>Scanner</code>, it defines a <code>KeywordValue</code> that produces a finite set of possibilities. Most only produce one value (like <code>abstract</code> or <code>contract</code>), but some can produce multiple, like <code>bytesN</code> or <code>fixedMxN</code>, that can have different values for <code>M</code> and <code>N</code>. This is important for us to build hash sets and quickly check for membership.</p> <p>Second, because keywords can also overlap with identifiers, each keyword has an <code>identifier</code> property that refers to which identifier token they can match. Instead of being part of same trie/FSM as tokens, whenever we want to scan a keyword, we try to scan its identifier instead. Afterwards, we check if its contents match one of the values of the keyword.</p> <p>Third, they have two additional <code>reserved</code> property. We should use these when we scan identifiers, to make sure that the resulting identifier doesn't match a reserved keyword, and if so, we should report an error, but continue parsing.</p> <p>Unique to Solidity, keywords can be <code>reserved</code> in versions before or after the versions they are <code>enabled</code> in. They can also be not <code>reserved</code> in versions before or after the versions they stop being <code>enabled</code> in. So we have to have these additional checks, to be able to catch cases like when a certain input can both be a keyword and an identifier, or neither.</p> <p>We should also be able to generate a public API <code>is_keyword(TerminalKind)</code> for users to conveniently detect them if needed.</p>"},{"location":"internals/design-docs/language-definition-v2/#trivia-items","title":"Trivia Items","text":"<p>Trivia items are similar tokens, contributing their own <code>TerminalKind</code>. They are referred to from the language's top-level <code>leading_trivia</code> and <code>trailing_trivia</code> properties. Before and after each token, the scanner should try to scan these tokens, collecting them in a flat list.</p> <p>Previously, we used to create many <code>LeadingTrivia</code> and <code>TrailingTrivia</code> nodes that hold whitespace/comments. Not only this is wasteful memory-wise, it is also unnatural/unexpected to wrap whitespace in nonterminal nodes. Instead, I propose treating them like any other token, and storing them as siblings to the tokens they belong to (in-order). Not only this is simpler, it is also more efficient, and is natural to how input is consumed and produced.</p>"},{"location":"internals/design-docs/language-definition-v2/#fragment-items","title":"Fragment Items","text":"<p>Fragments are not visible to users, and don't contribute a <code>TerminalKind</code>. They are just a utility used to refactor common parts of the grammar, and avoid duplication. During processing the language definition, they are inlined wherever they are referenced.</p>"},{"location":"internals/design-docs/language-definition-v2/#nonterminals","title":"Nonterminals","text":""},{"location":"internals/design-docs/language-definition-v2/#struct-items","title":"Struct Items","text":"<p>Structs represent a flat list (sequence) of typed fields. They are the simplest nonterminal, and generate a <code>struct</code> AST type. Their fields match 1-1 with the item fields. The struct name contributes a <code>NonterminalKind</code>.</p> <p>Each field can be either <code>Required(T)</code> or <code>Optional(T)</code>. Required fields are always present and parsed. Optional fields can be omitted if they don't exist, and are represented with Rust's <code>Option&lt;T&gt;</code> type (or TypeScript <code>T | undefined</code>). However, optional fields have an additional <code>enabled</code> property. After parsing optional fields, we should compare them with the current language version, and produce errors if they don't match, but continue parsing normally.</p> <p>The type of each field can be a <code>Nonterminal(T)</code> or <code>Terminal(Set&lt;T&gt;)</code>. A nonterminal field refers to another item, and holds its type. A terminal field refers to one or more terminal items (all valid in this position), and is of type <code>TerminalNode</code>.</p> <p>Additionally, the struct also stores the CST node that holds its contents:</p> Definition<pre><code>Struct(\n    name = ParametersDeclaration,\n    fields = (\n        open_paren = Required(Terminal([OpenParen])),\n        parameters = Required(Nonterminal(Parameters)),\n        close_paren = Required(Terminal([CloseParen]))\n    )\n)\n</code></pre> AST Type<pre><code>pub struct ParametersDeclaration {\n    pub open_paren: Rc&lt;TerminalNode&gt;,\n    pub parameters: Rc&lt;Parameters&gt;,\n    pub close_paren: Rc&lt;TerminalNode&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#enum-items","title":"Enum Items","text":"<p>Enums represent an ordered choice operator of multiple variants (possibilities). The enum name itself does NOT contribute a <code>NonterminalKind</code>, since it will always result in one of its variants (each with a unique <code>TerminalKind</code> or a <code>NonterminalKind</code>. They only exist in the AST, and don't affect the CST at all.</p> <p>We attempt to parse each variant (in-order), and choose the first one that succeeds. However, each variant can have an additional <code>enabled</code> property. We should always try to parse the variants that are valid in the current version first, and if not, still parse the rest, but produce an error afterwards. The fields of each variant are parsed similar to a struct fields (example above).</p> Definition<pre><code>Enum(\n    name = FunctionBody,\n    variants = [\n        EnumVariant(name = Block, reference = Block),\n        EnumVariant(name = Semicolon, reference = Semicolon)\n    ]\n)\n</code></pre> AST Type<pre><code>pub enum FunctionBody {\n    Block {\n        block: Rc&lt;Block&gt;,\n\n        cst: Rc&lt;NonterminalNode&gt;,\n    },\n    Semicolon {\n        semicolon: Rc&lt;TerminalNode&gt;,\n\n        cst: Rc&lt;NonterminalNode&gt;,\n    },\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#repeated-items","title":"Repeated Items","text":"<p>Repeated items represent a list of items of the same kind. The item name contributes a <code>NonterminalKind</code>. The AST type is a wrapper around a <code>Vec&lt;T&gt;</code>, with any utilities we need to add for convenience.</p> <p>It has an <code>allow_empty</code> boolean property, which allows parsing zero items. If it is <code>false</code>, we should still allow parsing zero items, but produce an error afterwards.</p> Definition<pre><code>Repeated(\n    name = FunctionAttributes,\n    repeated = FunctionAttribute,\n    allow_empty = true\n)\n</code></pre> AST Type<pre><code>pub struct FunctionAttributes {\n    pub items: Vec&lt;Rc&lt;FunctionAttribute&gt;&gt;\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#separated-items","title":"Separated Items","text":"<p>Separated items represent a list of items of the same kind, separated by a delimiter. The item name contributes a <code>NonterminalKind</code>. The AST type is a wrapper around two <code>Vec&lt;T&gt;</code> for items and their delimiters, with any utilities we need to add for convenience. For example, we should add APIs to create iterators for only the separated items, the separators, or both (in-order).</p> <p>It has an <code>allow_empty</code> boolean property, which allows parsing zero items. If it is <code>false</code>, we should still allow parsing zero items, but produce an error afterwards. We should also allow parsing a trailing separator at the end, but still produce an error afterwards.</p> Definition<pre><code>Separated(\n    name = EventParameters,\n    separated = EventParameter,\n    separator = Comma,\n    allow_empty = true\n)\n</code></pre> AST Type<pre><code>pub struct EventParameters {\n    pub items: Vec&lt;Rc&lt;EventParameter&gt;&gt;\n    pub separators: Vec&lt;Rc&lt;TerminalNode&gt;&gt;\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#precedence-items","title":"Precedence Items","text":"<p>This is perhaps the most complex nonterminal. It still uses the same PRATT algorithm from the previous implementation (no changes there), but adapted for the new AST types. It has two lists:</p> <p>First, a list of <code>precedence_expressions</code>, with each expression having a list of operators. Each operator has its own versioning (<code>enabled</code> property), a list of fields, and a model (prefix/postfix/binary).</p> <p>The operators from all expressions are flattened and combined in the parent PRATT parser. That grouping is only used to indicate that some operators can produce the same <code>PrecedenceExpression</code> name. However, we should exclude operators that don't match the current language version. This is useful for things like <code>ExponentiationExpression</code> where it has two operators with different associativity, but defined in enabled/disabled in different versions.</p> <p>Second, a list of <code>primary_expressions</code>, with their own versioning (<code>enabled</code> property) as well. We should try to parse them as an operator (similar to <code>EnumItem</code>), and produce an error if the version doesn't match afterwards.</p> <p>It is important to note that the item name doesn't contribute a <code>NonterminalKind</code>, but each <code>PrecedenceExpression</code> under it contributes one.</p> Definition<pre><code>Precedence(\n    name = Expression,\n    precedence_expressions = [\n        PrecedenceExpression(\n            name = AdditionExpression,\n            operators = [PrecedenceOperator(\n                model = BinaryLeftAssociative,\n                fields = (operator = Required(Terminal([Plus])))\n            )]\n        ),\n        PrecedenceExpression(\n            name = FunctionCallExpression,\n            operators = [PrecedenceOperator(\n                model = Postfix,\n                fields = (\n                    open_paren = Required(Terminal([OpenParen])),\n                    arguments = Required(Nonterminal(Arguments)),\n                    close_paren = Required(Terminal([CloseParen]))\n                )\n            )]\n        ),\n        PrecedenceExpression(\n            name = NegationExpression,\n            operators = [PrecedenceOperator(\n                model = Prefix,\n                fields = (operator = Required(Terminal([Not])))\n            )]\n        )\n    )],\n    primary_expressions = [\n        PrimaryExpression(expression = Identifier),\n        PrimaryExpression(expression = NumberLiteral),\n        PrimaryExpression(expression = StringLiteral)\n    ]\n)\n</code></pre> AST Type<pre><code>pub enum Expression {\n    AdditionExpression { expression: Rc&lt;AdditionExpression&gt; },\n    FunctionCallExpression { expression: Rc&lt;FunctionCallExpression&gt; },\n    NegationExpression { expression: Rc&lt;NegationExpression&gt; },\n\n    Identifier { expression: Rc&lt;TerminalNode&gt; },\n    NumberLiteral { expression: Rc&lt;TerminalNode&gt; },\n    StringLiteral { expression: Rc&lt;TerminalNode&gt; },\n}\n\npub struct AdditionExpression {\n    // 'left_operand' auto-generated (before) because it is a binary expression, and same type as parent\n    pub left_operand: Rc&lt;Expression&gt;,\n    // operator 'fields' are flattened into the expression node here\n    pub operator: Rc&lt;TerminalNode&gt;,\n    // 'right_operand' auto-generated (after) because it is a binary expression, and same type as parent\n    pub right_operand: Rc&lt;Expression&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n\npub struct FunctionCallExpression {\n    // 'operand' auto-generated (before) because it is a postfix expression, and same type as parent\n    pub operand: Rc&lt;Expression&gt;,\n    // operator 'fields' are flattened into the expression node here\n    pub open_paren: Rc&lt;TerminalNode&gt;,\n    pub arguments: Rc&lt;Arguments&gt;,\n    pub close_paren: Rc&lt;TerminalNode&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n\npub struct NegationExpression {\n    // operator 'fields' are flattened into the expression node here\n    pub operator: Rc&lt;TerminalNode&gt;,\n    // 'operand' auto-generated (after) because it is a prefix expression, and same type as parent\n    pub operand: Rc&lt;Expression&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#error-recovery","title":"Error Recovery","text":"<p>For the CST, I think the current algorithms work well, and we should be able to keep them. Unrecognized (skipped) input is grouped into one token, and we can just add it as-is to the <code>cst</code> node under its AST node.</p> <p>During AST construction, we will simply check for <code>TerminalKind::UNRECOGNIZED</code> nodes, and skip construction if there are any.</p>"},{"location":"internals/design-docs/language-definition-v2/#public-api-changes","title":"Public API Changes","text":"<p>Based on the above, I propose the following changes to the current public API:</p> <ul> <li>Rename <code>TokenKind</code> to <code>TerminalKind</code>, since it will also refer to trivia.</li> <li>Rename <code>RuleKind</code> to <code>NonterminalKind</code>, since \"rule\" is ambiguous.</li> <li>Rename <code>TerminalKind::SKIPPED</code>to <code>UNRECOGNIZED</code> for clarity.</li> <li>Hide <code>LexicalContext</code> and <code>fn scan(TokenKind)</code> from the public API, as it is a short-term workaround,     and will be replaced later when we have language embedding.</li> <li>Remove <code>ProductionKind</code> completely, since it is no longer needed. We only need to expose <code>fn parse(NonterminalKind)</code>.</li> <li>Since <code>EndOFFileTrivia</code> no longer exists, <code>ParseResult</code> should collect any remaining trivia at the end of the input,     and include it in the <code>ParseResult</code> returned, for any kind of node, not just <code>SourceUnit</code>.</li> </ul>"},{"location":"internals/design-docs/language-definition-v2/#visitors-and-cursors","title":"Visitors and Cursors","text":"<p>The current CST visitors/cursors should still work as-is, since the CST tree will be unchanged. However, the new AST types allow us in the future to produce typed visitors and traits with named functions for every node type, similar to a lot of other AST processing libraries. I want to at least produce an immutable <code>Visitor</code> and a mutable <code>Rewriter</code>.</p>"},{"location":"solidity-specification/","title":"Solidity Specification","text":""},{"location":"solidity-specification/#solidity-specification","title":"Solidity Specification","text":"<ul> <li>Supported Versions</li> <li>1. File Structure</li> <li>2. Definitions</li> <li>3. Types</li> <li>4. Statements</li> <li>5. Expressions</li> <li>6. Yul</li> </ul>"},{"location":"solidity-specification/supported-versions/","title":"Supported Versions","text":"<p>This specification compiles information from 82 publicly released versions of Solidity:</p> <p><code>0.4.11</code> <code>0.4.12</code> <code>0.4.13</code> <code>0.4.14</code> <code>0.4.15</code> <code>0.4.16</code> <code>0.4.17</code> <code>0.4.18</code> <code>0.4.19</code> <code>0.4.20</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.23</code> <code>0.4.24</code> <code>0.4.25</code> <code>0.4.26</code> <code>0.5.0</code> <code>0.5.1</code> <code>0.5.2</code> <code>0.5.3</code> <code>0.5.4</code> <code>0.5.5</code> <code>0.5.6</code> <code>0.5.7</code> <code>0.5.8</code> <code>0.5.9</code> <code>0.5.10</code> <code>0.5.11</code> <code>0.5.12</code> <code>0.5.13</code> <code>0.5.14</code> <code>0.5.15</code> <code>0.5.16</code> <code>0.5.17</code> <code>0.6.0</code> <code>0.6.1</code> <code>0.6.2</code> <code>0.6.3</code> <code>0.6.4</code> <code>0.6.5</code> <code>0.6.6</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.9</code> <code>0.6.10</code> <code>0.6.11</code> <code>0.6.12</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.2</code> <code>0.7.3</code> <code>0.7.4</code> <code>0.7.5</code> <code>0.7.6</code> <code>0.8.0</code> <code>0.8.1</code> <code>0.8.2</code> <code>0.8.3</code> <code>0.8.4</code> <code>0.8.5</code> <code>0.8.6</code> <code>0.8.7</code> <code>0.8.8</code> <code>0.8.9</code> <code>0.8.10</code> <code>0.8.11</code> <code>0.8.12</code> <code>0.8.13</code> <code>0.8.14</code> <code>0.8.15</code> <code>0.8.16</code> <code>0.8.17</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.20</code> <code>0.8.21</code> <code>0.8.22</code> <code>0.8.23</code> <code>0.8.24</code> <code>0.8.25</code> <code>0.8.26</code> <code>0.8.27</code></p> <p>Among which, 35 versions have breaking changes:</p> <p><code>0.4.11</code> <code>0.4.12</code> <code>0.4.14</code> <code>0.4.16</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.25</code> <code>0.5.0</code> <code>0.5.3</code> <code>0.5.5</code> <code>0.5.8</code> <code>0.5.10</code> <code>0.5.12</code> <code>0.5.14</code> <code>0.6.0</code> <code>0.6.2</code> <code>0.6.5</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.11</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.4</code> <code>0.8.0</code> <code>0.8.4</code> <code>0.8.7</code> <code>0.8.8</code> <code>0.8.10</code> <code>0.8.13</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.22</code> <code>0.8.24</code> <code>0.8.25</code> <code>0.8.27</code></p>"},{"location":"solidity-specification/01-file-structure/","title":"1. File Structure","text":""},{"location":"solidity-specification/01-file-structure/#1-file-structure","title":"1. File Structure","text":"<ul> <li>1.1. License Specifiers</li> <li>1.2. Source Unit</li> <li>1.3. Pragma Directives</li> <li>1.4. Import Directives</li> <li>1.5. Using Directives</li> <li>1.6. Trivia</li> <li>1.7. Nat Spec Format</li> <li>1.8. Keywords</li> <li>1.9. Punctuation</li> </ul>"},{"location":"solidity-specification/01-file-structure/01-license-specifiers/","title":"1.1. License Specifiers","text":""},{"location":"solidity-specification/01-file-structure/01-license-specifiers/#11-license-specifiers","title":"1.1. License Specifiers","text":""},{"location":"solidity-specification/01-file-structure/01-license-specifiers/#license-comment","title":"License Comment","text":"<p>This comment line declares that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default. The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\n</code></pre> <p>When omitted, the compiler produces a warning to add one. The compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the metadata.</p> <p>If you do not want to specify a license or if the source code is not open-source, please use the special value <code>UNLICENSED</code>. Note that <code>UNLICENSED</code> (no usage allowed, not present in SPDX license list) is different from <code>UNLICENSE</code> (grants all rights to everyone).</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/02-source-unit/","title":"1.2. Source Unit","text":""},{"location":"solidity-specification/01-file-structure/02-source-unit/#12-source-unit","title":"1.2. Source Unit","text":""},{"location":"solidity-specification/01-file-structure/02-source-unit/#syntax","title":"Syntax","text":"<pre>SourceUnit = (* members: *) SourceUnitMembers;</pre> <pre></pre> <pre>SourceUnitMembers = (* item: *) SourceUnitMember*;</pre> <pre></pre> <pre>SourceUnitMember = (* variant: *) PragmaDirective                 | (* variant: *) ImportDirective                 | (* variant: *) ContractDefinition                 | (* variant: *) InterfaceDefinition                 | (* variant: *) LibraryDefinition                 | (* variant: *) StructDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) EnumDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) FunctionDefinition (* Introduced in 0.7.1 *)                 | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)                 | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)                 | (* variant: *) UsingDirective (* Introduced in 0.8.13 *)                 | (* variant: *) EventDefinition (* Introduced in 0.8.22 *)                 | (* variant: *) ConstantDefinition; (* Introduced in 0.7.4 *)</pre>"},{"location":"solidity-specification/01-file-structure/02-source-unit/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/","title":"1.3. Pragma Directives","text":""},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#13-pragma-directives","title":"1.3. Pragma Directives","text":""},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#syntax","title":"Syntax","text":"<pre>PragmaDirective = (* pragma_keyword: *) PRAGMA_KEYWORD                  (* pragma: *) Pragma                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>Pragma = (* variant: *) ABICoderPragma       | (* variant: *) ExperimentalPragma       | (* variant: *) VersionPragma;</pre> <pre></pre> <pre>ABICoderPragma = (* abicoder_keyword: *) ABICODER_KEYWORD                 (* version: *) IDENTIFIER;</pre> <pre></pre> <pre>ExperimentalPragma = (* experimental_keyword: *) EXPERIMENTAL_KEYWORD                     (* feature: *) ExperimentalFeature;</pre> <pre></pre> <pre>ExperimentalFeature = (* variant: *) IDENTIFIER                    | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>VersionPragma = (* solidity_keyword: *) SOLIDITY_KEYWORD                (* sets: *) VersionExpressionSets;</pre> <pre></pre> <pre>VersionExpressionSets = (* item: *) VersionExpressionSet ((* separator: *) BAR_BAR (* item: *) VersionExpressionSet)*;</pre> <pre></pre> <pre>VersionExpressionSet = (* item: *) VersionExpression+;</pre> <pre></pre> <pre>VersionExpression = (* variant: *) VersionRange                  | (* variant: *) VersionTerm;</pre> <pre></pre> <pre>VersionRange = (* start: *) VersionLiteral               (* minus: *) MINUS               (* end: *) VersionLiteral;</pre> <pre></pre> <pre>VersionTerm = (* operator: *) VersionOperator?              (* literal: *) VersionLiteral;</pre> <pre></pre> <pre>VersionOperator = (* variant: *) CARET                | (* variant: *) TILDE                | (* variant: *) EQUAL                | (* variant: *) LESS_THAN                | (* variant: *) GREATER_THAN                | (* variant: *) LESS_THAN_EQUAL                | (* variant: *) GREATER_THAN_EQUAL;</pre> <pre></pre> <pre>VersionLiteral = (* variant: *) SimpleVersionLiteral               | (* variant: *) SINGLE_QUOTED_VERSION_LITERAL               | (* variant: *) DOUBLE_QUOTED_VERSION_LITERAL;</pre> <pre></pre> <pre>SimpleVersionLiteral = (* item: *) VERSION_SPECIFIER ((* separator: *) PERIOD (* item: *) VERSION_SPECIFIER)*;</pre> <pre></pre> <pre>VERSION_SPECIFIER = \u00abVERSION_SPECIFIER_FRAGMENT\u00bb;</pre> <pre></pre> <pre>SINGLE_QUOTED_VERSION_LITERAL = \"'\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_VERSION_LITERAL = '\"' \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* '\"';</pre> <pre></pre> <pre>\u00abVERSION_SPECIFIER_FRAGMENT\u00bb = ((\"0\"\u2026\"9\") | \"x\" | \"X\" | \"*\")+;</pre> <pre></pre> <pre>(* Never reserved *)ABICODER_KEYWORD = \"abicoder\";</pre> <pre></pre> <pre>(* Never reserved *)EXPERIMENTAL_KEYWORD = \"experimental\";</pre> <pre></pre> <pre>(* Never reserved *)SOLIDITY_KEYWORD = \"solidity\";</pre>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#version-pragma","title":"Version Pragma","text":"<p>This line declares which Solidity language version it was written for. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. An error is produced if the running compiler version does not match these requirements.</p> <p>Note that multiple version pragmas are supported, and the compiler will verify each pragma separately.</p> <p>For example, this line specifies that the source code is written for Solidity version <code>0.4.16</code>, or a newer version of the language up to, but not including version <code>0.9.0</code>:</p> <pre><code>pragma solidity &gt;=0.4.16 &lt;0.9.0;\n</code></pre>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#abi-coder-pragma","title":"ABI Coder Pragma","text":"<p>Used to instruct the compiler to choose a specific ABI encoder/decoder. The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. It might produce less optimal code and has not received as much testing as the old encoder.</p> <pre><code>pragma abicoder v1;\n// OR\npragma abicoder v2;\n</code></pre>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#experimental-pragma","title":"Experimental Pragma","text":"<p>It can be used to enable features of the compiler or language that are not yet enabled by default. Compilers should produce an error on unrecognized pragmas (or earlier versions before they were released), and a warning before the stable version. After the stable version, this should not have an effect.</p>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#abiencoderv2","title":"ABIEncoderV2","text":"<p>Please see the <code>abicoder</code> pragma defined above.</p> <pre><code>pragma experimental ABIEncoderV2;\n</code></pre>"},{"location":"solidity-specification/01-file-structure/03-pragma-directives/#smtchecker","title":"SMTChecker","text":"<p>If you use <code>SMTChecker</code>, then you get additional safety warnings which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound.</p> <pre><code>pragma experimental SMTChecker;\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/04-import-directives/","title":"1.4. Import Directives","text":""},{"location":"solidity-specification/01-file-structure/04-import-directives/#14-import-directives","title":"1.4. Import Directives","text":""},{"location":"solidity-specification/01-file-structure/04-import-directives/#syntax","title":"Syntax","text":"<pre>ImportDirective = (* import_keyword: *) IMPORT_KEYWORD                  (* clause: *) ImportClause                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ImportClause = (* variant: *) PathImport             | (* variant: *) NamedImport             | (* variant: *) ImportDeconstruction;</pre> <pre></pre> <pre>PathImport = (* path: *) StringLiteral             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>NamedImport = (* asterisk: *) ASTERISK              (* alias: *) ImportAlias              (* from_keyword: *) FROM_KEYWORD              (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstruction = (* open_brace: *) OPEN_BRACE                       (* symbols: *) ImportDeconstructionSymbols                       (* close_brace: *) CLOSE_BRACE                       (* from_keyword: *) FROM_KEYWORD                       (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstructionSymbols = (* item: *) ImportDeconstructionSymbol ((* separator: *) COMMA (* item: *) ImportDeconstructionSymbol)*;</pre> <pre></pre> <pre>ImportDeconstructionSymbol = (* name: *) IDENTIFIER                             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>ImportAlias = (* as_keyword: *) AS_KEYWORD              (* identifier: *) IDENTIFIER;</pre>"},{"location":"solidity-specification/01-file-structure/04-import-directives/#importing-files","title":"Importing Files","text":"<p>At a file level, you can use import statements of the following form:</p> <pre><code>import \"filename\";\n</code></pre> <p>This statement imports all global symbols from <code>filename</code> (and symbols imported there) into the current global scope. This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside <code>filename</code>, they automatically appear in all files that import like this from \u201cfilename\u201d. It is better to import specific symbols explicitly, which results in all global symbols being available under the <code>myFile</code> symbol:</p> <pre><code>import * as myFile from \"filename\";\n// OR\nimport \"filename\" as myFile;\n</code></pre>"},{"location":"solidity-specification/01-file-structure/04-import-directives/#importing-specific-symbols","title":"Importing Specific Symbols","text":"<p>You can import only the symbols you use from a specific file, using the syntax:</p> <pre><code>import {symbol1, symbol2} from \"filename\";\n</code></pre> <p>Which will create <code>symbol1</code> and <code>symbol1</code> to use in your code. If there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols <code>alias</code> and <code>symbol2</code> which reference <code>symbol1</code> and <code>symbol2</code> from inside <code>filename</code>, respectively:</p> <pre><code>import {symbol1 as alias, symbol2} from \"filename\";\n</code></pre>"},{"location":"solidity-specification/01-file-structure/04-import-directives/#virtual-file-system","title":"Virtual File System","text":"<p>In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (virtual filesystem or VFS for short) where each source unit is assigned a unique source unit name which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database.</p> <ul> <li>Using the <code>solc</code> binary CLI, you can pass disk file system paths to be used.</li> <li>Using the <code>solc</code> JSON API, you can pass the explicit file contents to be parsed.</li> <li>Using other tools like the Remix IDE you can import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry.</li> </ul> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/05-using-directives/","title":"1.5. Using Directives","text":""},{"location":"solidity-specification/01-file-structure/05-using-directives/#15-using-directives","title":"1.5. Using Directives","text":""},{"location":"solidity-specification/01-file-structure/05-using-directives/#syntax","title":"Syntax","text":"<pre>UsingDirective = (* using_keyword: *) USING_KEYWORD                 (* clause: *) UsingClause                 (* for_keyword: *) FOR_KEYWORD                 (* target: *) UsingTarget                 (* global_keyword: *) GLOBAL_KEYWORD? (* Introduced in 0.8.13 *)                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>UsingClause = (* variant: *) IdentifierPath            | (* variant: *) UsingDeconstruction; (* Introduced in 0.8.13 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstruction = (* open_brace: *) OPEN_BRACE                      (* symbols: *) UsingDeconstructionSymbols                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbols = (* item: *) UsingDeconstructionSymbol ((* separator: *) COMMA (* item: *) UsingDeconstructionSymbol)*;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbol = (* name: *) IdentifierPath                            (* alias: *) UsingAlias?; (* Introduced in 0.8.19 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingAlias = (* as_keyword: *) AS_KEYWORD             (* operator: *) UsingOperator;</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingOperator = (* variant: *) AMPERSAND              | (* variant: *) ASTERISK              | (* variant: *) BANG_EQUAL              | (* variant: *) BAR              | (* variant: *) CARET              | (* variant: *) EQUAL_EQUAL              | (* variant: *) GREATER_THAN              | (* variant: *) GREATER_THAN_EQUAL              | (* variant: *) LESS_THAN              | (* variant: *) LESS_THAN_EQUAL              | (* variant: *) MINUS              | (* variant: *) PERCENT              | (* variant: *) PLUS              | (* variant: *) SLASH              | (* variant: *) TILDE;</pre> <pre></pre> <pre>UsingTarget = (* variant: *) TypeName            | (* variant: *) ASTERISK;</pre>"},{"location":"solidity-specification/01-file-structure/05-using-directives/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/06-trivia/","title":"1.6. Trivia","text":""},{"location":"solidity-specification/01-file-structure/06-trivia/#16-trivia","title":"1.6. Trivia","text":""},{"location":"solidity-specification/01-file-structure/06-trivia/#syntax","title":"Syntax","text":"<pre>WHITESPACE = (\" \" | \"\\t\")+;</pre> <pre></pre> <pre>END_OF_LINE = \"\\n\" | (\"\\r\" \"\\n\"?);</pre> <pre></pre> <pre>SINGLE_LINE_COMMENT = \"//\" (!(\"\\r\" \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_COMMENT = \"/*\" (!\"*\" | \"*\")* \"*/\";</pre> <pre></pre> <pre>SINGLE_LINE_NAT_SPEC_COMMENT = \"///\" (!(\"\\r\" \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_NAT_SPEC_COMMENT = \"/**\" (!\"*\" | \"*\")* \"*/\";</pre>"},{"location":"solidity-specification/01-file-structure/06-trivia/#single-line-comments","title":"Single Line Comments","text":"<p>A single-line comment is terminated by any unicode line terminator (<code>LF</code>, <code>VF</code>, <code>FF</code>, <code>CR</code>, <code>NEL</code>, <code>LS</code> or <code>PS</code>) in UTF-8 encoding. The terminator is still part of the source code after the comment, so if it is not an ASCII symbol (these are <code>NEL</code>, <code>LS</code> and <code>PS</code>), it will lead to a parser error.</p> <pre><code>// This is a single-line comment.\n</code></pre>"},{"location":"solidity-specification/01-file-structure/06-trivia/#multi-line-comments","title":"Multi-line Comments","text":"<p>Comments starting with <code>/*</code> and ending with <code>*/</code> are allowed to range multiple lines:</p> <pre><code>/*\nThis is a\nmulti-line comment.\n*/\n</code></pre>"},{"location":"solidity-specification/01-file-structure/06-trivia/#natspec-comments","title":"NatSpec Comments","text":"<p>Additionally, there is another type of comment called a NatSpec comment. They are written with a triple slash <code>///</code> or a double asterisk block <code>/**...*/</code> and they should be used directly above function declarations or statements. It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI).</p> <pre><code>/// @author My Team Name\n/// @title A simple contract example\ncontract MyContract {}\n</code></pre> <p>Please see the NatSpec Format section for further information.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/","title":"1.7. Nat Spec Format","text":""},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#17-nat-spec-format","title":"1.7. Nat Spec Format","text":""},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#what-is-natspec","title":"What is NatSpec?","text":"<p>Solidity contracts can use a special form of comments to provide rich documentation for functions, return variables and more. This special form is named the Ethereum Natural Language Specification Format (NatSpec). It was inspired by Doxygen, and while it uses Doxygen-style comments and tags, there is no intention to keep strict compatibility with Doxygen.</p> <p>It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is used in:</p> <ul> <li>Developer-focused output, for documenting, sharing, and reusing the source code.</li> <li>User-facing output, at the time that they will interact with the contract (i.e. sign a transaction).</li> <li>Machine-readable output, to be used by downstream tools.</li> </ul> <p>Documentation can be inserted above each <code>contract</code>, <code>interface</code>, <code>library</code>, <code>function</code>, <code>event</code> and <code>state variable</code>.</p> <p>They can either exist in a single line format, starting with <code>///</code>:</p> <pre><code>/// @title An example contract\ncontract MyContract {}\n</code></pre> <p>And also in multi-line format, starting with <code>/**</code> and ending with <code>*/</code>:</p> <pre><code>/**\n * @title An example contract\n */\ncontract MyContract {}\n</code></pre>"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#tags","title":"Tags","text":"<p>Tags categorize different comments according to their purpose. The table below shows the different tags supported. Please note that they are optional, and without one, the entire comment will be interpreted as it had a <code>@notice</code> tag.</p> Tag Description Context <code>@title</code> A title that should describe the contract/interface <code>contract</code>, <code>library</code>, <code>interface</code> <code>@author</code> The name of the author <code>contract</code>, <code>library</code>, <code>interface</code> <code>@notice</code> Explain to an end user what this does <code>contract</code>, <code>library</code>, <code>interface</code>, <code>function</code>, <code>event</code>, <code>state variable</code> <code>@dev</code> Explain to a developer any extra details <code>contract</code>, <code>library</code>, <code>interface</code>, <code>function</code>, <code>event</code>, <code>state variable</code> <code>@param</code> Documents a parameter just like in Doxygen (must be followed by parameter name) <code>function</code>, <code>event</code> <code>@return</code> Documents the return variables of a contract's function <code>function</code>, <code>state variable</code> <code>@inheritdoc</code> Copies all missing tags from the base function (must be followed by the contract name) <code>function</code>, <code>state variable</code> <code>@custom:FOO</code> Custom tag, semantics is application-defined can be used everywhere"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#function-return-types","title":"Function Return Types","text":"<p>If your function returns multiple values, like <code>(int quotient, int remainder)</code> then use multiple <code>@return</code> statements in the same format as the <code>@param</code> statements.</p>"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#custom-tags","title":"Custom Tags","text":"<p>Custom tags start with <code>@custom:</code> and must be followed by one or more lowercase letters or hyphens. It cannot start with a hyphen however. They can be used everywhere and are part of the developer documentation. For example, <code>@custom:foo</code> or <code>@custom:foo-bar</code>. A good use case is analysis and verification tools.</p>"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#dynamic-expressions","title":"Dynamic expressions","text":"<p>The Solidity compiler will pass through NatSpec documentation from your Solidity source code to the JSON output as described in this guide. The consumer of this JSON output may present this to the end-user directly or it may apply some pre-processing.</p> <p>Specifying these dynamic expressions is outside the scope of the Solidity documentation. However, you can find one useful example in the RadSpec Project, where it evaluates references to function inputs to its values. For example, this line:</p> <pre><code>/// @notice This function will multiply `a` by 7\n</code></pre> <p>Can be evaluated as the following, where the value of <code>a</code> is <code>10</code>:</p> <pre><code>This function will multiply 10 by 7\n</code></pre>"},{"location":"solidity-specification/01-file-structure/07-nat-spec-format/#inheritance","title":"Inheritance","text":"<p>Functions without NatSpec will automatically inherit the documentation of their base function. Exceptions to this are:</p> <ul> <li>When the parameter names are different.</li> <li>When there is more than one base function.</li> <li>When there is an explicit <code>@inheritdoc</code> tag which specifies which contract should be used to inherit.</li> </ul> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/08-keywords/","title":"1.8. Keywords","text":""},{"location":"solidity-specification/01-file-structure/08-keywords/#18-keywords","title":"1.8. Keywords","text":""},{"location":"solidity-specification/01-file-structure/08-keywords/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.6.0 *)ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>ADDRESS_KEYWORD = \"address\";</pre> <pre></pre> <pre>AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>(* Deprecated in 0.8.0 *)BYTE_KEYWORD = \"byte\";</pre> <pre></pre> <pre>BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>(* Introduced in 0.5.0 *)(* Reserved in 0.5.0 *)CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)(* Reserved in 0.5.0 *)CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)(* Reserved in 0.5.0 *)EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)ERROR_KEYWORD = \"error\";</pre> <pre></pre> <pre>ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>FIXED_KEYWORD = \"fixed\";FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>(* Never reserved *)FROM_KEYWORD = \"from\";</pre> <pre></pre> <pre>FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)(* Never reserved *)GLOBAL_KEYWORD = \"global\";</pre> <pre></pre> <pre>(* Introduced in 0.6.11 *)(* Reserved in 0.7.0 *)GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Introduced in 0.6.5 *)(* Reserved in 0.5.0 *)IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.5.0 *)OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>RETURN_KEYWORD = \"return\";</pre> <pre></pre> <pre>RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)REVERT_KEYWORD = \"revert\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.8.27 *)(* Never reserved *)TRANSIENT_KEYWORD = \"transient\";</pre> <pre></pre> <pre>TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Introduced in 0.5.3 *)TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>UFIXED_KEYWORD = \"ufixed\";UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)(* Reserved in 0.5.0 *)UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.6.0 *)VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YEARS_KEYWORD = \"years\";</pre>"},{"location":"solidity-specification/01-file-structure/08-keywords/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/01-file-structure/09-punctuation/","title":"1.9. Punctuation","text":""},{"location":"solidity-specification/01-file-structure/09-punctuation/#19-punctuation","title":"1.9. Punctuation","text":""},{"location":"solidity-specification/01-file-structure/09-punctuation/#syntax","title":"Syntax","text":"<pre>OPEN_PAREN = \"(\";</pre> <pre></pre> <pre>CLOSE_PAREN = \")\";</pre> <pre></pre> <pre>OPEN_BRACKET = \"[\";</pre> <pre></pre> <pre>CLOSE_BRACKET = \"]\";</pre> <pre></pre> <pre>OPEN_BRACE = \"{\";</pre> <pre></pre> <pre>CLOSE_BRACE = \"}\";</pre> <pre></pre> <pre>COMMA = \",\";</pre> <pre></pre> <pre>PERIOD = \".\";</pre> <pre></pre> <pre>QUESTION_MARK = \"?\";</pre> <pre></pre> <pre>SEMICOLON = \";\";</pre> <pre></pre> <pre>COLON = \":\";</pre> <pre></pre> <pre>COLON_EQUAL = \":=\";</pre> <pre></pre> <pre>EQUAL = \"=\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)EQUAL_COLON = \"=:\";</pre> <pre></pre> <pre>EQUAL_EQUAL = \"==\";</pre> <pre></pre> <pre>EQUAL_GREATER_THAN = \"=&gt;\";</pre> <pre></pre> <pre>ASTERISK = \"*\";</pre> <pre></pre> <pre>ASTERISK_EQUAL = \"*=\";</pre> <pre></pre> <pre>ASTERISK_ASTERISK = \"**\";</pre> <pre></pre> <pre>BAR = \"|\";</pre> <pre></pre> <pre>BAR_EQUAL = \"|=\";</pre> <pre></pre> <pre>BAR_BAR = \"||\";</pre> <pre></pre> <pre>AMPERSAND = \"&amp;\";</pre> <pre></pre> <pre>AMPERSAND_EQUAL = \"&amp;=\";</pre> <pre></pre> <pre>AMPERSAND_AMPERSAND = \"&amp;&amp;\";</pre> <pre></pre> <pre>LESS_THAN = \"&lt;\";</pre> <pre></pre> <pre>LESS_THAN_EQUAL = \"&lt;=\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN = \"&lt;&lt;\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN_EQUAL = \"&lt;&lt;=\";</pre> <pre></pre> <pre>GREATER_THAN = \"&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_EQUAL = \"&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN = \"&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN = \"&gt;&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;&gt;=\";</pre> <pre></pre> <pre>PLUS = \"+\";</pre> <pre></pre> <pre>PLUS_EQUAL = \"+=\";</pre> <pre></pre> <pre>PLUS_PLUS = \"++\";</pre> <pre></pre> <pre>MINUS = \"-\";</pre> <pre></pre> <pre>MINUS_EQUAL = \"-=\";</pre> <pre></pre> <pre>MINUS_MINUS = \"--\";</pre> <pre></pre> <pre>MINUS_GREATER_THAN = \"-&gt;\";</pre> <pre></pre> <pre>SLASH = \"/\";</pre> <pre></pre> <pre>SLASH_EQUAL = \"/=\";</pre> <pre></pre> <pre>PERCENT = \"%\";</pre> <pre></pre> <pre>PERCENT_EQUAL = \"%=\";</pre> <pre></pre> <pre>BANG = \"!\";</pre> <pre></pre> <pre>BANG_EQUAL = \"!=\";</pre> <pre></pre> <pre>CARET = \"^\";</pre> <pre></pre> <pre>CARET_EQUAL = \"^=\";</pre> <pre></pre> <pre>TILDE = \"~\";</pre>"},{"location":"solidity-specification/01-file-structure/09-punctuation/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/","title":"2. Definitions","text":""},{"location":"solidity-specification/02-definitions/#2-definitions","title":"2. Definitions","text":"<ul> <li>2.1. Contracts</li> <li>2.2. Interfaces</li> <li>2.3. Libraries</li> <li>2.4. Structs</li> <li>2.5. Enums</li> <li>2.6. Constants</li> <li>2.7. State Variables</li> <li>2.8. Functions</li> <li>2.9. Modifiers</li> <li>2.10. Events</li> <li>2.11. User Defined Value Types</li> <li>2.12. Errors</li> </ul>"},{"location":"solidity-specification/02-definitions/01-contracts/","title":"2.1. Contracts","text":""},{"location":"solidity-specification/02-definitions/01-contracts/#21-contracts","title":"2.1. Contracts","text":""},{"location":"solidity-specification/02-definitions/01-contracts/#syntax","title":"Syntax","text":"<pre>ContractDefinition = (* abstract_keyword: *) ABSTRACT_KEYWORD? (* Introduced in 0.6.0 *)                     (* contract_keyword: *) CONTRACT_KEYWORD                     (* name: *) IDENTIFIER                     (* inheritance: *) InheritanceSpecifier?                     (* open_brace: *) OPEN_BRACE                     (* members: *) ContractMembers                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>InheritanceSpecifier = (* is_keyword: *) IS_KEYWORD                       (* types: *) InheritanceTypes;</pre> <pre></pre> <pre>InheritanceTypes = (* item: *) InheritanceType ((* separator: *) COMMA (* item: *) InheritanceType)*;</pre> <pre></pre> <pre>InheritanceType = (* type_name: *) IdentifierPath                  (* arguments: *) ArgumentsDeclaration?;</pre> <pre></pre> <pre>ContractMembers = (* item: *) ContractMember*;</pre> <pre></pre> <pre>ContractMember = (* variant: *) UsingDirective               | (* variant: *) FunctionDefinition               | (* variant: *) ConstructorDefinition (* Introduced in 0.4.22 *)               | (* variant: *) ReceiveFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) FallbackFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) UnnamedFunctionDefinition (* Deprecated in 0.6.0 *)               | (* variant: *) ModifierDefinition               | (* variant: *) StructDefinition               | (* variant: *) EnumDefinition               | (* variant: *) EventDefinition               | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)               | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)               | (* variant: *) StateVariableDefinition;</pre>"},{"location":"solidity-specification/02-definitions/01-contracts/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/02-interfaces/","title":"2.2. Interfaces","text":""},{"location":"solidity-specification/02-definitions/02-interfaces/#22-interfaces","title":"2.2. Interfaces","text":""},{"location":"solidity-specification/02-definitions/02-interfaces/#syntax","title":"Syntax","text":"<pre>InterfaceDefinition = (* interface_keyword: *) INTERFACE_KEYWORD                      (* name: *) IDENTIFIER                      (* inheritance: *) InheritanceSpecifier?                      (* open_brace: *) OPEN_BRACE                      (* members: *) InterfaceMembers                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>InterfaceMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-specification/02-definitions/02-interfaces/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/03-libraries/","title":"2.3. Libraries","text":""},{"location":"solidity-specification/02-definitions/03-libraries/#23-libraries","title":"2.3. Libraries","text":""},{"location":"solidity-specification/02-definitions/03-libraries/#syntax","title":"Syntax","text":"<pre>LibraryDefinition = (* library_keyword: *) LIBRARY_KEYWORD                    (* name: *) IDENTIFIER                    (* open_brace: *) OPEN_BRACE                    (* members: *) LibraryMembers                    (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>LibraryMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-specification/02-definitions/03-libraries/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/04-structs/","title":"2.4. Structs","text":""},{"location":"solidity-specification/02-definitions/04-structs/#24-structs","title":"2.4. Structs","text":""},{"location":"solidity-specification/02-definitions/04-structs/#syntax","title":"Syntax","text":"<pre>StructDefinition = (* struct_keyword: *) STRUCT_KEYWORD                   (* name: *) IDENTIFIER                   (* open_brace: *) OPEN_BRACE                   (* members: *) StructMembers                   (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>StructMembers = (* item: *) StructMember*;</pre> <pre></pre> <pre>StructMember = (* type_name: *) TypeName               (* name: *) IDENTIFIER               (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-specification/02-definitions/04-structs/#struct-types","title":"Struct Types","text":"<p>Structs are custom defined types that can group several variables. They can be defined inside or outside contracts.</p> <pre><code>struct Voter {\n    address delegate;\n    uint vote;\n}\n</code></pre> <p>You can also create new objects of this struct using the following syntax:</p> <pre><code>contract MyContract {\n    function create() public  {\n        Voter memory v = Voter({\n            delegate: msg.sender,\n            vote: 1\n        });\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/05-enums/","title":"2.5. Enums","text":""},{"location":"solidity-specification/02-definitions/05-enums/#25-enums","title":"2.5. Enums","text":""},{"location":"solidity-specification/02-definitions/05-enums/#syntax","title":"Syntax","text":"<pre>EnumDefinition = (* enum_keyword: *) ENUM_KEYWORD                 (* name: *) IDENTIFIER                 (* open_brace: *) OPEN_BRACE                 (* members: *) EnumMembers                 (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>EnumMembers = ((* item: *) IDENTIFIER ((* separator: *) COMMA (* item: *) IDENTIFIER)*)?;</pre>"},{"location":"solidity-specification/02-definitions/05-enums/#enum-types","title":"Enum Types","text":"<p>Enums can be used to create custom types with a finite set of constant values. Enums can be declared on the file level, outside of contract or library definitions.</p> <pre><code>enum ActionChoices {\n    One,\n    Two\n}\n\ncontract MyContract {\n    function choose() public pure returns (ActionChoices) {\n        return ActionChoices.Two;\n    }\n}\n</code></pre> <p>Enums require at least one member, and its default value when declared is the first member. Enums cannot have more than 256 members.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/06-constants/","title":"2.6. Constants","text":""},{"location":"solidity-specification/02-definitions/06-constants/#26-constants","title":"2.6. Constants","text":""},{"location":"solidity-specification/02-definitions/06-constants/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.7.4 *)ConstantDefinition = (* type_name: *) TypeName                     (* constant_keyword: *) CONSTANT_KEYWORD                     (* name: *) IDENTIFIER                     (* equal: *) EQUAL                     (* value: *) Expression                     (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-specification/02-definitions/06-constants/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/07-state-variables/","title":"2.7. State Variables","text":""},{"location":"solidity-specification/02-definitions/07-state-variables/#27-state-variables","title":"2.7. State Variables","text":""},{"location":"solidity-specification/02-definitions/07-state-variables/#syntax","title":"Syntax","text":"<pre>StateVariableDefinition = (* type_name: *) TypeName                          (* attributes: *) StateVariableAttributes                          (* name: *) IDENTIFIER                          (* value: *) StateVariableDefinitionValue?                          (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>StateVariableDefinitionValue = (* equal: *) EQUAL                               (* value: *) Expression;</pre> <pre></pre> <pre>StateVariableAttributes = (* item: *) StateVariableAttribute*;</pre> <pre></pre> <pre>StateVariableAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                       | (* variant: *) CONSTANT_KEYWORD                       | (* variant: *) INTERNAL_KEYWORD                       | (* variant: *) PRIVATE_KEYWORD                       | (* variant: *) PUBLIC_KEYWORD                       | (* variant: *) IMMUTABLE_KEYWORD (* Introduced in 0.6.5 *)                       | (* variant: *) TRANSIENT_KEYWORD; (* Introduced in 0.8.27 *)</pre>"},{"location":"solidity-specification/02-definitions/07-state-variables/#state-variables","title":"State Variables","text":"<p>State variables are variables whose values are permanently stored in contract storage.</p> <pre><code>contract MyContract {\n    uint myStateVariable;\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/08-functions/","title":"2.8. Functions","text":""},{"location":"solidity-specification/02-definitions/08-functions/#28-functions","title":"2.8. Functions","text":""},{"location":"solidity-specification/02-definitions/08-functions/#syntax","title":"Syntax","text":"<pre>FunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                     (* name: *) FunctionName                     (* parameters: *) ParametersDeclaration                     (* attributes: *) FunctionAttributes                     (* returns: *) ReturnsDeclaration?                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>FunctionName = (* variant: *) IDENTIFIER             | (* variant: *) FALLBACK_KEYWORD             | (* variant: *) RECEIVE_KEYWORD;</pre> <pre></pre> <pre>ParametersDeclaration = (* open_paren: *) OPEN_PAREN                        (* parameters: *) Parameters                        (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>Parameters = ((* item: *) Parameter ((* separator: *) COMMA (* item: *) Parameter)*)?;</pre> <pre></pre> <pre>Parameter = (* type_name: *) TypeName            (* storage_location: *) StorageLocation?            (* name: *) IDENTIFIER?;</pre> <pre></pre> <pre>FunctionAttributes = (* item: *) FunctionAttribute*;</pre> <pre></pre> <pre>FunctionAttribute = (* variant: *) ModifierInvocation                  | (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                  | (* variant: *) EXTERNAL_KEYWORD                  | (* variant: *) INTERNAL_KEYWORD                  | (* variant: *) PAYABLE_KEYWORD                  | (* variant: *) PRIVATE_KEYWORD                  | (* variant: *) PUBLIC_KEYWORD                  | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverrideSpecifier = (* override_keyword: *) OVERRIDE_KEYWORD                    (* overridden: *) OverridePathsDeclaration?;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePathsDeclaration = (* open_paren: *) OPEN_PAREN                           (* paths: *) OverridePaths                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePaths = (* item: *) IdentifierPath ((* separator: *) COMMA (* item: *) IdentifierPath)*;</pre> <pre></pre> <pre>ReturnsDeclaration = (* returns_keyword: *) RETURNS_KEYWORD                     (* variables: *) ParametersDeclaration;</pre> <pre></pre> <pre>FunctionBody = (* variant: *) Block             | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorDefinition = (* constructor_keyword: *) CONSTRUCTOR_KEYWORD                        (* parameters: *) ParametersDeclaration                        (* attributes: *) ConstructorAttributes                        (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttributes = (* item: *) ConstructorAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttribute = (* variant: *) ModifierInvocation                     | (* variant: *) INTERNAL_KEYWORD                     | (* variant: *) OVERRIDE_KEYWORD (* Introduced in 0.6.0 and deprecated in 0.6.7. *)                     | (* variant: *) PAYABLE_KEYWORD                     | (* variant: *) PUBLIC_KEYWORD                     | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 and deprecated in 0.6.7. *)</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) UnnamedFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttributes = (* item: *) UnnamedFunctionAttribute*;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) INTERNAL_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) PRIVATE_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PUBLIC_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 and deprecated in 0.6.0. *)                         | (* variant: *) VIEW_KEYWORD; (* Introduced in 0.4.16 and deprecated in 0.6.0. *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionDefinition = (* fallback_keyword: *) FALLBACK_KEYWORD                             (* parameters: *) ParametersDeclaration                             (* attributes: *) FallbackFunctionAttributes                             (* returns: *) ReturnsDeclaration?                             (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttributes = (* item: *) FallbackFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttribute = (* variant: *) ModifierInvocation                          | (* variant: *) OverrideSpecifier                          | (* variant: *) EXTERNAL_KEYWORD                          | (* variant: *) PAYABLE_KEYWORD                          | (* variant: *) PURE_KEYWORD                          | (* variant: *) VIEW_KEYWORD                          | (* variant: *) VIRTUAL_KEYWORD;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionDefinition = (* receive_keyword: *) RECEIVE_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) ReceiveFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttributes = (* item: *) ReceiveFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) OverrideSpecifier                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) VIRTUAL_KEYWORD;</pre>"},{"location":"solidity-specification/02-definitions/08-functions/#function-definitions","title":"Function Definitions","text":"<p>Functions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts.</p> <pre><code>contract MyContract {\n    function contractFunction() public {\n        // Inside the contract\n    }\n}\n\nfunction helperFunction() {\n    // Outside the contract\n}\n</code></pre> <p>Functions can be overloaded, where multiple functions with the same name, but with different parameters, can co-exist.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/09-modifiers/","title":"2.9. Modifiers","text":""},{"location":"solidity-specification/02-definitions/09-modifiers/#29-modifiers","title":"2.9. Modifiers","text":""},{"location":"solidity-specification/02-definitions/09-modifiers/#syntax","title":"Syntax","text":"<pre>ModifierDefinition = (* modifier_keyword: *) MODIFIER_KEYWORD                     (* name: *) IDENTIFIER                     (* parameters: *) ParametersDeclaration?                     (* attributes: *) ModifierAttributes                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>ModifierAttributes = (* item: *) ModifierAttribute*;</pre> <pre></pre> <pre>ModifierAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>ModifierInvocation = (* name: *) IdentifierPath                     (* arguments: *) ArgumentsDeclaration?;</pre>"},{"location":"solidity-specification/02-definitions/09-modifiers/#function-modifiers","title":"Function Modifiers","text":"<p>Function modifiers can be used to amend the semantics of functions in a declarative way:</p> <pre><code>contract MyContract {\n    modifier onlySeller() {\n        require(msg.sender == seller, \"Only seller can call this.\");\n        _; // Function body will be inserted here\n    }\n\n    function myFunction() public view onlySeller {\n        // Code here will be executed after `onlySeller` is executed.\n    }\n}\n</code></pre> <p>Unlike functions, modifiers cannot be overloaded.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/10-events/","title":"2.10. Events","text":""},{"location":"solidity-specification/02-definitions/10-events/#210-events","title":"2.10. Events","text":""},{"location":"solidity-specification/02-definitions/10-events/#syntax","title":"Syntax","text":"<pre>EventDefinition = (* event_keyword: *) EVENT_KEYWORD                  (* name: *) IDENTIFIER                  (* parameters: *) EventParametersDeclaration                  (* anonymous_keyword: *) ANONYMOUS_KEYWORD?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>EventParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) EventParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>EventParameters = ((* item: *) EventParameter ((* separator: *) COMMA (* item: *) EventParameter)*)?;</pre> <pre></pre> <pre>EventParameter = (* type_name: *) TypeName                 (* indexed_keyword: *) INDEXED_KEYWORD?                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-specification/02-definitions/10-events/#event-definitions","title":"Event Definitions","text":"<p>Events are convenient interfaces with the EVM logging facilities. They have to be defined inside a contract:</p> <pre><code>contract MyContract {\n    // Defining an event\n    event BidPlacedEvent(address bidder, uint amount);\n\n    function bid() public payable {\n        // Triggering an event\n        emit BidPlacedEvent(msg.sender, msg.value);\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/11-user-defined-value-types/","title":"2.11. User Defined Value Types","text":""},{"location":"solidity-specification/02-definitions/11-user-defined-value-types/#211-user-defined-value-types","title":"2.11. User Defined Value Types","text":""},{"location":"solidity-specification/02-definitions/11-user-defined-value-types/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.8.8 *)UserDefinedValueTypeDefinition = (* type_keyword: *) TYPE_KEYWORD                                 (* name: *) IDENTIFIER                                 (* is_keyword: *) IS_KEYWORD                                 (* value_type: *) ElementaryType                                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-specification/02-definitions/11-user-defined-value-types/#user-defined-value-types","title":"User Defined Value Types","text":"<p>A user defined value type allows creating a zero cost abstraction over an elementary value type. This is similar to a type alias. A user defined value type is defined using <code>type C is V</code>, where <code>C</code> is the name of the newly introduced type and <code>V</code> has to be a built-in value type (the underlying type).</p> <pre><code>type MyInteger is uint256;\n\nlibrary MyLibrary {\n    function add(MyInteger a, MyInteger b) internal pure returns (MyInteger) {\n        return MyInteger.wrap(MyInteger.unwrap(a) + MyInteger.unwrap(b));\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/02-definitions/12-errors/","title":"2.12. Errors","text":""},{"location":"solidity-specification/02-definitions/12-errors/#212-errors","title":"2.12. Errors","text":""},{"location":"solidity-specification/02-definitions/12-errors/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.8.4 *)ErrorDefinition = (* error_keyword: *) ERROR_KEYWORD                  (* name: *) IDENTIFIER                  (* members: *) ErrorParametersDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) ErrorParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameters = ((* item: *) ErrorParameter ((* separator: *) COMMA (* item: *) ErrorParameter)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameter = (* type_name: *) TypeName                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-specification/02-definitions/12-errors/#error-definitions","title":"Error Definitions","text":"<p>Errors allow you to define descriptive names and data for failure situations. Errors can be used in revert statements. In comparison to string descriptions, errors are much cheaper and allow you to encode additional data. You can use NatSpec to describe the error to the user. They can also be defined inside or outside contracts:</p> <pre><code>contract Token {\n    error NotEnoughFunds(uint requested, uint available);\n\n    function transfer(address to, uint amount) public {\n        uint balance = balances[msg.sender];\n        if (balance &lt; amount)\n            revert NotEnoughFunds(amount, balance);\n\n        // Continue with the transfer...\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/03-types/","title":"3. Types","text":""},{"location":"solidity-specification/03-types/#3-types","title":"3. Types","text":"<ul> <li>3.1. Advanced Types</li> <li>3.2. Elementary Types</li> </ul>"},{"location":"solidity-specification/03-types/01-advanced-types/","title":"3.1. Advanced Types","text":""},{"location":"solidity-specification/03-types/01-advanced-types/#31-advanced-types","title":"3.1. Advanced Types","text":""},{"location":"solidity-specification/03-types/01-advanced-types/#syntax","title":"Syntax","text":"<pre>TypeName = (* variant: *) ArrayTypeName         | (* variant: *) FunctionType         | (* variant: *) MappingType         | (* variant: *) ElementaryType         | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)ArrayTypeName = (* operand: *) TypeName                (* open_bracket: *) OPEN_BRACKET                (* index: *) Expression?                (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>FunctionType = (* function_keyword: *) FUNCTION_KEYWORD               (* parameters: *) ParametersDeclaration               (* attributes: *) FunctionTypeAttributes               (* returns: *) ReturnsDeclaration?;</pre> <pre></pre> <pre>FunctionTypeAttributes = (* item: *) FunctionTypeAttribute*;</pre> <pre></pre> <pre>FunctionTypeAttribute = (* variant: *) INTERNAL_KEYWORD                      | (* variant: *) EXTERNAL_KEYWORD                      | (* variant: *) PRIVATE_KEYWORD                      | (* variant: *) PUBLIC_KEYWORD                      | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                      | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) PAYABLE_KEYWORD;</pre> <pre></pre> <pre>MappingType = (* mapping_keyword: *) MAPPING_KEYWORD              (* open_paren: *) OPEN_PAREN              (* key_type: *) MappingKey              (* equal_greater_than: *) EQUAL_GREATER_THAN              (* value_type: *) MappingValue              (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>MappingKey = (* key_type: *) MappingKeyType             (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre> <pre></pre> <pre>MappingKeyType = (* variant: *) ElementaryType               | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>MappingValue = (* type_name: *) TypeName               (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre>"},{"location":"solidity-specification/03-types/01-advanced-types/#function-types","title":"Function Types","text":"<p>Function types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. They come in two flavors, <code>internal</code> and <code>external</code>.</p> <p>Function types are notated as follows:</p> <pre><code>function (&lt;parameter types&gt;) {internal|external} [pure|view|payable] [returns (&lt;return types&gt;)]\n</code></pre> <p>In contrast to the parameter types, the return types cannot be empty. If the function type should not return anything, the whole <code>returns (&lt;return types&gt;)</code> part has to be omitted.</p> <p>By default, function types are internal, so the <code>internal</code> keyword can be omitted. Note that this only applies to function types. Visibility has to be specified explicitly for functions defined in contracts, they do not have a default.</p> <pre><code>contract Oracle {\n    Request[] private requests;\n\n    function query(bytes memory data, function(uint) external callback) public {\n        requests.push(Request(data, callback));\n    }\n\n    function reply(uint requestID, uint response) public {\n        requests[requestID].callback(response);\n    }\n}\n</code></pre>"},{"location":"solidity-specification/03-types/01-advanced-types/#mapping-types","title":"Mapping Types","text":"<p>Mapping types use the syntax <code>mapping(_KeyType =&gt; _ValueType)</code> and variables of mapping type are declared using the syntax <code>mapping(_KeyType =&gt; _ValueType) _VariableName</code>.</p> <pre><code>contract MappingExample {\n    mapping(address =&gt; uint) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/03-types/02-elementary-types/","title":"3.2. Elementary Types","text":""},{"location":"solidity-specification/03-types/02-elementary-types/#32-elementary-types","title":"3.2. Elementary Types","text":""},{"location":"solidity-specification/03-types/02-elementary-types/#syntax","title":"Syntax","text":"<pre>ElementaryType = (* variant: *) BOOL_KEYWORD               | (* variant: *) BYTE_KEYWORD (* Deprecated in 0.8.0 *)               | (* variant: *) STRING_KEYWORD               | (* variant: *) AddressType               | (* variant: *) BYTES_KEYWORD               | (* variant: *) INT_KEYWORD               | (* variant: *) UINT_KEYWORD               | (* variant: *) FIXED_KEYWORD               | (* variant: *) UFIXED_KEYWORD;</pre> <pre></pre> <pre>AddressType = (* address_keyword: *) ADDRESS_KEYWORD              (* payable_keyword: *) PAYABLE_KEYWORD?;</pre>"},{"location":"solidity-specification/03-types/02-elementary-types/#address-types","title":"Address Types","text":"<p>The address type comes in two flavours, which are largely identical:</p> <ul> <li><code>address</code>: Holds a 20 byte value (size of an Ethereum address).</li> <li><code>address payable</code>: Same as <code>address</code>, but with the additional members <code>transfer</code> and <code>send</code>.</li> </ul> <p>Hexadecimal literals that pass the address checksum test, for example <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> are of <code>address</code> type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. You can prepend (for <code>int</code> types) or append (for <code>bytesNN</code> types) zeros to remove the error.</p>"},{"location":"solidity-specification/03-types/02-elementary-types/#fixed-size-byte-arrays","title":"Fixed-Size Byte Arrays","text":"<p>The value types <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, \u2026, <code>bytes32</code> hold a sequence of bytes from one to up to 32.</p>"},{"location":"solidity-specification/03-types/02-elementary-types/#dynamic-string-and-byte-arrays","title":"Dynamic String and Byte Arrays","text":"<p>The <code>bytes</code> type is similar to <code>bytes1[]</code>, but it is packed tightly in calldata and memory.</p> <p>Variables of type <code>string</code> are equal to <code>bytes</code> but do not allow length or index access. If you want to access the byte-representation of a string <code>s</code>, use <code>bytes(s)</code>. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters.</p> <p>Memory arrays with dynamic length can be created using the <code>new</code> keyword:</p> <pre><code>contract MyContract {\n    function myFunction(uint length) public pure {\n        bytes memory b = new bytes(length);\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/04-statements/","title":"4. Statements","text":""},{"location":"solidity-specification/04-statements/#4-statements","title":"4. Statements","text":"<ul> <li>4.1. Blocks</li> <li>4.2. Declaration Statements</li> <li>4.3. Control Statements</li> <li>4.4. Error Handling</li> </ul>"},{"location":"solidity-specification/04-statements/01-blocks/","title":"4.1. Blocks","text":""},{"location":"solidity-specification/04-statements/01-blocks/#41-blocks","title":"4.1. Blocks","text":""},{"location":"solidity-specification/04-statements/01-blocks/#syntax","title":"Syntax","text":"<pre>Block = (* open_brace: *) OPEN_BRACE        (* statements: *) Statements        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>Statements = (* item: *) Statement*;</pre> <pre></pre> <pre>Statement = (* variant: *) IfStatement          | (* variant: *) ForStatement          | (* variant: *) WhileStatement          | (* variant: *) DoWhileStatement          | (* variant: *) ContinueStatement          | (* variant: *) BreakStatement          | (* variant: *) ReturnStatement          | (* variant: *) ThrowStatement (* Deprecated in 0.5.0 *)          | (* variant: *) EmitStatement (* Introduced in 0.4.21 *)          | (* variant: *) TryStatement (* Introduced in 0.6.0 *)          | (* variant: *) RevertStatement (* Introduced in 0.8.4 *)          | (* variant: *) AssemblyStatement          | (* variant: *) Block          | (* variant: *) UncheckedBlock (* Introduced in 0.8.0 *)          | (* variant: *) TupleDeconstructionStatement          | (* variant: *) VariableDeclarationStatement          | (* variant: *) ExpressionStatement;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)UncheckedBlock = (* unchecked_keyword: *) UNCHECKED_KEYWORD                 (* block: *) Block;</pre> <pre></pre> <pre>ExpressionStatement = (* expression: *) Expression                      (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>AssemblyStatement = (* assembly_keyword: *) ASSEMBLY_KEYWORD                    (* label: *) StringLiteral?                    (* flags: *) AssemblyFlagsDeclaration?                    (* body: *) YulBlock;</pre> <pre></pre> <pre>AssemblyFlagsDeclaration = (* open_paren: *) OPEN_PAREN                           (* flags: *) AssemblyFlags                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>AssemblyFlags = (* item: *) StringLiteral ((* separator: *) COMMA (* item: *) StringLiteral)*;</pre>"},{"location":"solidity-specification/04-statements/01-blocks/#unchecked-blocks","title":"Unchecked Blocks","text":"<p>Starting with <code>v0.8.0</code>, by default, all arithmetic operations are checked for underflow or overflow, which means that if the result of an operation falls outside the value range of the type, the call is reverted through a failing assertion. This can be disabled using the <code>unchecked</code> block, resulting in wrapping arithmetic:</p> <pre><code>unchecked {\n  i++;\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/04-statements/02-declaration-statements/","title":"4.2. Declaration Statements","text":""},{"location":"solidity-specification/04-statements/02-declaration-statements/#42-declaration-statements","title":"4.2. Declaration Statements","text":""},{"location":"solidity-specification/04-statements/02-declaration-statements/#syntax","title":"Syntax","text":"<pre>TupleDeconstructionStatement = (* var_keyword: *) VAR_KEYWORD? (* Deprecated in 0.5.0 *)                               (* open_paren: *) OPEN_PAREN                               (* elements: *) TupleDeconstructionElements                               (* close_paren: *) CLOSE_PAREN                               (* equal: *) EQUAL                               (* expression: *) Expression                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>TupleDeconstructionElements = (* item: *) TupleDeconstructionElement ((* separator: *) COMMA (* item: *) TupleDeconstructionElement)*;</pre> <pre></pre> <pre>TupleDeconstructionElement = (* member: *) TupleMember?;</pre> <pre></pre> <pre>TupleMember = (* variant: *) TypedTupleMember            | (* variant: *) UntypedTupleMember;</pre> <pre></pre> <pre>TypedTupleMember = (* type_name: *) TypeName                   (* storage_location: *) StorageLocation?                   (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>UntypedTupleMember = (* storage_location: *) StorageLocation?                     (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>VariableDeclarationStatement = (* variable_type: *) VariableDeclarationType                               (* storage_location: *) StorageLocation?                               (* name: *) IDENTIFIER                               (* value: *) VariableDeclarationValue?                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>VariableDeclarationType = (* variant: *) TypeName                        | (* variant: *) VAR_KEYWORD; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>VariableDeclarationValue = (* equal: *) EQUAL                           (* expression: *) Expression;</pre> <pre></pre> <pre>StorageLocation = (* variant: *) MEMORY_KEYWORD                | (* variant: *) STORAGE_KEYWORD                | (* variant: *) CALL_DATA_KEYWORD; (* Introduced in 0.5.0 *)</pre>"},{"location":"solidity-specification/04-statements/02-declaration-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/04-statements/03-control-statements/","title":"4.3. Control Statements","text":""},{"location":"solidity-specification/04-statements/03-control-statements/#43-control-statements","title":"4.3. Control Statements","text":""},{"location":"solidity-specification/04-statements/03-control-statements/#syntax","title":"Syntax","text":"<pre>IfStatement = (* if_keyword: *) IF_KEYWORD              (* open_paren: *) OPEN_PAREN              (* condition: *) Expression              (* close_paren: *) CLOSE_PAREN              (* body: *) Statement              (* else_branch: *) ElseBranch?;</pre> <pre></pre> <pre>ElseBranch = (* else_keyword: *) ELSE_KEYWORD             (* body: *) Statement;</pre> <pre></pre> <pre>ForStatement = (* for_keyword: *) FOR_KEYWORD               (* open_paren: *) OPEN_PAREN               (* initialization: *) ForStatementInitialization               (* condition: *) ForStatementCondition               (* iterator: *) Expression?               (* close_paren: *) CLOSE_PAREN               (* body: *) Statement;</pre> <pre></pre> <pre>ForStatementInitialization = (* variant: *) TupleDeconstructionStatement                           | (* variant: *) VariableDeclarationStatement                           | (* variant: *) ExpressionStatement                           | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>ForStatementCondition = (* variant: *) ExpressionStatement                      | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>WhileStatement = (* while_keyword: *) WHILE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* condition: *) Expression                 (* close_paren: *) CLOSE_PAREN                 (* body: *) Statement;</pre> <pre></pre> <pre>DoWhileStatement = (* do_keyword: *) DO_KEYWORD                   (* body: *) Statement                   (* while_keyword: *) WHILE_KEYWORD                   (* open_paren: *) OPEN_PAREN                   (* condition: *) Expression                   (* close_paren: *) CLOSE_PAREN                   (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ContinueStatement = (* continue_keyword: *) CONTINUE_KEYWORD                    (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>BreakStatement = (* break_keyword: *) BREAK_KEYWORD                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ReturnStatement = (* return_keyword: *) RETURN_KEYWORD                  (* expression: *) Expression?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)EmitStatement = (* emit_keyword: *) EMIT_KEYWORD                (* event: *) IdentifierPath                (* arguments: *) ArgumentsDeclaration                (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-specification/04-statements/03-control-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/04-statements/04-error-handling/","title":"4.4. Error Handling","text":""},{"location":"solidity-specification/04-statements/04-error-handling/#44-error-handling","title":"4.4. Error Handling","text":""},{"location":"solidity-specification/04-statements/04-error-handling/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.6.0 *)TryStatement = (* try_keyword: *) TRY_KEYWORD               (* expression: *) Expression               (* returns: *) ReturnsDeclaration?               (* body: *) Block               (* catch_clauses: *) CatchClauses;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauses = (* item: *) CatchClause+;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClause = (* catch_keyword: *) CATCH_KEYWORD              (* error: *) CatchClauseError?              (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauseError = (* name: *) IDENTIFIER?                   (* parameters: *) ParametersDeclaration;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)RevertStatement = (* revert_keyword: *) REVERT_KEYWORD                  (* error: *) IdentifierPath?                  (* arguments: *) ArgumentsDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)ThrowStatement = (* throw_keyword: *) THROW_KEYWORD                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-specification/04-statements/04-error-handling/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/","title":"5. Expressions","text":""},{"location":"solidity-specification/05-expressions/#5-expressions","title":"5. Expressions","text":"<ul> <li>5.1. Base Expressions</li> <li>5.2. Function Calls</li> <li>5.3. Primary Expressions</li> <li>5.4. Numbers</li> <li>5.5. Strings</li> <li>5.6. Identifiers</li> </ul>"},{"location":"solidity-specification/05-expressions/01-base-expressions/","title":"5.1. Base Expressions","text":""},{"location":"solidity-specification/05-expressions/01-base-expressions/#51-base-expressions","title":"5.1. Base Expressions","text":""},{"location":"solidity-specification/05-expressions/01-base-expressions/#syntax","title":"Syntax","text":"<pre>Expression = (* variant: *) AssignmentExpression           | (* variant: *) ConditionalExpression           | (* variant: *) OrExpression           | (* variant: *) AndExpression           | (* variant: *) EqualityExpression           | (* variant: *) ComparisonExpression           | (* variant: *) BitwiseOrExpression           | (* variant: *) BitwiseXorExpression           | (* variant: *) BitwiseAndExpression           | (* variant: *) ShiftExpression           | (* variant: *) AdditiveExpression           | (* variant: *) MultiplicativeExpression           | (* variant: *) ExponentiationExpression           | (* variant: *) PostfixExpression           | (* variant: *) PrefixExpression           | (* variant: *) FunctionCallExpression           | (* variant: *) CallOptionsExpression           | (* variant: *) MemberAccessExpression           | (* variant: *) IndexAccessExpression           | (* variant: *) NewExpression           | (* variant: *) TupleExpression           | (* variant: *) TypeExpression (* Introduced in 0.5.3 *)           | (* variant: *) ArrayExpression           | (* variant: *) HexNumberExpression           | (* variant: *) DecimalNumberExpression           | (* variant: *) StringExpression           | (* variant: *) ElementaryType           | (* variant: *) PAYABLE_KEYWORD (* Introduced in 0.6.0 *)           | (* variant: *) TRUE_KEYWORD           | (* variant: *) FALSE_KEYWORD           | (* variant: *) IDENTIFIER;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) BAR_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PLUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) MINUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) CARET_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) SLASH_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PERCENT_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) ASTERISK_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)ConditionalExpression = (* operand: *) Expression                        (* question_mark: *) QUESTION_MARK                        (* true_expression: *) Expression                        (* colon: *) COLON                        (* false_expression: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)OrExpression = (* left_operand: *) Expression               (* operator: *) BAR_BAR               (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AndExpression = (* left_operand: *) Expression                (* operator: *) AMPERSAND_AMPERSAND                (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) EQUAL_EQUAL                     (* right_operand: *) Expression;(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) BANG_EQUAL                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)ComparisonExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)ComparisonExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)ComparisonExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)ComparisonExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseOrExpression = (* left_operand: *) Expression                      (* operator: *) BAR                      (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseXorExpression = (* left_operand: *) Expression                       (* operator: *) CARET                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseAndExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) LESS_THAN_LESS_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) PLUS                     (* right_operand: *) Expression;(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) MINUS                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) SLASH                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) PERCENT                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)(* Deprecated in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;(* Right-associative binary operator *)(* Introduced in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) PLUS_PLUS;(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) MINUS_MINUS;</pre> <pre></pre> <pre>(* Prefix unary operator *)PrefixExpression = (* operator: *) PLUS_PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS_MINUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) TILDE                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) BANG                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS                   (* operand: *) Expression;(* Prefix unary operator *)(* Deprecated in 0.5.0 *)PrefixExpression = (* operator: *) PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) DELETE_KEYWORD                   (* operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)FunctionCallExpression = (* operand: *) Expression                         (* arguments: *) ArgumentsDeclaration;</pre> <pre></pre> <pre>(* Postfix unary operator *)(* Introduced in 0.6.2 *)CallOptionsExpression = (* operand: *) Expression                        (* open_brace: *) OPEN_BRACE                        (* options: *) CallOptions                        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Postfix unary operator *)MemberAccessExpression = (* operand: *) Expression                         (* period: *) PERIOD                         (* member: *) IDENTIFIER;(* Postfix unary operator *)MemberAccessExpression = (* operand: *) Expression                         (* period: *) PERIOD                         (* member: *) ADDRESS_KEYWORD;</pre> <pre></pre> <pre>(* Postfix unary operator *)IndexAccessExpression = (* operand: *) Expression                        (* open_bracket: *) OPEN_BRACKET                        (* start: *) Expression?                        (* end: *) IndexAccessEnd?                        (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>IndexAccessEnd = (* colon: *) COLON                 (* end: *) Expression?;</pre>"},{"location":"solidity-specification/05-expressions/01-base-expressions/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/02-function-calls/","title":"5.2. Function Calls","text":""},{"location":"solidity-specification/05-expressions/02-function-calls/#52-function-calls","title":"5.2. Function Calls","text":""},{"location":"solidity-specification/05-expressions/02-function-calls/#syntax","title":"Syntax","text":"<pre>ArgumentsDeclaration = (* variant: *) PositionalArgumentsDeclaration                     | (* variant: *) NamedArgumentsDeclaration;</pre> <pre></pre> <pre>PositionalArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                                 (* arguments: *) PositionalArguments                                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>PositionalArguments = ((* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*)?;</pre> <pre></pre> <pre>NamedArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                            (* arguments: *) NamedArgumentGroup?                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NamedArgumentGroup = (* open_brace: *) OPEN_BRACE                     (* arguments: *) NamedArguments                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>NamedArguments = ((* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)CallOptions = (* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*;</pre> <pre></pre> <pre>NamedArgument = (* name: *) IDENTIFIER                (* colon: *) COLON                (* value: *) Expression;</pre>"},{"location":"solidity-specification/05-expressions/02-function-calls/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/03-primary-expressions/","title":"5.3. Primary Expressions","text":""},{"location":"solidity-specification/05-expressions/03-primary-expressions/#53-primary-expressions","title":"5.3. Primary Expressions","text":""},{"location":"solidity-specification/05-expressions/03-primary-expressions/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.5.3 *)TypeExpression = (* type_keyword: *) TYPE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* type_name: *) TypeName                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NewExpression = (* new_keyword: *) NEW_KEYWORD                (* type_name: *) TypeName;</pre> <pre></pre> <pre>TupleExpression = (* open_paren: *) OPEN_PAREN                  (* items: *) TupleValues                  (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>TupleValues = (* item: *) TupleValue ((* separator: *) COMMA (* item: *) TupleValue)*;</pre> <pre></pre> <pre>TupleValue = (* expression: *) Expression?;</pre> <pre></pre> <pre>ArrayExpression = (* open_bracket: *) OPEN_BRACKET                  (* items: *) ArrayValues                  (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>ArrayValues = (* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*;</pre>"},{"location":"solidity-specification/05-expressions/03-primary-expressions/#array-literals","title":"Array Literals","text":"<p>An array literal is a comma-separated list of one or more expressions, enclosed in square brackets (<code>[...]</code>). For example <code>[1, a, f(3)]</code>. It is always a statically-sized memory array whose length is the number of expressions.</p> <pre><code>contract MyContract {\n    function someFunction() public pure {\n        otherFunction([uint(1), 2, 3]);\n    }\n}\n</code></pre>"},{"location":"solidity-specification/05-expressions/03-primary-expressions/#array-slices","title":"Array Slices","text":"<p>Array slices are a view on a contiguous portion of an array. They are written as <code>x[start:end]</code>, where <code>start</code> and <code>end</code> are expressions resulting in a uint256 type (or implicitly convertible to it). The first element of the slice is <code>x[start]</code> and the last element is <code>x[end - 1]</code>.</p> <p>Both <code>start</code> and <code>end</code> are optional: <code>start</code> defaults to <code>0</code> and <code>end</code> defaults to the length of the array.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/","title":"5.4. Numbers","text":""},{"location":"solidity-specification/05-expressions/04-numbers/#54-numbers","title":"5.4. Numbers","text":""},{"location":"solidity-specification/05-expressions/04-numbers/#syntax","title":"Syntax","text":"<pre>HexNumberExpression = (* literal: *) HEX_LITERAL                      (* unit: *) NumberUnit?; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>DecimalNumberExpression = (* literal: *) DECIMAL_LITERAL                          (* unit: *) NumberUnit?;</pre> <pre></pre> <pre>HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)*;(* Deprecated in 0.5.0 *)HEX_LITERAL = \"0X\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)*;</pre> <pre></pre> <pre>DECIMAL_LITERAL = \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb?;DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb?;(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" \u00abDECIMAL_EXPONENT\u00bb?;(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb?;(* Introduced in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb (\".\" \u00abDECIMAL_DIGITS\u00bb)? \u00abDECIMAL_EXPONENT\u00bb?;</pre> <pre></pre> <pre>\u00abDECIMAL_DIGITS\u00bb = (\"0\"\u2026\"9\")+ (\"_\" (\"0\"\u2026\"9\")+)*;</pre> <pre></pre> <pre>\u00abDECIMAL_EXPONENT\u00bb = (\"e\" | \"E\") \"-\"? \u00abDECIMAL_DIGITS\u00bb;</pre> <pre></pre> <pre>NumberUnit = (* variant: *) WEI_KEYWORD           | (* variant: *) GWEI_KEYWORD (* Introduced in 0.6.11 *)           | (* variant: *) SZABO_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) FINNEY_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) ETHER_KEYWORD           | (* variant: *) SECONDS_KEYWORD           | (* variant: *) MINUTES_KEYWORD           | (* variant: *) HOURS_KEYWORD           | (* variant: *) DAYS_KEYWORD           | (* variant: *) WEEKS_KEYWORD           | (* variant: *) YEARS_KEYWORD; (* Deprecated in 0.5.0 *)</pre>"},{"location":"solidity-specification/05-expressions/04-numbers/#integers","title":"Integers","text":"<p>Signed (<code>int8</code>..<code>int256</code>) and unsigned (<code>uint8</code>..<code>uint256</code>) integers of various sizes, from 8 to 256 bits, moving up in steps of 8 bits. <code>uint</code> and <code>int</code> are aliases for <code>uint256</code> and <code>int256</code>, respectively.</p> <p>Integers in Solidity are restricted to a certain range. For example, with <code>uint32</code>, this is <code>0</code> up to <code>2**32 - 1</code>.</p> <p>Integer literals are formed from a sequence of digits in the range <code>0-9</code>. They are interpreted as decimals. For example, <code>69</code> means sixty nine.</p> <p>Octal literals do not exist in Solidity and leading zeros are invalid.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/#decimals","title":"Decimals","text":"<p>Decimal fractional literals are formed by a <code>.</code> with at least one number on one side. Examples include <code>1.</code>, <code>.1</code> and <code>1.3</code>.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/#fixed-point-numbers","title":"Fixed Point Numbers","text":"<p>Signed <code>fixed</code> and unsigned fixed <code>ufixed</code> point number of various sizes. Keywords <code>ufixedMxN</code> and <code>fixedMxN</code>, where <code>M</code> represents the number of bits taken by the type and <code>N</code> represents how many decimal points are available. <code>M</code> must be divisible by 8 and goes from 8 to 256 bits. <code>N</code> must be between 0 and 80, inclusive. <code>ufixed</code> and <code>fixed</code> are aliases for <code>ufixed128x18</code> and <code>fixed128x18</code>, respectively.</p> <p>Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/#scientific-notation","title":"Scientific Notation","text":"<p>Scientific notation in the form of <code>2e10</code> is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal <code>MeE</code> is equivalent to <code>M * 10**E</code>. Examples include <code>2e10</code>, <code>-2e10</code>, <code>2e-10</code>, <code>2.5e1</code>.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/#using-underscores","title":"Using Underscores","text":"<p>Underscores can be used to separate the digits of a numeric literal to aid readability. For example, decimal <code>123_000</code>, hexadecimal <code>0x2eff_abcde</code>, scientific decimal notation <code>1_2e345_678</code> are all valid. Underscores are only allowed between two digits and only one consecutive underscore is allowed. There is no additional semantic meaning added to a number literal containing underscores, the underscores are ignored.</p>"},{"location":"solidity-specification/05-expressions/04-numbers/#ether-units","title":"Ether Units","text":"<p>A literal number can take a suffix of <code>wei</code>, <code>gwei</code> or <code>ether</code> to specify a sub-denomination of Ether, where Ether numbers without a postfix are assumed to be Wei.</p> <pre><code>assert(1 wei == 1);\nassert(1 gwei == 1e9);\nassert(1 szabo == 1e12);\nassert(1 finney == 1e15);\nassert(1 ether == 1e18);\n</code></pre>"},{"location":"solidity-specification/05-expressions/04-numbers/#time-units","title":"Time Units","text":"<p>Suffixes that can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:</p> <pre><code>assert(1 == 1 seconds);\nassert(1 minutes == 60 seconds);\nassert(1 hours == 60 minutes);\nassert(1 days == 24 hours);\nassert(1 weeks == 7 days);\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/05-strings/","title":"5.5. Strings","text":""},{"location":"solidity-specification/05-expressions/05-strings/#55-strings","title":"5.5. Strings","text":""},{"location":"solidity-specification/05-expressions/05-strings/#syntax","title":"Syntax","text":"<pre>StringExpression = (* variant: *) StringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) StringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) HexStringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) HexStringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) UnicodeStringLiterals; (* Introduced in 0.7.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)StringLiterals = (* item: *) StringLiteral+;</pre> <pre></pre> <pre>StringLiteral = (* variant: *) SINGLE_QUOTED_STRING_LITERAL              | (* variant: *) DOUBLE_QUOTED_STRING_LITERAL;</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !(\"'\" \"\\\\\" \"\\r\" \"\\n\"))* \"'\";(* Introduced in 0.4.25 and deprecated in 0.7.0. *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" \"\\\\\" \"\\r\" \"\\n\"))* \"'\";SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | (\" \"\u2026\"&amp;\") | (\"(\"\u2026\"[\") | (\"]\"\u2026\"~\"))* \"'\";</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !('\"' \"\\\\\" \"\\r\" \"\\n\"))* '\"';(* Introduced in 0.4.25 and deprecated in 0.7.0. *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' \"\\\\\" \"\\r\" \"\\n\"))* '\"';DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | (\" \"\u2026\"!\") | (\"#\"\u2026\"[\") | (\"]\"\u2026\"~\"))* '\"';</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)HexStringLiterals = (* item: *) HexStringLiteral+;</pre> <pre></pre> <pre>HexStringLiteral = (* variant: *) SINGLE_QUOTED_HEX_STRING_LITERAL                 | (* variant: *) DOUBLE_QUOTED_HEX_STRING_LITERAL;</pre> <pre></pre> <pre>SINGLE_QUOTED_HEX_STRING_LITERAL = \"hex'\" \u00abHEX_STRING_CONTENTS\u00bb? \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_HEX_STRING_LITERAL = 'hex\"' \u00abHEX_STRING_CONTENTS\u00bb? '\"';</pre> <pre></pre> <pre>\u00abHEX_STRING_CONTENTS\u00bb = \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb (\"_\"? \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb)*;</pre> <pre></pre> <pre>\u00abHEX_CHARACTER\u00bb = (\"0\"\u2026\"9\") | (\"a\"\u2026\"f\") | (\"A\"\u2026\"F\");</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiterals = (* item: *) UnicodeStringLiteral+;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiteral = (* variant: *) SINGLE_QUOTED_UNICODE_STRING_LITERAL                     | (* variant: *) DOUBLE_QUOTED_UNICODE_STRING_LITERAL;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)SINGLE_QUOTED_UNICODE_STRING_LITERAL = \"unicode'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" \"\\\\\" \"\\r\" \"\\n\"))* \"'\";</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)DOUBLE_QUOTED_UNICODE_STRING_LITERAL = 'unicode\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' \"\\\\\" \"\\r\" \"\\n\"))* '\"';</pre> <pre></pre> <pre>\u00abESCAPE_SEQUENCE\u00bb = \"\\\\\" (\u00abASCII_ESCAPE\u00bb | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb = \"\\\\\" (!(\"x\" \"u\") | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>\u00abASCII_ESCAPE\u00bb = \"n\" | \"r\" | \"t\" | \"'\" | '\"' | \"\\\\\" | \"\\r\\n\" | \"\\r\" | \"\\n\";</pre> <pre></pre> <pre>\u00abHEX_BYTE_ESCAPE\u00bb = \"x\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre> <pre></pre> <pre>\u00abUNICODE_ESCAPE\u00bb = \"u\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre>"},{"location":"solidity-specification/05-expressions/05-strings/#string-literals","title":"String Literals","text":"<p>String literals are written with either double or single-quotes (<code>\"foo\"</code> or <code>'bar'</code>), and they can also be split into multiple consecutive parts (<code>\"foo\" \"bar\"</code> is equivalent to <code>\"foobar\"</code>) which can be helpful when dealing with long strings. They do not imply trailing zeroes as in C; <code>\"foo\"</code> represents three bytes, not four. As with integer literals, their type can vary, but they are implicitly convertible to <code>bytes1</code>, ..., <code>bytes32</code> if they fit.</p> <p>String literals can only contain printable ASCII characters, which means the characters between <code>0x20</code> and <code>0x7E</code> inclusively.</p>"},{"location":"solidity-specification/05-expressions/05-strings/#unicode-literals","title":"Unicode Literals","text":"<p>While regular string literals can only contain ASCII, unicode literals (prefixed with the keyword <code>unicode</code>) can contain any valid UTF-8 sequence. They also support the very same escape sequences as regular string literals.</p> <pre><code>string memory a = unicode\"Hello \ud83d\ude03\";\n</code></pre>"},{"location":"solidity-specification/05-expressions/05-strings/#hexadecimal-literals","title":"Hexadecimal Literals","text":"<p>Hexadecimal literals are prefixed with the keyword <code>hex</code> and are enclosed in double or single-quotes (<code>hex\"001122FF\"</code>, <code>hex'0011_22_FF'</code>). Their content must be hexadecimal digits which can optionally use a single underscore as separator between byte boundaries. The value of the literal will be the binary representation of the hexadecimal sequence.</p> <p>Hexadecimal literals behave like string literals and have the same convertibility restrictions. Additionally, multiple hexadecimal literals separated by whitespace are concatenated into a single literal: <code>hex\"00112233\" hex\"44556677\"</code> is equivalent to <code>hex\"0011223344556677\"</code></p>"},{"location":"solidity-specification/05-expressions/05-strings/#escape-sequences","title":"Escape Sequences","text":"<p>String literals also support the following escape characters:</p> <ul> <li><code>\\&lt;newline&gt;</code> (escapes an actual newline)</li> <li><code>\\\\</code> (backslash)</li> <li><code>\\'</code> (single quote)</li> <li><code>\\\"</code> (double quote)</li> <li><code>\\n</code> (newline)break</li> <li><code>\\r</code> (carriage return)</li> <li><code>\\t</code> (tab)</li> <li><code>\\xNN</code> (hex escape, takes a hex value and inserts the appropriate byte)</li> <li><code>\\uNNNN</code> (unicode escape, takes a Unicode code point and inserts an UTF-8 sequence)</li> </ul> <p>Any Unicode line terminator which is not a newline (i.e. LF, VF, FF, CR, NEL, LS, PS) is considered to terminate the string literal. Newline only terminates the string literal if it is not preceded by a <code>\\</code>.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/05-expressions/06-identifiers/","title":"5.6. Identifiers","text":""},{"location":"solidity-specification/05-expressions/06-identifiers/#56-identifiers","title":"5.6. Identifiers","text":""},{"location":"solidity-specification/05-expressions/06-identifiers/#syntax","title":"Syntax","text":"<pre>IdentifierPath = (* item: *) IDENTIFIER ((* separator: *) PERIOD (* item: *) IDENTIFIER)*;</pre> <pre></pre> <pre>IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>\u00abIDENTIFIER_START\u00bb = \"_\" | \"$\" | (\"a\"\u2026\"z\") | (\"A\"\u2026\"Z\");</pre> <pre></pre> <pre>\u00abIDENTIFIER_PART\u00bb = \u00abIDENTIFIER_START\u00bb | (\"0\"\u2026\"9\");</pre>"},{"location":"solidity-specification/05-expressions/06-identifiers/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/06-yul/","title":"6. Yul","text":""},{"location":"solidity-specification/06-yul/#6-yul","title":"6. Yul","text":"<ul> <li>6.1. Yul Statements</li> <li>6.2. Yul Expressions</li> <li>6.3. Yul Keywords</li> </ul>"},{"location":"solidity-specification/06-yul/01-yul-statements/","title":"6.1. Yul Statements","text":""},{"location":"solidity-specification/06-yul/01-yul-statements/#61-yul-statements","title":"6.1. Yul Statements","text":""},{"location":"solidity-specification/06-yul/01-yul-statements/#syntax","title":"Syntax","text":"<pre>YulBlock = (* open_brace: *) OPEN_BRACE           (* statements: *) YulStatements           (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>YulStatements = (* item: *) YulStatement*;</pre> <pre></pre> <pre>YulStatement = (* variant: *) YulBlock             | (* variant: *) YulFunctionDefinition             | (* variant: *) YulStackAssignmentStatement (* Deprecated in 0.5.0 *)             | (* variant: *) YulIfStatement             | (* variant: *) YulForStatement             | (* variant: *) YulSwitchStatement             | (* variant: *) YulLeaveStatement (* Introduced in 0.6.0 *)             | (* variant: *) YulBreakStatement             | (* variant: *) YulContinueStatement             | (* variant: *) YulLabel (* Deprecated in 0.5.0 *)             | (* variant: *) YulVariableDeclarationStatement             | (* variant: *) YulVariableAssignmentStatement             | (* variant: *) YulExpression;</pre> <pre></pre> <pre>YulFunctionDefinition = (* function_keyword: *) YUL_FUNCTION_KEYWORD                        (* name: *) YUL_IDENTIFIER                        (* parameters: *) YulParametersDeclaration                        (* returns: *) YulReturnsDeclaration?                        (* body: *) YulBlock;</pre> <pre></pre> <pre>YulParametersDeclaration = (* open_paren: *) OPEN_PAREN                           (* parameters: *) YulParameters                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulParameters = ((* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*)?;</pre> <pre></pre> <pre>YulReturnsDeclaration = (* minus_greater_than: *) MINUS_GREATER_THAN                        (* variables: *) YulVariableNames;</pre> <pre></pre> <pre>YulVariableNames = (* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*;</pre> <pre></pre> <pre>YulVariableDeclarationStatement = (* let_keyword: *) YUL_LET_KEYWORD                                  (* variables: *) YulVariableNames                                  (* value: *) YulVariableDeclarationValue?;</pre> <pre></pre> <pre>YulVariableDeclarationValue = (* assignment: *) YulAssignmentOperator                              (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulVariableAssignmentStatement = (* variables: *) YulPaths                                 (* assignment: *) YulAssignmentOperator                                 (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulAssignmentOperator = (* variant: *) COLON_EQUAL                      | (* variant: *) YulColonAndEqual; (* Deprecated in 0.5.5 *)</pre> <pre></pre> <pre>(* Deprecated in 0.5.5 *)YulColonAndEqual = (* colon: *) COLON                   (* equal: *) EQUAL;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentStatement = (* assignment: *) YulStackAssignmentOperator                              (* variable: *) YUL_IDENTIFIER;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentOperator = (* variant: *) EQUAL_COLON                           | (* variant: *) YulEqualAndColon;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulEqualAndColon = (* equal: *) EQUAL                   (* colon: *) COLON;</pre> <pre></pre> <pre>YulIfStatement = (* if_keyword: *) YUL_IF_KEYWORD                 (* condition: *) YulExpression                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulForStatement = (* for_keyword: *) YUL_FOR_KEYWORD                  (* initialization: *) YulBlock                  (* condition: *) YulExpression                  (* iterator: *) YulBlock                  (* body: *) YulBlock;</pre> <pre></pre> <pre>YulSwitchStatement = (* switch_keyword: *) YUL_SWITCH_KEYWORD                     (* expression: *) YulExpression                     (* cases: *) YulSwitchCases;</pre> <pre></pre> <pre>YulSwitchCases = (* item: *) YulSwitchCase+;</pre> <pre></pre> <pre>YulSwitchCase = (* variant: *) YulDefaultCase              | (* variant: *) YulValueCase;</pre> <pre></pre> <pre>YulDefaultCase = (* default_keyword: *) YUL_DEFAULT_KEYWORD                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulValueCase = (* case_keyword: *) YUL_CASE_KEYWORD               (* value: *) YulLiteral               (* body: *) YulBlock;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)YulLeaveStatement = (* leave_keyword: *) YUL_LEAVE_KEYWORD;</pre> <pre></pre> <pre>YulBreakStatement = (* break_keyword: *) YUL_BREAK_KEYWORD;</pre> <pre></pre> <pre>YulContinueStatement = (* continue_keyword: *) YUL_CONTINUE_KEYWORD;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulLabel = (* label: *) YUL_IDENTIFIER           (* colon: *) COLON;</pre>"},{"location":"solidity-specification/06-yul/01-yul-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/06-yul/02-yul-expressions/","title":"6.2. Yul Expressions","text":""},{"location":"solidity-specification/06-yul/02-yul-expressions/#62-yul-expressions","title":"6.2. Yul Expressions","text":""},{"location":"solidity-specification/06-yul/02-yul-expressions/#syntax","title":"Syntax","text":"<pre>YulExpression = (* variant: *) YulFunctionCallExpression              | (* variant: *) YulLiteral              | (* variant: *) YulBuiltInFunction              | (* variant: *) YulPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)YulFunctionCallExpression = (* operand: *) YulExpression                            (* open_paren: *) OPEN_PAREN                            (* arguments: *) YulArguments                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulArguments = ((* item: *) YulExpression ((* separator: *) COMMA (* item: *) YulExpression)*)?;</pre> <pre></pre> <pre>YulPaths = (* item: *) YulPath ((* separator: *) COMMA (* item: *) YulPath)*;</pre> <pre></pre> <pre>YulPath = (* item: *) YulPathComponent ((* separator: *) PERIOD (* item: *) YulPathComponent)*;</pre> <pre></pre> <pre>YulPathComponent = (* variant: *) YUL_IDENTIFIER                 | (* variant: *) YUL_ADDRESS_KEYWORD; (* Introduced in 0.8.10 *)</pre> <pre></pre> <pre>(* Introduced in 0.5.8 and deprecated in 0.7.0. *)YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb (\u00abIDENTIFIER_PART\u00bb | \".\")*;YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>YulBuiltInFunction = (* variant: *) YUL_ADD_KEYWORD                   | (* variant: *) YUL_ADD_MOD_KEYWORD                   | (* variant: *) YUL_ADDRESS_KEYWORD                   | (* variant: *) YUL_AND_KEYWORD                   | (* variant: *) YUL_BALANCE_KEYWORD                   | (* variant: *) YUL_BLOCK_HASH_KEYWORD                   | (* variant: *) YUL_BYTE_KEYWORD                   | (* variant: *) YUL_CALL_CODE_KEYWORD                   | (* variant: *) YUL_CALL_DATA_COPY_KEYWORD                   | (* variant: *) YUL_CALL_DATA_LOAD_KEYWORD                   | (* variant: *) YUL_CALL_DATA_SIZE_KEYWORD                   | (* variant: *) YUL_CALLER_KEYWORD                   | (* variant: *) YUL_CALL_KEYWORD                   | (* variant: *) YUL_CALL_VALUE_KEYWORD                   | (* variant: *) YUL_COIN_BASE_KEYWORD                   | (* variant: *) YUL_CREATE_KEYWORD                   | (* variant: *) YUL_DELEGATE_CALL_KEYWORD                   | (* variant: *) YUL_DIV_KEYWORD                   | (* variant: *) YUL_EQ_KEYWORD                   | (* variant: *) YUL_EXP_KEYWORD                   | (* variant: *) YUL_EXT_CODE_COPY_KEYWORD                   | (* variant: *) YUL_EXT_CODE_SIZE_KEYWORD                   | (* variant: *) YUL_GAS_KEYWORD                   | (* variant: *) YUL_GAS_LIMIT_KEYWORD                   | (* variant: *) YUL_GAS_PRICE_KEYWORD                   | (* variant: *) YUL_GT_KEYWORD                   | (* variant: *) YUL_INVALID_KEYWORD                   | (* variant: *) YUL_IS_ZERO_KEYWORD                   | (* variant: *) YUL_LOG_0_KEYWORD                   | (* variant: *) YUL_LOG_1_KEYWORD                   | (* variant: *) YUL_LOG_2_KEYWORD                   | (* variant: *) YUL_LOG_3_KEYWORD                   | (* variant: *) YUL_LOG_4_KEYWORD                   | (* variant: *) YUL_LT_KEYWORD                   | (* variant: *) YUL_M_LOAD_KEYWORD                   | (* variant: *) YUL_MOD_KEYWORD                   | (* variant: *) YUL_M_SIZE_KEYWORD                   | (* variant: *) YUL_M_STORE_8_KEYWORD                   | (* variant: *) YUL_M_STORE_KEYWORD                   | (* variant: *) YUL_MUL_KEYWORD                   | (* variant: *) YUL_MUL_MOD_KEYWORD                   | (* variant: *) YUL_NOT_KEYWORD                   | (* variant: *) YUL_NUMBER_KEYWORD                   | (* variant: *) YUL_ORIGIN_KEYWORD                   | (* variant: *) YUL_OR_KEYWORD                   | (* variant: *) YUL_POP_KEYWORD                   | (* variant: *) YUL_RETURN_KEYWORD                   | (* variant: *) YUL_REVERT_KEYWORD                   | (* variant: *) YUL_S_DIV_KEYWORD                   | (* variant: *) YUL_SELF_DESTRUCT_KEYWORD                   | (* variant: *) YUL_SGT_KEYWORD                   | (* variant: *) YUL_SIGN_EXTEND_KEYWORD                   | (* variant: *) YUL_S_LOAD_KEYWORD                   | (* variant: *) YUL_SLT_KEYWORD                   | (* variant: *) YUL_S_MOD_KEYWORD                   | (* variant: *) YUL_S_STORE_KEYWORD                   | (* variant: *) YUL_STOP_KEYWORD                   | (* variant: *) YUL_SUB_KEYWORD                   | (* variant: *) YUL_TIMESTAMP_KEYWORD                   | (* variant: *) YUL_XOR_KEYWORD                   | (* variant: *) YUL_KECCAK_256_KEYWORD (* Introduced in 0.4.12 *)                   | (* variant: *) YUL_SHA_3_KEYWORD (* Deprecated in 0.5.0 *)                   | (* variant: *) YUL_SUICIDE_KEYWORD (* Deprecated in 0.5.0 *)                   | (* variant: *) YUL_RETURN_DATA_COPY_KEYWORD (* Introduced in 0.4.12 *)                   | (* variant: *) YUL_RETURN_DATA_SIZE_KEYWORD (* Introduced in 0.4.12 *)                   | (* variant: *) YUL_STATIC_CALL_KEYWORD (* Introduced in 0.4.12 *)                   | (* variant: *) YUL_CREATE_2_KEYWORD (* Introduced in 0.4.12 *)                   | (* variant: *) YUL_EXT_CODE_HASH_KEYWORD (* Introduced in 0.5.0 *)                   | (* variant: *) YUL_SAR_KEYWORD                   | (* variant: *) YUL_SHL_KEYWORD                   | (* variant: *) YUL_SHR_KEYWORD                   | (* variant: *) YUL_CHAIN_ID_KEYWORD                   | (* variant: *) YUL_SELF_BALANCE_KEYWORD                   | (* variant: *) YUL_BASE_FEE_KEYWORD (* Introduced in 0.8.7 *)                   | (* variant: *) YUL_DIFFICULTY_KEYWORD (* Deprecated in 0.8.18 *)                   | (* variant: *) YUL_PREV_RANDAO_KEYWORD (* Introduced in 0.8.18 *)                   | (* variant: *) YUL_BLOB_BASE_FEE_KEYWORD (* Introduced in 0.8.24 *)                   | (* variant: *) YUL_BLOB_HASH_KEYWORD (* Introduced in 0.8.24 *)                   | (* variant: *) YUL_T_LOAD_KEYWORD (* Introduced in 0.8.24 *)                   | (* variant: *) YUL_T_STORE_KEYWORD (* Introduced in 0.8.24 *)                   | (* variant: *) YUL_M_COPY_KEYWORD; (* Introduced in 0.8.24 *)</pre> <pre></pre> <pre>YulLiteral = (* variant: *) YUL_TRUE_KEYWORD           | (* variant: *) YUL_FALSE_KEYWORD           | (* variant: *) YUL_DECIMAL_LITERAL           | (* variant: *) YUL_HEX_LITERAL           | (* variant: *) HexStringLiteral           | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>YUL_DECIMAL_LITERAL = \"0\" | ((\"1\"\u2026\"9\") (\"0\"\u2026\"9\")*);</pre> <pre></pre> <pre>YUL_HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+;</pre>"},{"location":"solidity-specification/06-yul/02-yul-expressions/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-specification/06-yul/03-yul-keywords/","title":"6.3. Yul Keywords","text":""},{"location":"solidity-specification/06-yul/03-yul-keywords/#63-yul-keywords","title":"6.3. Yul Keywords","text":""},{"location":"solidity-specification/06-yul/03-yul-keywords/#syntax","title":"Syntax","text":"<pre>(* Reserved until 0.7.1 *)YUL_ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>YUL_ADD_KEYWORD = \"add\";</pre> <pre></pre> <pre>YUL_ADD_MOD_KEYWORD = \"addmod\";</pre> <pre></pre> <pre>YUL_ADDRESS_KEYWORD = \"address\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>YUL_AND_KEYWORD = \"and\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>YUL_BALANCE_KEYWORD = \"balance\";</pre> <pre></pre> <pre>(* Introduced in 0.8.7 *)(* Reserved in 0.8.7 *)YUL_BASE_FEE_KEYWORD = \"basefee\";</pre> <pre></pre> <pre>(* Introduced in 0.8.24 *)(* Reserved in 0.8.25 *)YUL_BLOB_BASE_FEE_KEYWORD = \"blobbasefee\";</pre> <pre></pre> <pre>(* Introduced in 0.8.24 *)(* Reserved in 0.8.25 *)YUL_BLOB_HASH_KEYWORD = \"blobhash\";</pre> <pre></pre> <pre>YUL_BLOCK_HASH_KEYWORD = \"blockhash\";</pre> <pre></pre> <pre>(* Reserved until 0.5.10 *)YUL_BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>YUL_BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>YUL_BYTE_KEYWORD = \"byte\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>YUL_CALL_CODE_KEYWORD = \"callcode\";</pre> <pre></pre> <pre>YUL_CALL_DATA_COPY_KEYWORD = \"calldatacopy\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>YUL_CALL_DATA_LOAD_KEYWORD = \"calldataload\";</pre> <pre></pre> <pre>YUL_CALL_DATA_SIZE_KEYWORD = \"calldatasize\";</pre> <pre></pre> <pre>YUL_CALLER_KEYWORD = \"caller\";</pre> <pre></pre> <pre>YUL_CALL_KEYWORD = \"call\";</pre> <pre></pre> <pre>YUL_CALL_VALUE_KEYWORD = \"callvalue\";</pre> <pre></pre> <pre>YUL_CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>(* Reserved in 0.5.12 *)YUL_CHAIN_ID_KEYWORD = \"chainid\";</pre> <pre></pre> <pre>YUL_COIN_BASE_KEYWORD = \"coinbase\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>YUL_CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>YUL_CREATE_KEYWORD = \"create\";</pre> <pre></pre> <pre>(* Introduced in 0.4.12 *)(* Reserved in 0.4.12 *)YUL_CREATE_2_KEYWORD = \"create2\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>YUL_DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>YUL_DELEGATE_CALL_KEYWORD = \"delegatecall\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>(* Deprecated in 0.8.18 *)YUL_DIFFICULTY_KEYWORD = \"difficulty\";</pre> <pre></pre> <pre>YUL_DIV_KEYWORD = \"div\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>YUL_EQ_KEYWORD = \"eq\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>YUL_EXP_KEYWORD = \"exp\";</pre> <pre></pre> <pre>YUL_EXT_CODE_COPY_KEYWORD = \"extcodecopy\";</pre> <pre></pre> <pre>(* Introduced in 0.5.0 *)(* Reserved in 0.5.0 *)YUL_EXT_CODE_HASH_KEYWORD = \"extcodehash\";</pre> <pre></pre> <pre>YUL_EXT_CODE_SIZE_KEYWORD = \"extcodesize\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>YUL_FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\";(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>YUL_FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>YUL_FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>YUL_GAS_KEYWORD = \"gas\";</pre> <pre></pre> <pre>YUL_GAS_LIMIT_KEYWORD = \"gaslimit\";</pre> <pre></pre> <pre>YUL_GAS_PRICE_KEYWORD = \"gasprice\";</pre> <pre></pre> <pre>YUL_GT_KEYWORD = \"gt\";</pre> <pre></pre> <pre>(* Reserved from 0.7.0 until 0.7.1 *)YUL_GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>YUL_HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>YUL_IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>(* Reserved until 0.6.8 *)YUL_IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>YUL_INVALID_KEYWORD = \"invalid\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>YUL_IS_ZERO_KEYWORD = \"iszero\";</pre> <pre></pre> <pre>(* Introduced in 0.4.12 *)(* Reserved in 0.4.12 *)YUL_KECCAK_256_KEYWORD = \"keccak256\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.7.1 *)YUL_LEAVE_KEYWORD = \"leave\";</pre> <pre></pre> <pre>YUL_LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>YUL_LOG_0_KEYWORD = \"log0\";</pre> <pre></pre> <pre>YUL_LOG_1_KEYWORD = \"log1\";</pre> <pre></pre> <pre>YUL_LOG_2_KEYWORD = \"log2\";</pre> <pre></pre> <pre>YUL_LOG_3_KEYWORD = \"log3\";</pre> <pre></pre> <pre>YUL_LOG_4_KEYWORD = \"log4\";</pre> <pre></pre> <pre>YUL_LT_KEYWORD = \"lt\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>(* Introduced in 0.8.24 *)(* Reserved in 0.8.25 *)YUL_M_COPY_KEYWORD = \"mcopy\";</pre> <pre></pre> <pre>YUL_M_LOAD_KEYWORD = \"mload\";</pre> <pre></pre> <pre>YUL_MOD_KEYWORD = \"mod\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>YUL_M_SIZE_KEYWORD = \"msize\";</pre> <pre></pre> <pre>YUL_M_STORE_KEYWORD = \"mstore\";</pre> <pre></pre> <pre>YUL_M_STORE_8_KEYWORD = \"mstore8\";</pre> <pre></pre> <pre>YUL_MUL_KEYWORD = \"mul\";</pre> <pre></pre> <pre>YUL_MUL_MOD_KEYWORD = \"mulmod\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>YUL_NOT_KEYWORD = \"not\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>YUL_NUMBER_KEYWORD = \"number\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>YUL_OR_KEYWORD = \"or\";</pre> <pre></pre> <pre>YUL_ORIGIN_KEYWORD = \"origin\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>YUL_POP_KEYWORD = \"pop\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>(* Introduced in 0.8.18 *)(* Reserved in 0.8.18 *)YUL_PREV_RANDAO_KEYWORD = \"prevrandao\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>(* Introduced in 0.4.12 *)(* Reserved in 0.4.12 *)YUL_RETURN_DATA_COPY_KEYWORD = \"returndatacopy\";</pre> <pre></pre> <pre>(* Introduced in 0.4.12 *)(* Reserved in 0.4.12 *)YUL_RETURN_DATA_SIZE_KEYWORD = \"returndatasize\";</pre> <pre></pre> <pre>YUL_RETURN_KEYWORD = \"return\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>YUL_REVERT_KEYWORD = \"revert\";</pre> <pre></pre> <pre>(* Reserved in 0.4.21 *)YUL_SAR_KEYWORD = \"sar\";</pre> <pre></pre> <pre>YUL_S_DIV_KEYWORD = \"sdiv\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved in 0.5.12 *)YUL_SELF_BALANCE_KEYWORD = \"selfbalance\";</pre> <pre></pre> <pre>YUL_SELF_DESTRUCT_KEYWORD = \"selfdestruct\";</pre> <pre></pre> <pre>YUL_SGT_KEYWORD = \"sgt\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)(* Reserved until 0.5.0 *)YUL_SHA_3_KEYWORD = \"sha3\";</pre> <pre></pre> <pre>(* Reserved in 0.4.21 *)YUL_SHL_KEYWORD = \"shl\";</pre> <pre></pre> <pre>(* Reserved in 0.4.21 *)YUL_SHR_KEYWORD = \"shr\";</pre> <pre></pre> <pre>YUL_SIGN_EXTEND_KEYWORD = \"signextend\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>YUL_S_LOAD_KEYWORD = \"sload\";</pre> <pre></pre> <pre>YUL_SLT_KEYWORD = \"slt\";</pre> <pre></pre> <pre>YUL_S_MOD_KEYWORD = \"smod\";</pre> <pre></pre> <pre>YUL_S_STORE_KEYWORD = \"sstore\";</pre> <pre></pre> <pre>(* Introduced in 0.4.12 *)(* Reserved in 0.4.12 *)YUL_STATIC_CALL_KEYWORD = \"staticcall\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>YUL_STOP_KEYWORD = \"stop\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>YUL_SUB_KEYWORD = \"sub\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)(* Reserved until 0.5.0 *)YUL_SUICIDE_KEYWORD = \"suicide\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>YUL_SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>YUL_TIMESTAMP_KEYWORD = \"timestamp\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.8.24 *)(* Reserved in 0.8.25 *)YUL_T_LOAD_KEYWORD = \"tload\";</pre> <pre></pre> <pre>YUL_TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Introduced in 0.8.24 *)(* Reserved in 0.8.25 *)YUL_T_STORE_KEYWORD = \"tstore\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\";(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Reserved until 0.6.5 *)YUL_VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_YEARS_KEYWORD = \"years\";</pre> <pre></pre> <pre>YUL_XOR_KEYWORD = \"xor\";</pre>"},{"location":"solidity-specification/06-yul/03-yul-keywords/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"user-guide/","title":"User Guide","text":"<ul> <li>Introduction</li> <li>Concepts</li> <li>Rust Crate</li> <li>NPM Package</li> </ul>"},{"location":"user-guide/concepts/","title":"Concepts","text":"<p>At its core, Slang is a collection of APIs that are meant to analyze the source code, starting with the source code itself and ending with a rich structure that can be reasoned about. This is a departure from the classic approach of \"black-box\" compilers, which are handed the input and only their output can be observed.</p>"},{"location":"user-guide/concepts/#language-versions","title":"Language Versions","text":"<p>To use Slang, you start by initializing a <code>Language</code> object with a specific version of the language. The earliest Solidity version we support is <code>0.4.11</code>, and we plan on supporting all future versions as they are released.</p> <p>From a <code>Language</code> object, you can analyze any source text according to the nonterminals of that specific version. Providing an accurate language version is important, as it affects the shape of the syntax tree, and possible errors produced. You can use the <code>Language::getSupportedVersions()</code> API to get a list of all supported versions for the current Slang release.</p> <p>The <code>Language::parse()</code> API is the main entry point for the parser, and to generate concrete syntax trees (CSTs) that can be used for further analysis. Each <code>parse()</code> operation accepts the input source code, and a <code>NonterminalKind</code> variant. This allows callers to parse entire source files (<code>NonterminalKind::SourceUnit</code>), individual contracts (<code>NonterminalKind::ContractDefinition</code>), methods (<code>NonterminalKind::FunctionDefinition</code>), or any other syntax nodes.</p> <p>The resulting <code>ParseOutput</code> object will contain syntax errors (if any), and the syntax tree corresponding to the input source code.</p>"},{"location":"user-guide/concepts/#concrete-syntax-tree-cst","title":"Concrete Syntax Tree (CST)","text":"<p>Slang is capable of parsing the source code into a Concrete Syntax Tree (CST; also sometimes called \"full-fidelity\"), which is a tree structure of the program that also includes things like punctuation or whitespace.</p> <p>This is done by using the (standard) approach of lexical analysis followed by syntax analysis. The source text as a sequence of characters is recognized into a sequence of terminals (lexical analysis), which then in turn is parsed into the CST.</p> <p>The resulting CST is a regular tree data structure that you can visit. The tree nodes are represented by the <code>Node</code> structure, which can be one of two kinds:</p> <ul> <li><code>NonterminalNode</code> represent sub-trees, containing a vector of other <code>Node</code> children.</li> <li><code>TerminalNode</code> are leaves and represent a terminal (i.e. an identifier, keyword, punctuation) in the source.</li> </ul>"},{"location":"user-guide/concepts/#cst-cursors","title":"CST Cursors","text":"<p>For many code analysis tasks, it is useful to traverse the parse tree and visit each node. The <code>Cursor</code> object allows callers to traverse the parse tree in an efficient pre-order manner.</p> <p>It provides several <code>goTo*()</code> navigation functions, each returning <code>true</code> if the cursor was successfully moved, and <code>false</code> otherwise. There are three main ways to do it:</p> <ul> <li>According to the DFS order, i.e. <code>goToNext()</code> and <code>goToPrevious()</code>,</li> <li>According to the relationship between the current node and the next node, i.e. <code>goToParent()</code>, <code>goToFirstChild()</code>, <code>goToNextNonDescendent()</code></li> <li>According to the kind of the next node, i.e. <code>goToNextTerminalWithKind(kind)</code>, <code>goToNextNonterminalWithKind(kind)</code></li> </ul> <p>As such, the cursor is stateful and keeps track of the path it has taken through the CST. It starts at the root it was created at and is completed when it reaches its root when navigating forward.</p>"},{"location":"user-guide/concepts/#cst-queries","title":"CST Queries","text":"<p>The <code>Cursor</code> API is a low-level API that allows you to traverse the CST in a procedural manner. However, it is often more convenient to use the declarative <code>Query</code> API. Queries allow you to express your intent more concisely, and also allows you to reuse the same query in multiple places. Queries can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The query language is based on pattern matching, and the execution semantics are closer to unification than to regular expression matching i.e. a query returns all possible matches, not just the longest/shortest/first/last match. There is no concept of a 'greedy' operator for example.</p> <p>Query execution is based on <code>Cursor</code>s, and the resulting matches and unification captures are returned as <code>Cursor</code>s as well. This allows you to mix and match manual traversal, cursors, and queries.</p> <p>Multiple queries can be executed in a batch, and efficiently traverse the tree looking for matches. This mode of operation can replace all visitor patterns.</p>"},{"location":"user-guide/concepts/#abstract-syntax-tree-ast","title":"Abstract Syntax Tree (AST)","text":"<p>AST types are a set of abstractions that provide a typed view of the untyped CST nodes. You can convert any untyped CST node to its corresponding AST type using their constructors.</p> <p>There is a corresponding type for each <code>NonterminalKind</code> in the language. AST types are immutable. Additionally, their fields are constructed lazily as they are accessed for the first time.</p> <p>AST nodes maintain a reference to the CST node they were constructed from, and can be used to navigate to the corresponding CST node.</p>"},{"location":"user-guide/introduction/","title":"Introduction","text":"<p>Welcome to the Slang user guide! This aims to be an introduction to Slang itself, its concepts and also contains a collection of guides how you can achieve basic tasks with it.</p>"},{"location":"user-guide/introduction/#what-is-slang","title":"What is Slang?","text":"<p>Slang is intended to be a modular Solidity compiler, specifically targeting code analysis and developer tooling. This means servicing tools with domain-specific APIs and, in general, facilitating working with and analyzing the Solidity source code. If you're in the editor writing Solidity or performing linting or additional validation, there's a chance that you are, or could be, running Slang!</p> <p>To get a good grasp on the concepts used in Slang, see the Concepts section.</p>"},{"location":"user-guide/introduction/#what-slang-is-not","title":"What Slang is not?","text":"<p>First and foremost, it is not a replacement for <code>solc</code>, the standard Solidity compiler. We do not plan at the moment to support emitting optimized EVM bytecode for use in production. Secondly, it does not perform formal verification of contracts or Solidity logic in general. However, other tools that serve this purpose are intended to be built on top of it.</p>"},{"location":"user-guide/introduction/#supporting-multiple-versions","title":"Supporting multiple versions","text":"<p>The Solidity programming language has evolved quite a bit since its inception. Some features were introduced, some changed, while some eventually became obsolete and were removed altogether.</p> <p>While it's good for a programming language to evolve and better serve the needs of its users, not being able to easily upgrade or re-deploy existing contracts poses a unique challenge. Developer tooling must be able to understand and consume older contracts that are still being used on the blockchain, written in older versions of Solidity.</p> <p>Because of that, Slang must be able to reason about different versions of Solidity; how the language grammar, name capture rules, and semantics have changed across different versions. One of our goals is to document differences as part of our Solidity Specification.</p> <p>This is why, instead of having to download separate versions of the tool for each Solidity version, you can access the Slang language APIs by simply specifying the Solidity version that you want to work with.</p>"},{"location":"user-guide/introduction/#distributions","title":"Distributions","text":"<p>Slang itself is written in Rust and we maintain a public Rust package on crates.io. At the moment, we also distribute it as an npm package with TypeScript interface. In the future, we plan on expanding the language captures with Python and possibly more.</p>"},{"location":"user-guide/tree-query-language/","title":"The Tree Query Language","text":""},{"location":"user-guide/tree-query-language/#query-syntax","title":"Query Syntax","text":"<p>A query is a pattern that matches a certain set of nodes in a tree. The expression to match a given node consists of a pair of brackets (<code>[]</code>) containing two things: the node's kind, and optionally, a series of other patterns that match the node's children. For example, this pattern would match any <code>MultiplicativeExpression</code> node that has two children <code>Expression</code> nodes, with an <code>Asterisk</code> node in between:</p> <pre><code>[MultiplicativeExpression [Expression] [Asterisk] [Expression]]\n</code></pre> <p>The children of a node can optionally be labeled. The label is a property of the edge from the node to the child, and is not a property of the child. For example, this pattern will match a <code>MultiplicativeExpression</code> node with the two <code>Expression</code> children labeled <code>left_operand</code> and <code>right_operand</code>:</p> <pre><code>[MultiplicativeExpression left_operand:[Expression] [Asterisk] right_operand:[Expression]]\n</code></pre> <p>You can also match a node's textual content using a string literal. For example, this pattern would match a <code>MultiplicativeExpression</code> with a <code>*</code> operator (for clarity):</p> <pre><code>[MultiplicativeExpression left_operand:[_] operator:[\"*\"] right_operand:[_]]\n</code></pre> <p>If you don't care about the kind of a node, you can use an underscore <code>_</code>, which matches any kind. For example, this pattern will match a <code>MultiplicativeExpression</code> node with two children, one of any kind labeled <code>left_operand</code> and one of any kind:</p> <pre><code>[MultiplicativeExpression left_operand:[_] [_]]\n</code></pre> <p>Children can be elided. For example, this would produce multiple matches for a <code>MultiplicativeExpression</code> where at least one of the children is an expression of a <code>StringExpression</code> variant, where each match is associated with each of the <code>StringExpression</code> children:</p> <pre><code>[MultiplicativeExpression [Expression [StringExpression]]]\n</code></pre> <p>Trivia nodes (whitespace, comments, etc.) will be skipped over when running a query. Furthermore, trivia nodes cannot be explicitly (or implicitly with <code>_</code>) matched by queries.</p>"},{"location":"user-guide/tree-query-language/#capturing-nodes","title":"Capturing Nodes","text":"<p>When matching patterns, you may want to process specific nodes within the pattern. Captures allow you to associate names with specific nodes in a pattern, so that you can later refer to those nodes by those names. Capture names are written before the nodes that they refer to, and start with an <code>@</code> character.</p> <p>For example, this pattern would match any struct definition and it would associate the name <code>struct_name</code> with the identifier:</p> <pre><code>[StructDefinition @struct_name name:[Identifier]]\n</code></pre> <p>And this pattern would match all event definitions for a contract, associating the name <code>event_name</code> with the event name, <code>contract_name</code> with the containing contract name:</p> <pre><code>[ContractDefinition\n    @contract_name name:[Identifier]\n    members:[ContractMembers\n        [ContractMember\n            [EventDefinition @event_name name:[Identifier]]\n        ]\n    ]\n]\n</code></pre>"},{"location":"user-guide/tree-query-language/#quantification","title":"Quantification","text":"<p>You can surround a sequence of patterns in parenthesis (<code>()</code>), followed by a <code>?</code>, <code>*</code> or <code>+</code> operator. The <code>?</code> operator matches zero or one repetitions of a pattern, the <code>*</code> operator matches zero or more, and the <code>+</code> operator matches one or more.</p> <p>For example, this pattern would match a sequence of one or more import directives at the top of the file:</p> <pre><code>[SourceUnit members:[_ ([_ @import [ImportDirective]])+]]\n</code></pre> <p>This pattern would match a structure definition with one or more members, capturing their names:</p> <pre><code>[StructDefinition\n    @name name:[_]\n    members:[_ ([_ @member [Identifier]])+]\n]\n</code></pre> <p>This pattern would match all function calls, capturing a string argument if one was present:</p> <pre><code>[FunctionCallExpression\n    arguments:[ArgumentsDeclaration\n        variant:[PositionalArgumentsDeclaration\n            arguments:[PositionalArguments\n                (@arg [Expression variant:[StringExpression]])?\n            ]\n        ]\n    ]\n]\n</code></pre>"},{"location":"user-guide/tree-query-language/#alternations","title":"Alternations","text":"<p>An alternation is written as a sequence of patterns separated by <code>|</code> and surrounded by parentheses.</p> <p>For example, this pattern would match a call to either a variable or an object property. In the case of a variable, capture it as <code>@function</code>, and in the case of a property, capture it as <code>@method</code>:</p> <pre><code>[FunctionCallExpression\n    operand:[Expression\n        (@function variant:[Identifier]\n        | @method variant:[MemberAccessExpression])\n    ]\n]\n</code></pre> <p>This pattern would match a set of possible keyword terminals, capturing them as <code>@keyword</code>:</p> <pre><code>@keyword (\n    [\"break\"]\n  | [\"delete\"]\n  | [\"else\"]\n  | [\"for\"]\n  | [\"function\"]\n  | [\"if\"]\n  | [\"return\"]\n  | [\"try\"]\n  | [\"while\"]\n)\n</code></pre>"},{"location":"user-guide/tree-query-language/#adjacency","title":"Adjacency","text":"<p>By using the adjacency operator <code>.</code> you can constrain a pattern to only match the first or the last child nodes.</p> <p>For example, the following pattern would match only the first parameter declaration in a function definition:</p> <pre><code>[FunctionDefinition\n    [ParametersDeclaration\n        [Parameters . @first_param [Parameter]]\n    ]\n]\n</code></pre> <p>And conversely the following will match only the last parameter:</p> <pre><code>[FunctionDefinition\n    [ParametersDeclaration\n        [Parameters @last_param [Parameter] .]\n    ]\n]\n</code></pre> <p>If the adjacency operator is used in between two patterns it constrains matches on both patterns to occur consecutively, ie. without any other sibling node in between. For example, this pattern matches pairs of consecutive statements:</p> <pre><code>[Statements @stmt1 [Statement] . @stmt2 [Statement]]\n</code></pre>"},{"location":"user-guide/npm-package/","title":"NPM Package","text":"<ul> <li>Installation</li> <li>Using the Parser</li> <li>Using the Cursor</li> <li>Using Queries</li> <li>Using the AST</li> </ul>"},{"location":"user-guide/npm-package/installation/","title":"Installation","text":"<p>You can install Slang NPM package simply by running the following <code>npm</code> command:</p> <pre><code>npm install \"@nomicfoundation/slang\"\n</code></pre> <p>Or if you are using <code>yarn</code> for package management:</p> <pre><code>yarn add \"@nomicfoundation/slang\"\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/","title":"Using Queries","text":"<p>It's often more convenient to use the declarative <code>Query</code> API to traverse the CST, as they allow you to express your intent more concisely and can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The query language is based on pattern matching, and the execution semantics are closer to unification than to regular expression matching. A query returns all possible matches, not just the longest/shortest/first/last match.</p> <p>If not specified otherwise, let's assume we already parsed a Solidity source and have a <code>cursor</code> pointing to the root node of the CST (created with <code>createTreeCursor</code>, see Using the Cursor).</p>"},{"location":"user-guide/npm-package/using-queries/#creating-and-executing-queries","title":"Creating and executing queries","text":"<p>You can create a <code>Query</code> object using <code>Query.parse</code>, which accepts a string value. These can be then used by <code>Cursor.query</code> to execute it.</p> <p>You can pass multiple queries to a cursor to and efficiently traverse the tree looking for matches. They will be executed concurrently, returning matches in the order they appear in input.</p> <pre><code>// Any `Cursor` can be used to create a query.\nconst cursor = parse_output.createTreeCursor();\n\nconst query = Query.parse(\"[ContractDefinition]\");\nconst matches: QueryMatchIterator = cursor.query([query]);\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/#iterating-over-node-patterns","title":"Iterating over node patterns","text":"<p>Queries allow you to iterate over all node patterns that match the query, which can replace your need for manual iteration via cursors or visitors. In order to get a <code>Cursor</code> that points to the matched node, you need to capture them with a name capture (<code>@capture_name</code>) to a specific node in the query pattern.</p> <p>Let's use this to list all the contract definitions in the source file:</p> input.sol<pre><code>contract Foo {}\ncontract Bar {}\ncontract Baz {}\n</code></pre> <pre><code>const found = [];\n\nconst query = Query.parse(\"@contract [ContractDefinition]\");\nconst matches = cursor.query([query]);\n\nlet match = null;\nwhile ((match = matches.next())) {\n  const captures = match.captures;\n  const cursors = captures[\"contract\"];\n\n  const cursor = cursors?.[0]?.node() as NonterminalNode;\n\n  found.push(cursor.unparse().trim());\n}\n\nassert.deepStrictEqual(found, [\"contract Foo {}\", \"contract Bar {}\", \"contract Baz {}\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/#multiple-patterns-simultaneously","title":"Multiple patterns simultaneously","text":"<p>We can also intersperse multiple patterns in a single query, which will return all the matches for each pattern. This can be useful when you want to match multiple types of nodes in a single pass.</p> <pre><code>const names = [];\n\nconst struct_def = Query.parse(\"[StructDefinition @name [Identifier]]\");\nconst enum_def = Query.parse(\"[EnumDefinition @name [Identifier]]\");\nconst matches = cursor.query([struct_def, enum_def]);\n\nlet match = null;\nwhile ((match = matches.next())) {\n  const index = match.queryNumber;\n  const captures = match.captures;\n  const cursors = captures[\"name\"];\n\n  const cursor = cursors?.[0];\n\n  names.push([index, (cursor?.node() as TerminalNode).text]);\n}\n\nassert.deepStrictEqual(names, [\n  [0, \"Foo\"],\n  [1, \"Bar\"],\n  [0, \"Baz\"],\n  [1, \"Qux\"],\n]);\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/#matching-on-nodes-label","title":"Matching on node's label","text":"<p>We can match not only on the node's kind, but also on its label. This can be useful if there may be two children with the same kind but different labels or to be more declarative.</p> <p>To do so, we use <code>[label: _]</code> syntax. Here, we also use <code>_</code> to allow matching any kind of node, as long as it matches the given label.</p> input.sol<pre><code>contract Example {\n    function foo() public {\n        (uint a, uint16 b, uint64 c, uint256 d) = (1, 2, 3, 4);\n    }\n}\n</code></pre> <pre><code>const names = [];\n\nconst query = Query.parse(\"[TypedTupleMember @type type_name:[_]]\");\nconst matches = cursor.query([query]);\n\nlet match = null;\nwhile ((match = matches.next())) {\n  const captures = match.captures;\n  const cursors = captures[\"type\"];\n\n  const cursor = cursors?.[0];\n\n  names.push((cursor?.node() as NonterminalNode).unparse());\n}\n\nassert.deepStrictEqual(names, [\"uint\", \" uint16\", \" uint64\", \" uint256\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/#matching-on-nodes-literal-content","title":"Matching on node's literal content","text":"<p>Lastly, we can also match on the node's literal content. This can be useful when you want to match a specific identifier, string, or number.</p> <p>Let's say we prefer our code to be explicit and prefer using <code>uint256</code> instead of <code>uint</code>. To find all instances of the <code>uint</code> alias we could do the following:</p> input.sol<pre><code>contract Example {\n    function foo() public {\n        (uint a, uint16 b, uint64 c, uint256 d) = (1, 2, 3, 4);\n    }\n}\n</code></pre> <pre><code>const names = [];\n\nconst query = Query.parse(`[ElementaryType @uint_keyword variant:[\"uint\"]]`);\nconst matches = cursor.query([query]);\n\nlet match = null;\nwhile ((match = matches.next())) {\n  const captures = match.captures;\n  const cursors = captures[\"uint_keyword\"];\n\n  const cursor = cursors?.[0];\n\n  names.push((cursor?.node() as TerminalNode).text);\n}\n\nassert.deepStrictEqual(names, [\"uint\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-queries/#example-finding-txorigin-patterns","title":"Example: Finding <code>tx.origin</code> patterns","text":"<p>As a more realistic example, let's say we want to write a linter that unconditionally lints against all <code>tx.origin</code> accesses.</p> <p>Let's use the motivating example from https://soliditylang.org:</p> input.sol<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract TxUserWallet {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferTo(address payable dest, uint amount) public {\n        // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n}\n</code></pre> <p>Now, we can above features to write a query that matches all <code>tx.origin</code> patterns:</p> <pre><code>const query = Query.parse(`\n@txorigin [MemberAccessExpression\n  [Expression @start [\"tx\"]]\n  [\"origin\"]\n]`);\nconst matches = cursor.query([query]);\n\nconst found = [];\n\nlet match = null;\nwhile ((match = matches.next())) {\n  const captures = match.captures;\n  const cursors = captures[\"txorigin\"];\n\n  const cursor = cursors?.[0];\n\n  found.push([cursor?.textOffset.utf8, (cursor?.node() as NonterminalNode).unparse()]);\n}\n\nassert.deepStrictEqual(found, [[375, \"tx.origin\"]]);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-ast/","title":"Using the AST","text":"<p>Let's try to analyze the following Solidity source file, containing a simple function:</p> input.sol<pre><code>function add(uint256 a, uint256 b) public pure returns (uint256) {\n    return a + b;\n}\n</code></pre> <p>We start as usual by parsing the input, and then we can use the <code>ParseOutput</code> root to create the CST type. Since it is a node of kind <code>FunctionDefinition</code>, we are using the AST type of the same name to analyze it:</p> <pre><code>import assert from \"node:assert\";\nimport { Language } from \"@nomicfoundation/slang/language\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/kinds\";\nimport { NonterminalNode } from \"@nomicfoundation/slang/cst\";\nimport { FunctionDefinition } from \"@nomicfoundation/slang/ast\";\n\nconst language = new Language(\"0.8.0\");\n\nconst parseOutput = language.parse(NonterminalKind.FunctionDefinition, source);\n</code></pre> <p>The <code>FunctionDefinition</code> type has named fields to access all its children. For example, we can check the name of the function:</p> <pre><code>const $function = new FunctionDefinition(parseOutput.tree() as NonterminalNode);\n\nassert.equal($function.name.variant.text, \"add\");\n</code></pre> <p>We can also list its parameters:</p> <pre><code>const parameters = $function.parameters.parameters.items.map((parameter) =&gt; {\n  return parameter.name?.text;\n});\n\nassert.deepEqual(parameters, [\"a\", \"b\"]);\n</code></pre> <p>Or attributes:</p> <pre><code>const attributes = $function.attributes.items.map((attribute) =&gt; {\n  return attribute.cst.unparse().trim();\n});\n\nassert.deepEqual(attributes, [\"public\", \"pure\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-cursor/","title":"Using the Cursor","text":"<p>This guide will walk you through the basics of using a CST cursor in your project. Let's start with this source file, that contains three contracts:</p> input.sol<pre><code>contract Foo {}\ncontract Bar {}\ncontract Baz {}\n</code></pre> <pre><code>import assert from \"node:assert\";\nimport { Language } from \"@nomicfoundation/slang/language\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/kinds\";\nimport { NonterminalNode, TerminalNode } from \"@nomicfoundation/slang/cst\";\n\nconst language = new Language(\"0.8.0\");\n\nconst parseOutput = language.parse(NonterminalKind.SourceUnit, source);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-cursor/#listing-contract-names","title":"Listing Contract Names","text":"<p>The below example uses a cursor to list the names of all contracts in a source file:</p> <pre><code>const contracts = [];\n\nconst cursor = parseOutput.createTreeCursor();\n\nwhile (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n  assert(cursor.goToFirstChild());\n  assert(cursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n  const terminalNode = cursor.node();\n  assert(terminalNode instanceof TerminalNode);\n  contracts.push(terminalNode.text);\n\n  assert(cursor.goToParent());\n}\n\nassert.deepStrictEqual(contracts, [\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-cursor/#visiting-only-a-sub-tree","title":"Visiting Only a Sub-tree","text":"<p>In cases like the above, we needed to visit a sub-tree of the CST (to get the contract name). But we also need to remember to return the cursor to its original position after each read, which is inconvenient, and can lead to subtle bugs.</p> <p>To avoid this, we can use the <code>spawn()</code> API, which cheaply creates a new cursor that starts at the given node, without copying the previous path history. This lets us visit the sub-tree of each contract, without modifying the original cursor:</p> <pre><code>const contracts = [];\n\nconst cursor = parseOutput.createTreeCursor();\n\nwhile (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n  const childCursor = cursor.spawn();\n  assert(childCursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n  const terminalNode = childCursor.node();\n  assert(terminalNode instanceof TerminalNode);\n  contracts.push(terminalNode.text);\n}\n\nassert.deepStrictEqual(contracts, [\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-cursor/#accessing-node-positions","title":"Accessing Node Positions","text":"<p>The <code>Cursor</code> API also tracks the position and range of the current node it is visiting. Here is an example that records the source range of each contract, along with its text:</p> <pre><code>const contracts = [];\n\nconst cursor = parseOutput.createTreeCursor();\n\nwhile (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n  const range = cursor.textRange;\n\n  const contractNode = cursor.node();\n  assert(contractNode instanceof NonterminalNode);\n\n  contracts.push([\n    range.start.line,\n    range.start.column,\n    range.end.line,\n    range.end.column,\n    contractNode.unparse().trim(),\n  ]);\n}\n\nassert.deepStrictEqual(contracts, [\n  [0, 0, 1, 0, \"contract Foo {}\"],\n  [1, 0, 2, 0, \"contract Bar {}\"],\n  [2, 0, 2, 15, \"contract Baz {}\"],\n]);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-parser/","title":"Using the Parser","text":"<p>Using the API directly provides us with a more fine-grained control over the parsing process. It allows us to parse not just the input as a top-level source unit, but also individual constructs like contracts, various definitions, and even expressions.</p>"},{"location":"user-guide/npm-package/using-the-parser/#parsing-source-files","title":"Parsing Source Files","text":"<p>Let's start with this simple source file, that contains a single contract:</p> input.sol<pre><code>contract Foo {}\n</code></pre> <p>We begin by creating a <code>Language</code> object with a specified version. This is an entry point for our parser API. Then we can use it to parse the source file, specifying the top-level nonterminal to parse:</p> <pre><code>import assert from \"node:assert\";\nimport { Language } from \"@nomicfoundation/slang/language\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/kinds\";\nimport { NonterminalNode } from \"@nomicfoundation/slang/cst\";\n\nconst language = new Language(\"0.8.0\");\n\nconst parseOutput = language.parse(NonterminalKind.ContractDefinition, source);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-parser/#checking-for-syntax-errors","title":"Checking for Syntax Errors","text":"<p>If the file has errors, we can get them from the <code>ParseOutput</code> type, and print them out:</p> <pre><code>for (const error of parseOutput.errors()) {\n  console.error(`Error at byte offset ${error.textRange().start.utf8}: ${error.message()}`);\n}\n</code></pre> <p>Otherwise, we can check if input is valid using this helpful utility:</p> <pre><code>assert(parseOutput.isValid);\n</code></pre>"},{"location":"user-guide/npm-package/using-the-parser/#inspecting-the-parse-tree","title":"Inspecting the Parse Tree","text":"<p>Now, let's try to inspect the resulting CST, and iterate on its children:</p> <pre><code>const contract = parseOutput.tree();\nassert(contract instanceof NonterminalNode);\nassert.equal(contract.kind, NonterminalKind.ContractDefinition);\n\nconst contractChildren = contract.children();\nassert.equal(contractChildren.length, 7);\n\nconst [contractKeyword, firstSpace, contractName, secondSpace, openBrace, members, closeBrace] = contractChildren;\n\nassert.equal(contractKeyword?.kind, TerminalKind.ContractKeyword);\nassert.equal(firstSpace?.kind, TerminalKind.Whitespace);\nassert.equal(contractName?.kind, TerminalKind.Identifier);\nassert.equal(secondSpace?.kind, TerminalKind.Whitespace);\nassert.equal(openBrace?.kind, TerminalKind.OpenBrace);\nassert.equal(members?.kind, NonterminalKind.ContractMembers);\nassert.equal(closeBrace?.kind, TerminalKind.CloseBrace);\n</code></pre> <p>Additionally, we can convert the CST node back into the input string:</p> <pre><code>const contractSource = contract.unparse();\nassert.equal(contractSource, \"contract Foo {}\");\n</code></pre>"},{"location":"user-guide/rust-crate/","title":"Rust Crate","text":"<ul> <li>Installation</li> <li>Using the CLI</li> <li>Using the Parser</li> <li>Using the Cursor</li> <li>Using Queries</li> </ul>"},{"location":"user-guide/rust-crate/installation/","title":"Installation","text":"<p>The Rust package is published to crates.io as <code>slang_solidity</code> (docs). It can be used both as a regular Rust dependency and as a standalone CLI (installable with Cargo).</p> <p>You can install the CLI as a cargo binary using:</p> <pre><code>cargo install \"slang_solidity_cli\"\n</code></pre> <p>Or you can add the API as a dependency to your project:</p> <pre><code>cargo add \"slang_solidity\"\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/","title":"Using Queries","text":"<p>It's often more convenient to use the declarative <code>Query</code> API to traverse the CST, as they allow you to express your intent more concisely and can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The query language is based on pattern matching, and the execution semantics are closer to unification than to regular expression matching. A query returns all possible matches, not just the longest/shortest/first/last match.</p> <p>If not specified otherwise, let's assume we already parsed a Solidity source and have a <code>cursor</code> pointing to the root node of the CST (created with <code>create_tree_cursor</code>, see Using the Cursor).</p>"},{"location":"user-guide/rust-crate/using-queries/#creating-and-executing-queries","title":"Creating and executing queries","text":"<p>You can create a <code>Query</code> struct using <code>Query::parse</code>, which accepts a <code>&amp;str</code>. These can be then used by <code>Cursor::query</code> to execute it.</p> <p>You can pass multiple queries to a cursor to and efficiently traverse the tree looking for matches. They will be executed concurrently, returning matches in the order they appear in input.</p> <pre><code>use slang_solidity::query::Query;\n\n// Any `Cursor` can be used to create a query.\nlet cursor = parse_output.create_tree_cursor();\n\nlet query = Query::parse(\"[ContractDefinition]\").unwrap();\nlet result: QueryMatchIterator = cursor.query(vec![query]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/#iterating-over-node-patterns","title":"Iterating over node patterns","text":"<p>Queries allow you to iterate over all node patterns that match the query, which can replace your need for manual iteration via cursors or visitors. In order to get a <code>Cursor</code> that points to the matched node, you need to capture them with a name capture (<code>@capture_name</code>) to a specific node in the query pattern.</p> <p>Let's use this to list all the contract definitions in the source file:</p> input.sol<pre><code>contract Foo {}\ncontract Bar {}\ncontract Baz {}\n</code></pre> <pre><code>let mut found = vec![];\n\nlet query = Query::parse(\"@contract [ContractDefinition]\").unwrap();\n\nfor r#match in cursor.query(vec![query]) {\n    let captures = r#match.captures;\n    let cursors = captures.get(\"contract\").unwrap();\n\n    let cursor = cursors.first().unwrap();\n\n    found.push(cursor.node().unparse().trim().to_owned());\n}\n\nassert_eq!(\n    found,\n    [\"contract Foo {}\", \"contract Bar {}\", \"contract Baz {}\"]\n);\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/#multiple-patterns-simultaneously","title":"Multiple patterns simultaneously","text":"<p>We can also intersperse multiple patterns in a single query, which will return all the matches for each pattern. This can be useful when you want to match multiple types of nodes in a single pass.</p> <pre><code>let mut names = vec![];\n\nlet struct_def = Query::parse(\"[StructDefinition @name [Identifier]]\").unwrap();\nlet enum_def = Query::parse(\"[EnumDefinition @name [Identifier]]\").unwrap();\n\nfor r#match in cursor.query(vec![struct_def, enum_def]) {\n    let index = r#match.query_number;\n    let captures = r#match.captures;\n    let cursors = captures.get(\"name\").unwrap();\n\n    let cursor = cursors.first().unwrap();\n\n    names.push((index, cursor.node().unparse()));\n}\n\nassert_eq!(\n    names,\n    &amp;[\n        (0, \"Foo\".to_string()),\n        (1, \"Bar\".to_string()),\n        (0, \"Baz\".to_string()),\n        (1, \"Qux\".to_string())\n    ]\n);\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/#matching-on-nodes-label","title":"Matching on node's label","text":"<p>We can match not only on the node's kind, but also on its label. This can be useful if there may be two children with the same kind but different labels or to be more declarative.</p> <p>To do so, we use <code>[label: _]</code> syntax. Here, we also use <code>_</code> to allow matching any kind of node, as long as it matches the given label.</p> input.sol<pre><code>contract Example {\n    function foo() public {\n        (uint a, uint16 b, uint64 c, uint256 d) = (1, 2, 3, 4);\n    }\n}\n</code></pre> <pre><code>let mut names = vec![];\n\nlet query = Query::parse(\"[TypedTupleMember @type type_name:[_]]\").unwrap();\n\nfor r#match in cursor.query(vec![query]) {\n    let captures = r#match.captures;\n    let cursors = captures.get(\"type\").unwrap();\n\n    let cursor = cursors.first().unwrap();\n\n    names.push(cursor.node().unparse());\n}\n\nassert_eq!(names, &amp;[\"uint\", \" uint16\", \" uint64\", \" uint256\"]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/#matching-on-nodes-literal-content","title":"Matching on node's literal content","text":"<p>Lastly, we can also match on the node's literal content. This can be useful when you want to match a specific identifier, string, or number.</p> <p>Let's say we prefer our code to be explicit and prefer using <code>uint256</code> instead of <code>uint</code>. To find all instances of the <code>uint</code> alias we could do the following:</p> input.sol<pre><code>contract Example {\n    function foo() public {\n        (uint a, uint16 b, uint64 c, uint256 d) = (1, 2, 3, 4);\n    }\n}\n</code></pre> <pre><code>let mut names = vec![];\n\nlet query = Query::parse(r#\"[ElementaryType @uint_keyword variant:[\"uint\"]]\"#).unwrap();\n\nfor r#match in cursor.query(vec![query]) {\n    let captures = r#match.captures;\n    let cursors = captures.get(\"uint_keyword\").unwrap();\n\n    let cursor = cursors.first().unwrap();\n\n    names.push(cursor.node().unparse());\n}\n\nassert_eq!(names, &amp;[\"uint\"]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-queries/#example-finding-txorigin-patterns","title":"Example: Finding <code>tx.origin</code> patterns","text":"<p>As a more realistic example, let's say we want to write a linter that unconditionally lints against all <code>tx.origin</code> accesses.</p> <p>Let's use the motivating example from https://soliditylang.org:</p> input.sol<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract TxUserWallet {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferTo(address payable dest, uint amount) public {\n        // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n}\n</code></pre> <p>Now, we can above features to write a query that matches all <code>tx.origin</code> patterns:</p> <pre><code>let query = Query::parse(\n    r#\"@txorigin [MemberAccessExpression\n            [Expression @start [\"tx\"]]\n            [\"origin\"]\n        ]\"#,\n)\n.unwrap();\n\nlet mut results = vec![];\n\nfor r#match in cursor.query(vec![query]) {\n    let captures = r#match.captures;\n    let cursors = captures.get(\"txorigin\").unwrap();\n\n    let cursor = cursors.first().unwrap();\n\n    results.push((cursor.text_offset().utf8, cursor.node().unparse()));\n}\n\nassert_eq!(results, &amp;[(375usize, \"tx.origin\".to_string())]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cli/","title":"Using the CLI","text":""},{"location":"user-guide/rust-crate/using-the-cli/#parsing-source-files","title":"Parsing Source Files","text":"<p>The <code>parse</code> command will take a path to a Solidity file, and a <code>--version</code> flag. Specifying the correct version is important, as it will affect the grammar used to parse inputs.</p> <p>All parse errors are printed in a human-readable format; the command will succeed if there are no parse errors, and fail otherwise.</p> <pre><code>$ slang_solidity parse --help\n\nUsage: slang_solidity parse [OPTIONS] --version &lt;VERSION&gt; &lt;FILE_PATH&gt;\n\nArguments:\n  &lt;FILE_PATH&gt;\n          File path to the Solidity (*.sol) source file to parse\n\nOptions:\n  -v, --version &lt;VERSION&gt;\n          The Solidity language version to use for parsing\n      --json\n          Print the concrete syntax tree as JSON\n  -h, --help\n          Print help\n</code></pre> <p>Here is an example of the JSON output it can print:</p> <pre><code>// A Nonterminal node\n\"Nonterminal\": {\n  // Name of the nonterminal kind\n  \"kind\": \"SourceUnit\",\n  // Length of the nonterminal in Unicode code points, depending on the encoding used\n  \"text_len\": {\n    \"utf8\": 24,\n    \"utf16\": 24,\n    \"char\": 24 // de facto utf32\n  },\n  \"children\": [/* Nonterminal or Terminal nodes */]\n}\n// A Terminal node\n\"Terminal\": {\n  // Name of the terminal kind\n  \"kind\": \"PragmaKeyword\",\n  // Literal value, taken from the source code\n  \"text\": \"pragma\"\n}\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cli/#inspecting-json-output","title":"Inspecting JSON Output","text":"<p>Now let's try to use that command to parse the following Solidity file, and inspect its contents:</p> input.sol<pre><code>pragma solidity ^0.8.0;\n</code></pre> <pre><code>slang_solidity parse --json --version \"0.8.0\" \"input.sol\" &gt; \"output.json\"\n</code></pre> <p>Because the resulting structure is well-defined and recursive, we can use the popular <code>jq</code> tool to quickly analyze the resulting output:</p> <pre><code>JQ_QUERY='recurse | select(.Terminal?) | .Terminal'\ncat output.json | jq \"$JQ_QUERY\"\n</code></pre> <p>This gives us a flat list of the Terminal nodes:</p> <pre><code>{\n  \"kind\": \"PragmaKeyword\",\n  \"text\": \"pragma\"\n}\n{\n  \"kind\": \"Whitespace\",\n  \"text\": \" \"\n}\n{\n  \"kind\": \"SolidityKeyword\",\n  \"text\": \"solidity\"\n}\n{\n  \"kind\": \"Whitespace\",\n  \"text\": \" \"\n}\n{\n  \"kind\": \"Caret\",\n  \"text\": \"^\"\n}\n{\n  \"kind\": \"VersionPragmaValue\",\n  \"text\": \"0\"\n}\n{\n  \"kind\": \"Period\",\n  \"text\": \".\"\n}\n{\n  \"kind\": \"VersionPragmaValue\",\n  \"text\": \"8\"\n}\n{\n  \"kind\": \"Period\",\n  \"text\": \".\"\n}\n{\n  \"kind\": \"VersionPragmaValue\",\n  \"text\": \"0\"\n}\n{\n  \"kind\": \"Semicolon\",\n  \"text\": \";\"\n}\n{\n  \"kind\": \"EndOfLine\",\n  \"text\": \"\\n\"\n}\n</code></pre> <p>Now, we can adapt the query to select the <code>text</code> fields of the nodes and concatenate them, which gives us back the reconstructed source code! \ud83c\udf89</p> <pre><code>$ JQ_QUERY='[recurse | select(.Terminal?) | .Terminal.text] | join(\"\")'\n$ cat output.json | jq \"$JQ_QUERY\"\n\n\"pragma solidity ^0.8.0;\\n\"\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cursor/","title":"Using the Cursor","text":"<p>This guide will walk you through the basics of using a CST cursor in your project. Let's start with this source file, that contains three contracts:</p> input.sol<pre><code>contract Foo {}\ncontract Bar {}\ncontract Baz {}\n</code></pre> <pre><code>use semver::Version;\nuse slang_solidity::kinds::{EdgeLabel, NonterminalKind, TerminalKind};\nuse slang_solidity::language::Language;\nuse slang_solidity::text_index::TextRangeExtensions;\n\nlet language = Language::new(Version::parse(\"0.8.0\")?)?;\n\nlet parse_output = language.parse(NonterminalKind::SourceUnit, source);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cursor/#listing-contract-names","title":"Listing Contract Names","text":"<p>The below example uses a cursor to list the names of all contracts in a source file:</p> <pre><code>let mut contracts = Vec::new();\n\nlet mut cursor = parse_output.create_tree_cursor();\n\nwhile cursor.go_to_next_nonterminal_with_kind(NonterminalKind::ContractDefinition) {\n    assert!(cursor.go_to_first_child());\n    assert!(cursor.go_to_next_terminal_with_kind(TerminalKind::Identifier));\n\n    let terminal_node = cursor.node();\n    contracts.push(terminal_node.as_terminal().unwrap().text.clone());\n\n    // You have to make sure you return the cursor to its original position:\n    assert!(cursor.go_to_parent());\n}\n\nassert_eq!(contracts, &amp;[\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cursor/#visiting-only-a-sub-tree","title":"Visiting Only a Sub-tree","text":"<p>In cases like the above, we needed to visit a sub-tree of the CST (to get the contract name). But we also need to remember to return the cursor to its original position after each read, which is inconvenient, and can lead to subtle bugs.</p> <p>To avoid this, we can use the <code>spawn()</code> API, which cheaply creates a new cursor that starts at the given node, without copying the previous path history. This lets us visit the sub-tree of each contract, without modifying the original cursor:</p> <pre><code>let mut contracts = Vec::new();\n\nlet mut cursor = parse_output.create_tree_cursor();\n\nwhile cursor.go_to_next_nonterminal_with_kind(NonterminalKind::ContractDefinition) {\n    let mut child_cursor = cursor.spawn();\n    assert!(child_cursor.go_to_next_terminal_with_kind(TerminalKind::Identifier));\n\n    let terminal_node = child_cursor.node();\n    contracts.push(terminal_node.as_terminal().unwrap().text.clone());\n}\n\nassert_eq!(contracts, &amp;[\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cursor/#accessing-node-positions","title":"Accessing Node Positions","text":"<p>The <code>Cursor</code> API also tracks the position and range of the current node it is visiting. Here is an example that records the source range of each contract, along with its text:</p> <pre><code>let mut contracts = Vec::new();\n\nlet mut cursor = parse_output.create_tree_cursor();\n\nwhile cursor.go_to_next_nonterminal_with_kind(NonterminalKind::ContractDefinition) {\n    let range = cursor.text_range().utf8();\n    let text = Rc::clone(cursor.node().as_nonterminal().unwrap()).unparse();\n\n    contracts.push((range, text.trim().to_owned()));\n}\n\nassert_eq!(\n    contracts,\n    &amp;[\n        (0..16, \"contract Foo {}\".to_string()),\n        (16..32, \"contract Bar {}\".to_string()),\n        (32..47, \"contract Baz {}\".to_string()),\n    ]\n);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-cursor/#using-iterator-api","title":"Using Iterator API","text":"<p>In addition to the procedural-style methods, the <code>Cursor</code> struct also implements the <code>Iterator</code> trait, which allows you to use it in a functional style.</p> <p>Let's use that to extract all <code>Identifier</code> nodes from the source text using that API:</p> <pre><code>let cursor = parse_output.create_tree_cursor();\n\nlet identifiers: Vec&lt;_&gt; = cursor\n    .filter_map(|node| {\n        node.as_terminal_with_kind(TerminalKind::Identifier)\n            .cloned()\n    })\n    .map(|identifier| identifier.text.clone())\n    .collect();\n\nassert_eq!(identifiers, &amp;[\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre> <p>Note</p> <p>It's important to note that <code>Iterator::next</code> first visits the current node, yields it, and then moves the cursor to the next node. As such, accessor associated functions called on the <code>Cursor</code> that reference the \"current\" will point to the one that is not yet yielded by the iterator. This might be an important, when mixing the two styles.</p>"},{"location":"user-guide/rust-crate/using-the-cursor/#using-a-cursor-with-names","title":"Using a Cursor with Names","text":"<p>In addition to the basic <code>Cursor</code>, there's also a <code>CursorWithLabels</code> type that keeps track of the names of the nodes it visits. You can create a <code>CursorWithLabels</code> from a <code>Cursor</code> by using the <code>with_labels()</code> API.</p> <p>Let's use that to extract all nodes that are labeled <code>Name</code>:</p> <pre><code>let cursor = parse_output.create_tree_cursor();\n\nlet identifiers: Vec&lt;_&gt; = cursor\n    .with_edges()\n    .filter(|node| node.label == Some(EdgeLabel::Name))\n    .filter_map(|node| {\n        node.as_terminal_with_kind(TerminalKind::Identifier)\n            .cloned()\n    })\n    .map(|identifier| identifier.text.clone())\n    .collect();\n\nassert_eq!(identifiers, &amp;[\"Foo\", \"Bar\", \"Baz\"]);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-parser/","title":"Using the Parser","text":"<p>Using the API directly provides us with a more fine-grained control over the parsing process. It allows us to parse not just the input as a top-level source unit, but also individual nonterminals like contracts, various definitions, and even expressions.</p>"},{"location":"user-guide/rust-crate/using-the-parser/#parsing-source-files","title":"Parsing Source Files","text":"<p>Let's start with this simple source file, that contains a single contract:</p> input.sol<pre><code>contract Foo {}\n</code></pre> <p>We begin by creating a <code>Language</code> object with a specified version. This is an entry point for our parser API. Then we can use it to parse the source file, specifying the top-level nonterminal to parse:</p> <pre><code>use semver::Version;\nuse slang_solidity::cst::Node;\nuse slang_solidity::kinds::{NonterminalKind, TerminalKind};\nuse slang_solidity::language::Language;\n\nlet language = Language::new(Version::parse(\"0.8.0\")?)?;\n\nlet parse_output = language.parse(NonterminalKind::ContractDefinition, source);\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-parser/#checking-for-syntax-errors","title":"Checking for Syntax Errors","text":"<p>If the file has errors, we can get them from the <code>ParseOutput</code> type, and print them out:</p> <pre><code>for error in parse_output.errors() {\n    eprintln!(\n        \"Error at byte offset {offset}: {message}\",\n        offset = error.text_range().start.utf8,\n        message = error.message()\n    );\n}\n</code></pre> <p>Otherwise, we can check if input is valid using this helpful utility:</p> <pre><code>assert!(parse_output.is_valid());\n</code></pre>"},{"location":"user-guide/rust-crate/using-the-parser/#inspecting-the-parse-tree","title":"Inspecting the Parse Tree","text":"<p>Now, let's try to inspect the resulting CST, and iterate on its children:</p> <pre><code>let parse_tree = parse_output.tree();\n\nlet contract = parse_tree.as_nonterminal().unwrap();\nassert_eq!(contract.kind, NonterminalKind::ContractDefinition);\nassert_eq!(contract.children.len(), 7);\n\nlet children = &amp;contract.children;\nassert!(\n    matches!(&amp;children[0].node, Node::Terminal(t) if t.kind == TerminalKind::ContractKeyword)\n);\nassert!(matches!(&amp;children[1].node, Node::Terminal(t) if t.kind == TerminalKind::Whitespace));\nassert!(matches!(&amp;children[2].node, Node::Terminal(t) if t.kind == TerminalKind::Identifier));\nassert!(matches!(&amp;children[3].node, Node::Terminal(t) if t.kind == TerminalKind::Whitespace));\nassert!(matches!(&amp;children[4].node, Node::Terminal(t) if t.kind == TerminalKind::OpenBrace));\nassert!(\n    matches!(&amp;children[5].node, Node::Nonterminal(r) if r.kind == NonterminalKind::ContractMembers)\n);\nassert!(matches!(&amp;children[6].node, Node::Terminal(t) if t.kind == TerminalKind::CloseBrace));\n</code></pre> <p>Additionally, we can convert the CST node back into the input string:</p> <pre><code>let contract_source = Rc::clone(contract).unparse();\nassert_eq!(contract_source, \"contract Foo {}\");\n</code></pre>"}]}