{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"slang","text":""},{"location":"#solidity-compiler-tooling-by-nomicfoundation","title":"Solidity compiler tooling by @NomicFoundation","text":"<p>A modular set of compiler APIs empowering the next generation of Solidity code analysis and developer tooling. Written in Rust and distributed in multiple languages.</p> <ul> <li>Announcement Post</li> <li>How to write your own Solidity linter using Slang, in 25 lines of code!</li> <li>Slang User Guide</li> </ul> <p>This repository maintains the source code and release process for these projects:</p> <ul> <li>Solidity Language Grammar</li> <li>Slang NPM Package</li> </ul> <p>\u2757 This project is still in alpha, and is under active development. If you are planning on using it, please reach out to us on Telegram so we can help you get started.</p> <ul> <li>Slang Telegram Group</li> <li>We are hiring!</li> </ul>"},{"location":"internals/","title":"Internals","text":"<ul> <li>Repository Structure</li> <li>Development</li> <li>Design Docs</li> </ul>"},{"location":"internals/development/","title":"Development","text":""},{"location":"internals/development/#dev-containers","title":"Dev Containers","text":"<p>To make the developer experience as seamless and consistent as possible, we recommend using the VS Code devcontainer included in this repository. It is a light image that has the minimum required tools to build this project. If you are not familiar with containerized development, I recommend taking a look at the official VS Code guide. Using a devcontainer allows us to quickly setup/teardown the environment, and install/setup different dependencies for different projects, without polluting the local environment. In the future, it will enable us to include Windows and Mac OS specific images for cross-platform testing.</p> <p>If you would like to still develop outside a container, this should still be possible, as the CI will guarantee that your changes are safe. We intend to keep the images to a bare minimum, and install most dependencies through scripts you can run locally. However, using a common development container means sharing and standardizing useful settings and extensions for the editor (VS Code), the terminal (zsh), and any other tools.</p> <p>In the future, if we decide to enable code spaces, we can have a 1-click button to create and warm up a powerful dev machine to use in seconds, and running completely remote in a browser tab. It will make it trivial to switch between different versions and branches, or even use and debug multiple ones at the same time from different tabs.</p>"},{"location":"internals/development/#hermit","title":"Hermit","text":"<p>To install language-specific binaries and packages, we use Hermit, which installs all tools only when it is first needed/invoked, so you can quickly setup and build different projects quickly. It also takes care of updating your <code>$PATH</code> as you <code>cd</code> in and out of different projects, to make sure you are using the right tools every time. Follow this guide to install it locally to your machine, or simply build any included project, and it will bootstrap itself if it is missing.</p>"},{"location":"internals/development/#infra-cli","title":"Infra CLI","text":"<p>To ensure consistency, and a good experience for first-time developers, all build/test/run/debug commands should be written, versioned, and documented inside the <code>infra_cli</code> crate. This means that any dev instructions are well documented, versioned, and verified/executed with every build. It also means that we can minimize any manual setup or teardown steps during development, and just rely on that cli.</p> <p>You can access all such commands (from the hermit environment) by just running the <code>infra</code> script, which just refers to <code>$REPO_ROOT/scripts/bin/infra</code>. If this is your first time contributing, we recommend starting with <code>infra --help</code> to familiarize yourself with its capabilities.</p>"},{"location":"internals/development/#versioning-and-publishing","title":"Versioning and Publishing","text":"<p>We manage versioning through changesets. Each pull request can describe what user facing changes it is introducing, and include this information as a \"changeset\" markdown file along with source changes. These changeset files are analyzed and used to create another pull request to bump the repository version and update dependencies. Once the version bump is merged, artifacts are built and released to all registries.</p>"},{"location":"internals/development/#managing-dependencies","title":"Managing Dependencies","text":"<p>Our <code>$REPO_ROOT/.github/dependabot.yml</code> config runs automatic updates to our dependencies on a weekly basis. This handles <code>github-actions</code>, <code>npm</code>, <code>cargo</code>, and <code>pip</code> packages. However, two kinds of dependencies still need to be updated manually for now:</p> <ol> <li>Rust toolchains: <code>$RUST_STABLE_VERSION</code> and <code>$RUST_NIGHTLY_VERSION</code> defined in <code>hermit.hcl</code> and updated via <code>rustup install</code>.</li> <li>Hermit binaries defined in <code>$REPO_ROOT/bin/XXX.pkg</code>, and updated via <code>hermit install</code>.</li> </ol>"},{"location":"internals/repository-structure/","title":"Repository Structure","text":"<p>This repository is split into multiple projects at the root folder. Each project has its own dependencies and tools used to build, test, and ship different parts of the repository. For example, a Rust environment for the compiler, a Python environment for documentation, and a NodeJS environment for linters. This allows us to implement different binaries, APIs, and internal tools/scripts, and package/version them together, while having minimal inter-dependencies.</p> <p>All dependencies should have exact full versions, and we can rely on tooling to automatically upgrade it over time. It allows us to have perfectly reproducible builds for every commit, a critical aspect for compilers, and developer tools in general.</p>"},{"location":"internals/repository-structure/#directory-structure","title":"Directory Structure","text":"<p>Currently, the repository has the following projects:</p> <ul> <li><code>.changeset/</code>: pending user visible changes not released yet.</li> <li><code>.devcontainer/</code>: self-contained Docker image to develop, build, test, and publish.</li> <li><code>crates/</code>:<ul> <li><code>infra/</code>: contains the CLI used for development, and utilities to build/test/run/debug all other projects.</li> <li><code>codegen/</code>: language analysis APs that convert input crates to output crates below.</li> <li><code>solidity/</code>:<ul> <li><code>inputs/</code>: Solidity language definition.</li> <li><code>outputs/</code>: different packages and artifacts produced from it.</li> </ul> </li> </ul> </li> <li><code>documentation/</code>: mkdocs site to render project documentation.</li> </ul>"},{"location":"internals/design-docs/","title":"Design Docs","text":"<ul> <li>Language Definition v2</li> </ul>"},{"location":"internals/design-docs/language-definition-v2/","title":"Language Definition v2","text":"<p>This document describes the new language definition model (AKA DSL v2), and the features/possibilities it enables for both syntax and semantic analysis. Each section describes a part of the definition model, and how it can affect the scanner, parser, CST, and AST.</p> <p>This is a collection of different discussions we had over the last few weeks, and can (and should) be broken down into smaller work items if needed. It should be possible to map the current definition to the old one, so that we do incremental progress, instead of rewriting everything at once.</p>"},{"location":"internals/design-docs/language-definition-v2/#cst","title":"CST","text":"<p>We currently produce an untyped tree of nodes. It holds all parts of the input (byte for byte), even whitespace, comments, and unrecognized (skipped) parts. We can reconstruct the original input back from the CST, just by iterating on nodes in order. For memory/performance reasons, we don't hold positions/location information in the tree, but they are calculated during iterating/visiting the tree.</p> <p>The CST is useful for many use cases:</p> <ul> <li>Tools that only want to deal with document contents, like formatters, and syntax-only linters.</li> <li>For visitors/rewriters that want to run on certain nodes, regardless of their position/parent types.</li> <li>Reconstructing the original input, including trivia/whitespace, and any skipped (unrecognized) parts.</li> </ul> <p>Here is an example of the node type, similar to what we have now:</p> <pre><code>pub enum Node {\n    Terminal { node: Rc&lt;TerminalNode&gt; },\n    Nonterminal { node: Rc&lt;NonterminalNode&gt; },\n}\n\npub struct TerminalNode {\n    pub kind: TerminalKind,\n    pub text: String,\n}\n\npub struct NonterminalNode {\n    pub kind: NonterminalKind,\n    pub text_length: TextIndex,\n    pub children: Vec&lt;Node&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#ast","title":"AST","text":"<p>We intend to also produce a strongly typed tree (structs and enums). Having strong types provides safety/correctness guarantees for users. It also allows us to generate visitor and rewriter APIs automatically.</p> <p>Each AST node should provide an API to get the underlying CST node, where users can iterate over the actual terminals as they appear in input, and get their position in the source code. However, this is a one-way operation. CST nodes don't hold references to their AST nodes.</p> <p>Note: some compilers drop syntactic elements that don't carry semantic information from their AST (like semicolons, or commas). However, we don't make that distinction, as we intend to implement further analysis in the form of micro-passes, that each can rewrite and pick parts of the tree that are relevant to them. So our initial tree (AST) should be complete.</p>"},{"location":"internals/design-docs/language-definition-v2/#versioning","title":"Versioning","text":"<p>The biggest benefit of the new language definition is that it allows scanners and parsers to attempt parsing input belonging to any language version, and report errors afterwards if the input is not valid for the selected version. This is a huge benefit over existing parsers, where they will either parse an inaccurate superset of all versions, or they parse a specific version, and produce unhelpful errors like <code>Unrecognized 'abstract' keyword</code> when the current language version doesn't support it.</p> <p>Not only we will be able to recover from such errors and continue parsing, producing an accurate/complete tree at the end, but we will also be able to produce much better errors like: <code>The 'abstract' keyword is not supported in the current version X. Please upgrade to version Y instead to be able to use it</code>.</p>"},{"location":"internals/design-docs/language-definition-v2/#terminals","title":"Terminals","text":""},{"location":"internals/design-docs/language-definition-v2/#token-items","title":"Token Items","text":"<p>Tokens consist of one or more <code>TokenDefinition</code>. Each definition is separate/unique, but produces the same <code>TerminalKind</code>. This is useful for tokens like <code>DecimalLiteral</code> and <code>HexLiteral</code> who can have multiple forms, but each form is enabled or disabled in certain versions of the language.</p> <p>All definitions have a unique <code>Scanner</code>, and they can be combined in the same trie/FSM to produce a single token at each position in the input. Afterwards, the scanner can compare the definition's <code>enabled</code> property with the current language version, adding an error if they don't match, but continue parsing anyway.</p>"},{"location":"internals/design-docs/language-definition-v2/#keyword-items","title":"Keyword Items","text":"<p>Keywords also contribute a <code>TerminalKind</code>, and consist of one or more <code>KeywordDefinition</code>. But they have additional semantics:</p> <p>First, instead of defining a regular <code>Scanner</code>, it defines a <code>KeywordValue</code> that produces a finite set of possibilities. Most only produce one value (like <code>abstract</code> or <code>contract</code>), but some can produce multiple, like <code>bytesN</code> or <code>fixedMxN</code>, that can have different values for <code>M</code> and <code>N</code>. This is important for us to build hash sets and quickly check for membership.</p> <p>Second, because keywords can also overlap with identifiers, each keyword has an <code>identifier</code> property that refers to which identifier token they can match. Instead of being part of same trie/FSM as tokens, whenever we want to scan a keyword, we try to scan its identifier instead. Afterwards, we check if its contents match one of the values of the keyword.</p> <p>Third, they have two additional <code>reserved</code> property. We should use these when we scan identifiers, to make sure that the resulting identifier doesn't match a reserved keyword, and if so, we should report an error, but continue parsing.</p> <p>Unique to Solidity, keywords can be <code>reserved</code> in versions before or after the versions they are <code>enabled</code> in. They can also be not <code>reserved</code> in versions before or after the versions they stop being <code>enabled</code> in. So we have to have these additional checks, to be able to catch cases like when a certain input can both be a keyword and an identifier, or neither.</p> <p>We should also be able to generate a public API <code>is_keyword(TerminalKind)</code> for users to conveniently detect them if needed.</p>"},{"location":"internals/design-docs/language-definition-v2/#trivia-items","title":"Trivia Items","text":"<p>Trivia items are similar tokens, contributing their own <code>TerminalKind</code>. They are referred to from the language's top-level <code>leading_trivia</code> and <code>trailing_trivia</code> properties. Before and after each token, the scanner should try to scan these tokens, collecting them in a flat list.</p> <p>Previously, we used to create many <code>LeadingTrivia</code> and <code>TrailingTrivia</code> nodes that hold whitespace/comments. Not only this is wasteful memory-wise, it is also unnatural/unexpected to wrap whitespace in nonterminal nodes. Instead, I propose treating them like any other token, and storing them as siblings to the tokens they belong to (in-order). Not only this is simpler, it is also more efficient, and is natural to how input is consumed and produced.</p>"},{"location":"internals/design-docs/language-definition-v2/#fragment-items","title":"Fragment Items","text":"<p>Fragments are not visible to users, and don't contribute a <code>TerminalKind</code>. They are just a utility used to refactor common parts of the grammar, and avoid duplication. During processing the language definition, they are inlined wherever they are referenced.</p>"},{"location":"internals/design-docs/language-definition-v2/#nonterminals","title":"Nonterminals","text":""},{"location":"internals/design-docs/language-definition-v2/#struct-items","title":"Struct Items","text":"<p>Structs represent a flat list (sequence) of typed fields. They are the simplest nonterminal, and generate a <code>struct</code> AST type. Their fields match 1-1 with the item fields. The struct name contributes a <code>NonterminalKind</code>.</p> <p>Each field can be either <code>Required(T)</code> or <code>Optional(T)</code>. Required fields are always present and parsed. Optional fields can be omitted if they don't exist, and are represented with Rust's <code>Option&lt;T&gt;</code> type (or TypeScript <code>T | undefined</code>). However, optional fields have an additional <code>enabled</code> property. After parsing optional fields, we should compare them with the current language version, and produce errors if they don't match, but continue parsing normally.</p> <p>The type of each field can be a <code>Nonterminal(T)</code> or <code>Terminal(Set&lt;T&gt;)</code>. A nonterminal field refers to another item, and holds its type. A terminal field refers to one or more terminal items (all valid in this position), and is of type <code>TerminalNode</code>.</p> <p>Additionally, the struct also stores the CST node that holds its contents:</p> Definition<pre><code>Struct(\n    name = ParametersDeclaration,\n    fields = (\n        open_paren = Required(Terminal([OpenParen])),\n        parameters = Required(Nonterminal(Parameters)),\n        close_paren = Required(Terminal([CloseParen]))\n    )\n)\n</code></pre> AST Type<pre><code>pub struct ParametersDeclaration {\n    pub open_paren: Rc&lt;TerminalNode&gt;,\n    pub parameters: Rc&lt;Parameters&gt;,\n    pub close_paren: Rc&lt;TerminalNode&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#enum-items","title":"Enum Items","text":"<p>Enums represent an ordered choice operator of multiple variants (possibilities). The enum name itself does NOT contribute a <code>NonterminalKind</code>, since it will always result in one of its variants (each with a unique <code>TerminalKind</code> or a <code>NonterminalKind</code>. They only exist in the AST, and don't affect the CST at all.</p> <p>We attempt to parse each variant (in-order), and choose the first one that succeeds. However, each variant can have an additional <code>enabled</code> property. We should always try to parse the variants that are valid in the current version first, and if not, still parse the rest, but produce an error afterwards. The fields of each variant are parsed similar to a struct fields (example above).</p> Definition<pre><code>Enum(\n    name = FunctionBody,\n    variants = [\n        EnumVariant(name = Block, reference = Block),\n        EnumVariant(name = Semicolon, reference = Semicolon)\n    ]\n)\n</code></pre> AST Type<pre><code>pub enum FunctionBody {\n    Block {\n        block: Rc&lt;Block&gt;,\n\n        cst: Rc&lt;NonterminalNode&gt;,\n    },\n    Semicolon {\n        semicolon: Rc&lt;TerminalNode&gt;,\n\n        cst: Rc&lt;NonterminalNode&gt;,\n    },\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#repeated-items","title":"Repeated Items","text":"<p>Repeated items represent a list of items of the same kind. The item name contributes a <code>NonterminalKind</code>. The AST type is a wrapper around a <code>Vec&lt;T&gt;</code>, with any utilities we need to add for convenience.</p> <p>It has an <code>allow_empty</code> boolean property, which allows parsing zero items. If it is <code>false</code>, we should still allow parsing zero items, but produce an error afterwards.</p> Definition<pre><code>Repeated(\n    name = FunctionAttributes,\n    repeated = FunctionAttribute,\n    allow_empty = true\n)\n</code></pre> AST Type<pre><code>pub struct FunctionAttributes {\n    pub items: Vec&lt;Rc&lt;FunctionAttribute&gt;&gt;\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#separated-items","title":"Separated Items","text":"<p>Separated items represent a list of items of the same kind, separated by a delimiter. The item name contributes a <code>NonterminalKind</code>. The AST type is a wrapper around two <code>Vec&lt;T&gt;</code> for items and their delimiters, with any utilities we need to add for convenience. For example, we should add APIs to create iterators for only the separated items, the separators, or both (in-order).</p> <p>It has an <code>allow_empty</code> boolean property, which allows parsing zero items. If it is <code>false</code>, we should still allow parsing zero items, but produce an error afterwards. We should also allow parsing a trailing separator at the end, but still produce an error afterwards.</p> Definition<pre><code>Separated(\n    name = EventParameters,\n    separated = EventParameter,\n    separator = Comma,\n    allow_empty = true\n)\n</code></pre> AST Type<pre><code>pub struct EventParameters {\n    pub items: Vec&lt;Rc&lt;EventParameter&gt;&gt;\n    pub separators: Vec&lt;Rc&lt;TerminalNode&gt;&gt;\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#precedence-items","title":"Precedence Items","text":"<p>This is perhaps the most complex nonterminal. It still uses the same PRATT algorithm from the previous implementation (no changes there), but adapted for the new AST types. It has two lists:</p> <p>First, a list of <code>precedence_expressions</code>, with each expression having a list of operators. Each operator has its own versioning (<code>enabled</code> property), a list of fields, and a model (prefix/postfix/binary).</p> <p>The operators from all expressions are flattened and combined in the parent PRATT parser. That grouping is only used to indicate that some operators can produce the same <code>PrecedenceExpression</code> name. However, we should exclude operators that don't match the current language version. This is useful for things like <code>ExponentiationExpression</code> where it has two operators with different associativity, but defined in enabled/disabled in different versions.</p> <p>Second, a list of <code>primary_expressions</code>, with their own versioning (<code>enabled</code> property) as well. We should try to parse them as an operator (similar to <code>EnumItem</code>), and produce an error if the version doesn't match afterwards.</p> <p>It is important to note that the item name doesn't contribute a <code>NonterminalKind</code>, but each <code>PrecedenceExpression</code> under it contributes one.</p> Definition<pre><code>Precedence(\n    name = Expression,\n    precedence_expressions = [\n        PrecedenceExpression(\n            name = AdditionExpression,\n            operators = [PrecedenceOperator(\n                model = BinaryLeftAssociative,\n                fields = (operator = Required(Terminal([Plus])))\n            )]\n        ),\n        PrecedenceExpression(\n            name = FunctionCallExpression,\n            operators = [PrecedenceOperator(\n                model = Postfix,\n                fields = (\n                    open_paren = Required(Terminal([OpenParen])),\n                    arguments = Required(Nonterminal(Arguments)),\n                    close_paren = Required(Terminal([CloseParen]))\n                )\n            )]\n        ),\n        PrecedenceExpression(\n            name = NegationExpression,\n            operators = [PrecedenceOperator(\n                model = Prefix,\n                fields = (operator = Required(Terminal([Not])))\n            )]\n        )\n    )],\n    primary_expressions = [\n        PrimaryExpression(expression = Identifier),\n        PrimaryExpression(expression = NumberLiteral),\n        PrimaryExpression(expression = StringLiteral)\n    ]\n)\n</code></pre> AST Type<pre><code>pub enum Expression {\n    AdditionExpression { expression: Rc&lt;AdditionExpression&gt; },\n    FunctionCallExpression { expression: Rc&lt;FunctionCallExpression&gt; },\n    NegationExpression { expression: Rc&lt;NegationExpression&gt; },\n\n    Identifier { expression: Rc&lt;TerminalNode&gt; },\n    NumberLiteral { expression: Rc&lt;TerminalNode&gt; },\n    StringLiteral { expression: Rc&lt;TerminalNode&gt; },\n}\n\npub struct AdditionExpression {\n    // 'left_operand' auto-generated (before) because it is a binary expression, and same type as parent\n    pub left_operand: Rc&lt;Expression&gt;,\n    // operator 'fields' are flattened into the expression node here\n    pub operator: Rc&lt;TerminalNode&gt;,\n    // 'right_operand' auto-generated (after) because it is a binary expression, and same type as parent\n    pub right_operand: Rc&lt;Expression&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n\npub struct FunctionCallExpression {\n    // 'operand' auto-generated (before) because it is a postfix expression, and same type as parent\n    pub operand: Rc&lt;Expression&gt;,\n    // operator 'fields' are flattened into the expression node here\n    pub open_paren: Rc&lt;TerminalNode&gt;,\n    pub arguments: Rc&lt;Arguments&gt;,\n    pub close_paren: Rc&lt;TerminalNode&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n\npub struct NegationExpression {\n    // operator 'fields' are flattened into the expression node here\n    pub operator: Rc&lt;TerminalNode&gt;,\n    // 'operand' auto-generated (after) because it is a prefix expression, and same type as parent\n    pub operand: Rc&lt;Expression&gt;,\n\n    pub cst: Rc&lt;NonterminalNode&gt;,\n}\n</code></pre>"},{"location":"internals/design-docs/language-definition-v2/#error-recovery","title":"Error Recovery","text":"<p>For the CST, I think the current algorithms work well, and we should be able to keep them. Unrecognized (skipped) input is grouped into one token, and we can just add it as-is to the <code>cst</code> node under its AST node.</p> <p>During AST construction, we will simply check for <code>TerminalKind::UNRECOGNIZED</code> nodes, and skip construction if there are any.</p>"},{"location":"internals/design-docs/language-definition-v2/#public-api-changes","title":"Public API Changes","text":"<p>Based on the above, I propose the following changes to the current public API:</p> <ul> <li>Rename <code>TokenKind</code> to <code>TerminalKind</code>, since it will also refer to trivia.</li> <li>Rename <code>RuleKind</code> to <code>NonterminalKind</code>, since \"rule\" is ambiguous.</li> <li>Rename <code>TerminalKind::SKIPPED</code>to <code>UNRECOGNIZED</code> for clarity.</li> <li>Hide <code>LexicalContext</code> and <code>fn scan(TokenKind)</code> from the public API, as it is a short-term workaround,   and will be replaced later when we have language embedding.</li> <li>Remove <code>ProductionKind</code> completely, since it is no longer needed. We only need to expose <code>fn parse(NonterminalKind)</code>.</li> <li>Since <code>EndOFFileTrivia</code> no longer exists, <code>ParseResult</code> should collect any remaining trivia at the end of the input,   and include it in the <code>ParseResult</code> returned, for any kind of node, not just <code>SourceUnit</code>.</li> </ul>"},{"location":"internals/design-docs/language-definition-v2/#visitors-and-cursors","title":"Visitors and Cursors","text":"<p>The current CST visitors/cursors should still work as-is, since the CST tree will be unchanged. However, the new AST types allow us in the future to produce typed visitors and traits with named functions for every node type, similar to a lot of other AST processing libraries. I want to at least produce an immutable <code>Visitor</code> and a mutable <code>Rewriter</code>.</p>"},{"location":"solidity-grammar/","title":"Solidity Grammar","text":""},{"location":"solidity-grammar/#solidity-grammar","title":"Solidity Grammar","text":"<ul> <li>Supported Versions</li> <li>1. File Structure</li> <li>2. Definitions</li> <li>3. Types</li> <li>4. Statements</li> <li>5. Expressions</li> <li>6. Yul</li> </ul>"},{"location":"solidity-grammar/supported-versions/","title":"Supported Versions","text":"<p>This grammar compiles information from 83 publicly released versions of Solidity:</p> <p><code>0.4.11</code> <code>0.4.12</code> <code>0.4.13</code> <code>0.4.14</code> <code>0.4.15</code> <code>0.4.16</code> <code>0.4.17</code> <code>0.4.18</code> <code>0.4.19</code> <code>0.4.20</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.23</code> <code>0.4.24</code> <code>0.4.25</code> <code>0.4.26</code> <code>0.5.0</code> <code>0.5.1</code> <code>0.5.2</code> <code>0.5.3</code> <code>0.5.4</code> <code>0.5.5</code> <code>0.5.6</code> <code>0.5.7</code> <code>0.5.8</code> <code>0.5.9</code> <code>0.5.10</code> <code>0.5.11</code> <code>0.5.12</code> <code>0.5.13</code> <code>0.5.14</code> <code>0.5.15</code> <code>0.5.16</code> <code>0.5.17</code> <code>0.6.0</code> <code>0.6.1</code> <code>0.6.2</code> <code>0.6.3</code> <code>0.6.4</code> <code>0.6.5</code> <code>0.6.6</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.9</code> <code>0.6.10</code> <code>0.6.11</code> <code>0.6.12</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.2</code> <code>0.7.3</code> <code>0.7.4</code> <code>0.7.5</code> <code>0.7.6</code> <code>0.8.0</code> <code>0.8.1</code> <code>0.8.2</code> <code>0.8.3</code> <code>0.8.4</code> <code>0.8.5</code> <code>0.8.6</code> <code>0.8.7</code> <code>0.8.8</code> <code>0.8.9</code> <code>0.8.10</code> <code>0.8.11</code> <code>0.8.12</code> <code>0.8.13</code> <code>0.8.14</code> <code>0.8.15</code> <code>0.8.16</code> <code>0.8.17</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.20</code> <code>0.8.21</code> <code>0.8.22</code> <code>0.8.23</code> <code>0.8.24</code> <code>0.8.25</code> <code>0.8.26</code> <code>0.8.27</code> <code>0.8.28</code></p> <p>Among which, 29 versions have breaking changes:</p> <p><code>0.4.11</code> <code>0.4.14</code> <code>0.4.16</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.25</code> <code>0.5.0</code> <code>0.5.3</code> <code>0.5.5</code> <code>0.5.8</code> <code>0.5.10</code> <code>0.5.14</code> <code>0.6.0</code> <code>0.6.2</code> <code>0.6.5</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.11</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.4</code> <code>0.8.0</code> <code>0.8.4</code> <code>0.8.8</code> <code>0.8.13</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.22</code> <code>0.8.27</code></p>"},{"location":"solidity-grammar/01-file-structure/","title":"1. File Structure","text":""},{"location":"solidity-grammar/01-file-structure/#1-file-structure","title":"1. File Structure","text":"<ul> <li>1.1. License Specifiers</li> <li>1.2. Source Unit</li> <li>1.3. Pragma Directives</li> <li>1.4. Import Directives</li> <li>1.5. Using Directives</li> <li>1.6. Trivia</li> <li>1.7. Nat Spec Format</li> <li>1.8. Keywords</li> <li>1.9. Punctuation</li> </ul>"},{"location":"solidity-grammar/01-file-structure/01-license-specifiers/","title":"1.1. License Specifiers","text":""},{"location":"solidity-grammar/01-file-structure/01-license-specifiers/#11-license-specifiers","title":"1.1. License Specifiers","text":""},{"location":"solidity-grammar/01-file-structure/01-license-specifiers/#license-comment","title":"License Comment","text":"<p>This comment line declares that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default. The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\n</code></pre> <p>When omitted, the compiler produces a warning to add one. The compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the metadata.</p> <p>If you do not want to specify a license or if the source code is not open-source, please use the special value <code>UNLICENSED</code>. Note that <code>UNLICENSED</code> (no usage allowed, not present in SPDX license list) is different from <code>UNLICENSE</code> (grants all rights to everyone).</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/02-source-unit/","title":"1.2. Source Unit","text":""},{"location":"solidity-grammar/01-file-structure/02-source-unit/#12-source-unit","title":"1.2. Source Unit","text":""},{"location":"solidity-grammar/01-file-structure/02-source-unit/#syntax","title":"Syntax","text":"<pre>SourceUnit = (* members: *) SourceUnitMembers;</pre> <pre></pre> <pre>SourceUnitMembers = (* item: *) SourceUnitMember*;</pre> <pre></pre> <pre>SourceUnitMember = (* variant: *) PragmaDirective                 | (* variant: *) ImportDirective                 | (* variant: *) ContractDefinition                 | (* variant: *) InterfaceDefinition                 | (* variant: *) LibraryDefinition                 | (* variant: *) StructDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) EnumDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) FunctionDefinition (* Introduced in 0.7.1 *)                 | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)                 | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)                 | (* variant: *) UsingDirective (* Introduced in 0.8.13 *)                 | (* variant: *) EventDefinition (* Introduced in 0.8.22 *)                 | (* variant: *) ConstantDefinition; (* Introduced in 0.7.4 *)</pre>"},{"location":"solidity-grammar/01-file-structure/02-source-unit/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/","title":"1.3. Pragma Directives","text":""},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#13-pragma-directives","title":"1.3. Pragma Directives","text":""},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#syntax","title":"Syntax","text":"<pre>PragmaDirective = (* pragma_keyword: *) PRAGMA_KEYWORD                  (* pragma: *) Pragma                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>Pragma = (* variant: *) AbicoderPragma       | (* variant: *) ExperimentalPragma       | (* variant: *) VersionPragma;</pre> <pre></pre> <pre>AbicoderPragma = (* abicoder_keyword: *) ABICODER_KEYWORD                 (* version: *) IDENTIFIER;</pre> <pre></pre> <pre>ExperimentalPragma = (* experimental_keyword: *) EXPERIMENTAL_KEYWORD                     (* feature: *) ExperimentalFeature;</pre> <pre></pre> <pre>ExperimentalFeature = (* variant: *) IDENTIFIER                    | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>VersionPragma = (* solidity_keyword: *) SOLIDITY_KEYWORD                (* sets: *) VersionExpressionSets;</pre> <pre></pre> <pre>VersionExpressionSets = (* item: *) VersionExpressionSet ((* separator: *) BAR_BAR (* item: *) VersionExpressionSet)*;</pre> <pre></pre> <pre>VersionExpressionSet = (* item: *) VersionExpression+;</pre> <pre></pre> <pre>VersionExpression = (* variant: *) VersionRange                  | (* variant: *) VersionTerm;</pre> <pre></pre> <pre>VersionRange = (* start: *) VersionLiteral               (* minus: *) MINUS               (* end: *) VersionLiteral;</pre> <pre></pre> <pre>VersionTerm = (* operator: *) VersionOperator?              (* literal: *) VersionLiteral;</pre> <pre></pre> <pre>VersionOperator = (* variant: *) CARET                | (* variant: *) TILDE                | (* variant: *) EQUAL                | (* variant: *) LESS_THAN                | (* variant: *) GREATER_THAN                | (* variant: *) LESS_THAN_EQUAL                | (* variant: *) GREATER_THAN_EQUAL;</pre> <pre></pre> <pre>VersionLiteral = (* variant: *) SimpleVersionLiteral               | (* variant: *) SINGLE_QUOTED_VERSION_LITERAL               | (* variant: *) DOUBLE_QUOTED_VERSION_LITERAL;</pre> <pre></pre> <pre>SimpleVersionLiteral = (* item: *) VERSION_SPECIFIER ((* separator: *) PERIOD (* item: *) VERSION_SPECIFIER)*;</pre> <pre></pre> <pre>VERSION_SPECIFIER = \u00abVERSION_SPECIFIER_FRAGMENT\u00bb;</pre> <pre></pre> <pre>SINGLE_QUOTED_VERSION_LITERAL = \"'\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_VERSION_LITERAL = '\"' \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* '\"';</pre> <pre></pre> <pre>\u00abVERSION_SPECIFIER_FRAGMENT\u00bb = (\"0\"\u2026\"9\" | \"x\" | \"X\" | \"*\")+;</pre> <pre></pre> <pre>(* Never reserved *)ABICODER_KEYWORD = \"abicoder\";</pre> <pre></pre> <pre>(* Never reserved *)EXPERIMENTAL_KEYWORD = \"experimental\";</pre> <pre></pre> <pre>(* Never reserved *)SOLIDITY_KEYWORD = \"solidity\";</pre>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#version-pragma","title":"Version Pragma","text":"<p>This line declares which Solidity language version it was written for. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. An error is produced if the running compiler version does not match these requirements.</p> <p>Note that multiple version pragmas are supported, and the compiler will verify each pragma separately.</p> <p>For example, this line specifies that the source code is written for Solidity version <code>0.4.16</code>, or a newer version of the language up to, but not including version <code>0.9.0</code>:</p> <pre><code>pragma solidity &gt;=0.4.16 &lt;0.9.0;\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#abi-coder-pragma","title":"ABI Coder Pragma","text":"<p>Used to instruct the compiler to choose a specific ABI encoder/decoder. The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. It might produce less optimal code and has not received as much testing as the old encoder.</p> <pre><code>pragma abicoder v1;\n// OR\npragma abicoder v2;\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#experimental-pragma","title":"Experimental Pragma","text":"<p>It can be used to enable features of the compiler or language that are not yet enabled by default. Compilers should produce an error on unrecognized pragmas (or earlier versions before they were released), and a warning before the stable version. After the stable version, this should not have an effect.</p>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#abiencoderv2","title":"ABIEncoderV2","text":"<p>Please see the <code>abicoder</code> pragma defined above.</p> <pre><code>pragma experimental ABIEncoderV2;\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/03-pragma-directives/#smtchecker","title":"SMTChecker","text":"<p>If you use <code>SMTChecker</code>, then you get additional safety warnings which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound.</p> <pre><code>pragma experimental SMTChecker;\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/04-import-directives/","title":"1.4. Import Directives","text":""},{"location":"solidity-grammar/01-file-structure/04-import-directives/#14-import-directives","title":"1.4. Import Directives","text":""},{"location":"solidity-grammar/01-file-structure/04-import-directives/#syntax","title":"Syntax","text":"<pre>ImportDirective = (* import_keyword: *) IMPORT_KEYWORD                  (* clause: *) ImportClause                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ImportClause = (* variant: *) PathImport             | (* variant: *) NamedImport             | (* variant: *) ImportDeconstruction;</pre> <pre></pre> <pre>PathImport = (* path: *) StringLiteral             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>NamedImport = (* asterisk: *) ASTERISK              (* alias: *) ImportAlias              (* from_keyword: *) FROM_KEYWORD              (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstruction = (* open_brace: *) OPEN_BRACE                       (* symbols: *) ImportDeconstructionSymbols                       (* close_brace: *) CLOSE_BRACE                       (* from_keyword: *) FROM_KEYWORD                       (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstructionSymbols = (* item: *) ImportDeconstructionSymbol ((* separator: *) COMMA (* item: *) ImportDeconstructionSymbol)*;</pre> <pre></pre> <pre>ImportDeconstructionSymbol = (* name: *) IDENTIFIER                             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>ImportAlias = (* as_keyword: *) AS_KEYWORD              (* identifier: *) IDENTIFIER;</pre>"},{"location":"solidity-grammar/01-file-structure/04-import-directives/#importing-files","title":"Importing Files","text":"<p>At a file level, you can use import statements of the following form:</p> <pre><code>import \"filename\";\n</code></pre> <p>This statement imports all global symbols from <code>filename</code> (and symbols imported there) into the current global scope. This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside <code>filename</code>, they automatically appear in all files that import like this from \u201cfilename\u201d. It is better to import specific symbols explicitly, which results in all global symbols being available under the <code>myFile</code> symbol:</p> <pre><code>import * as myFile from \"filename\";\n// OR\nimport \"filename\" as myFile;\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/04-import-directives/#importing-specific-symbols","title":"Importing Specific Symbols","text":"<p>You can import only the symbols you use from a specific file, using the syntax:</p> <pre><code>import {symbol1, symbol2} from \"filename\";\n</code></pre> <p>Which will create <code>symbol1</code> and <code>symbol1</code> to use in your code. If there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols <code>alias</code> and <code>symbol2</code> which reference <code>symbol1</code> and <code>symbol2</code> from inside <code>filename</code>, respectively:</p> <pre><code>import {symbol1 as alias, symbol2} from \"filename\";\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/04-import-directives/#virtual-file-system","title":"Virtual File System","text":"<p>In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (virtual filesystem or VFS for short) where each source unit is assigned a unique source unit name which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database.</p> <ul> <li>Using the <code>solc</code> binary CLI, you can pass disk file system paths to be used.</li> <li>Using the <code>solc</code> JSON API, you can pass the explicit file contents to be parsed.</li> <li>Using other tools like the Remix IDE you can import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry.</li> </ul> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/05-using-directives/","title":"1.5. Using Directives","text":""},{"location":"solidity-grammar/01-file-structure/05-using-directives/#15-using-directives","title":"1.5. Using Directives","text":""},{"location":"solidity-grammar/01-file-structure/05-using-directives/#syntax","title":"Syntax","text":"<pre>UsingDirective = (* using_keyword: *) USING_KEYWORD                 (* clause: *) UsingClause                 (* for_keyword: *) FOR_KEYWORD                 (* target: *) UsingTarget                 (* global_keyword: *) GLOBAL_KEYWORD? (* Introduced in 0.8.13 *)                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>UsingClause = (* variant: *) IdentifierPath            | (* variant: *) UsingDeconstruction; (* Introduced in 0.8.13 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstruction = (* open_brace: *) OPEN_BRACE                      (* symbols: *) UsingDeconstructionSymbols                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbols = (* item: *) UsingDeconstructionSymbol ((* separator: *) COMMA (* item: *) UsingDeconstructionSymbol)*;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbol = (* name: *) IdentifierPath                            (* alias: *) UsingAlias?; (* Introduced in 0.8.19 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingAlias = (* as_keyword: *) AS_KEYWORD             (* operator: *) UsingOperator;</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingOperator = (* variant: *) AMPERSAND              | (* variant: *) ASTERISK              | (* variant: *) BANG_EQUAL              | (* variant: *) BAR              | (* variant: *) CARET              | (* variant: *) EQUAL_EQUAL              | (* variant: *) GREATER_THAN              | (* variant: *) GREATER_THAN_EQUAL              | (* variant: *) LESS_THAN              | (* variant: *) LESS_THAN_EQUAL              | (* variant: *) MINUS              | (* variant: *) PERCENT              | (* variant: *) PLUS              | (* variant: *) SLASH              | (* variant: *) TILDE;</pre> <pre></pre> <pre>UsingTarget = (* variant: *) TypeName            | (* variant: *) ASTERISK;</pre>"},{"location":"solidity-grammar/01-file-structure/05-using-directives/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/06-trivia/","title":"1.6. Trivia","text":""},{"location":"solidity-grammar/01-file-structure/06-trivia/#16-trivia","title":"1.6. Trivia","text":""},{"location":"solidity-grammar/01-file-structure/06-trivia/#syntax","title":"Syntax","text":"<pre>WHITESPACE = (\" \" | \"\\t\")+;</pre> <pre></pre> <pre>END_OF_LINE = \"\\n\" | (\"\\r\" \"\\n\"?);</pre> <pre></pre> <pre>SINGLE_LINE_COMMENT = \"//\" (?!\"/\") (!(\"\\r\" | \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_COMMENT = \"/*\" (?!\"*\" !\"/\") (!\"*\" | (\"*\" (?!\"/\")))* \"*/\";</pre> <pre></pre> <pre>SINGLE_LINE_NAT_SPEC_COMMENT = \"///\" (!(\"\\r\" | \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_NAT_SPEC_COMMENT = \"/**\" (?!\"/\") (!\"*\" | (\"*\" (?!\"/\")))* \"*/\";</pre>"},{"location":"solidity-grammar/01-file-structure/06-trivia/#single-line-comments","title":"Single Line Comments","text":"<p>A single-line comment is terminated by any unicode line terminator (<code>LF</code>, <code>VF</code>, <code>FF</code>, <code>CR</code>, <code>NEL</code>, <code>LS</code> or <code>PS</code>) in UTF-8 encoding. The terminator is still part of the source code after the comment, so if it is not an ASCII symbol (these are <code>NEL</code>, <code>LS</code> and <code>PS</code>), it will lead to a parser error.</p> <pre><code>// This is a single-line comment.\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/06-trivia/#multi-line-comments","title":"Multi-line Comments","text":"<p>Comments starting with <code>/*</code> and ending with <code>*/</code> are allowed to range multiple lines:</p> <pre><code>/*\nThis is a\nmulti-line comment.\n*/\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/06-trivia/#natspec-comments","title":"NatSpec Comments","text":"<p>Additionally, there is another type of comment called a NatSpec comment. They are written with a triple slash <code>///</code> or a double asterisk block <code>/**...*/</code> and they should be used directly above function declarations or statements. It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI).</p> <pre><code>/// @author My Team Name\n/// @title A simple contract example\ncontract MyContract {}\n</code></pre> <p>Please see the NatSpec Format section for further information.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/","title":"1.7. Nat Spec Format","text":""},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#17-nat-spec-format","title":"1.7. Nat Spec Format","text":""},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#what-is-natspec","title":"What is NatSpec?","text":"<p>Solidity contracts can use a special form of comments to provide rich documentation for functions, return variables and more. This special form is named the Ethereum Natural Language Specification Format (NatSpec). It was inspired by Doxygen, and while it uses Doxygen-style comments and tags, there is no intention to keep strict compatibility with Doxygen.</p> <p>It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is used in:</p> <ul> <li>Developer-focused output, for documenting, sharing, and reusing the source code.</li> <li>User-facing output, at the time that they will interact with the contract (i.e. sign a transaction).</li> <li>Machine-readable output, to be used by downstream tools.</li> </ul> <p>Documentation can be inserted above each <code>contract</code>, <code>interface</code>, <code>library</code>, <code>function</code>, <code>event</code> and <code>state variable</code>.</p> <p>They can either exist in a single line format, starting with <code>///</code>:</p> <pre><code>/// @title An example contract\ncontract MyContract {}\n</code></pre> <p>And also in multi-line format, starting with <code>/**</code> and ending with <code>*/</code>:</p> <pre><code>/**\n * @title An example contract\n */\ncontract MyContract {}\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#tags","title":"Tags","text":"<p>Tags categorize different comments according to their purpose. The table below shows the different tags supported. Please note that they are optional, and without one, the entire comment will be interpreted as it had a <code>@notice</code> tag.</p> Tag Description Context <code>@title</code> A title that should describe the contract/interface <code>contract</code>, <code>library</code>, <code>interface</code> <code>@author</code> The name of the author <code>contract</code>, <code>library</code>, <code>interface</code> <code>@notice</code> Explain to an end user what this does <code>contract</code>, <code>library</code>, <code>interface</code>, <code>function</code>, <code>event</code>, <code>state variable</code> <code>@dev</code> Explain to a developer any extra details <code>contract</code>, <code>library</code>, <code>interface</code>, <code>function</code>, <code>event</code>, <code>state variable</code> <code>@param</code> Documents a parameter just like in Doxygen (must be followed by parameter name) <code>function</code>, <code>event</code> <code>@return</code> Documents the return variables of a contract's function <code>function</code>, <code>state variable</code> <code>@inheritdoc</code> Copies all missing tags from the base function (must be followed by the contract name) <code>function</code>, <code>state variable</code> <code>@custom:FOO</code> Custom tag, semantics is application-defined can be used everywhere"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#function-return-types","title":"Function Return Types","text":"<p>If your function returns multiple values, like <code>(int quotient, int remainder)</code> then use multiple <code>@return</code> statements in the same format as the <code>@param</code> statements.</p>"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#custom-tags","title":"Custom Tags","text":"<p>Custom tags start with <code>@custom:</code> and must be followed by one or more lowercase letters or hyphens. It cannot start with a hyphen however. They can be used everywhere and are part of the developer documentation. For example, <code>@custom:foo</code> or <code>@custom:foo-bar</code>. A good use case is analysis and verification tools.</p>"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#dynamic-expressions","title":"Dynamic expressions","text":"<p>The Solidity compiler will pass through NatSpec documentation from your Solidity source code to the JSON output as described in this guide. The consumer of this JSON output may present this to the end-user directly or it may apply some pre-processing.</p> <p>Specifying these dynamic expressions is outside the scope of the Solidity documentation. However, you can find one useful example in the RadSpec Project, where it evaluates references to function inputs to its values. For example, this line:</p> <pre><code>/// @notice This function will multiply `a` by 7\n</code></pre> <p>Can be evaluated as the following, where the value of <code>a</code> is <code>10</code>:</p> <pre><code>This function will multiply 10 by 7\n</code></pre>"},{"location":"solidity-grammar/01-file-structure/07-nat-spec-format/#inheritance","title":"Inheritance","text":"<p>Functions without NatSpec will automatically inherit the documentation of their base function. Exceptions to this are:</p> <ul> <li>When the parameter names are different.</li> <li>When there is more than one base function.</li> <li>When there is an explicit <code>@inheritdoc</code> tag which specifies which contract should be used to inherit.</li> </ul> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/08-keywords/","title":"1.8. Keywords","text":""},{"location":"solidity-grammar/01-file-structure/08-keywords/#18-keywords","title":"1.8. Keywords","text":""},{"location":"solidity-grammar/01-file-structure/08-keywords/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.6.0 *)ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>(* Never reserved *)ADDRESS_KEYWORD = \"address\";</pre> <pre></pre> <pre>AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>(* Deprecated in 0.8.0 *)BYTE_KEYWORD = \"byte\";</pre> <pre></pre> <pre>BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>(* Introduced in 0.5.0 *)(* Reserved in 0.5.0 *)CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)(* Reserved in 0.5.0 *)CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)(* Reserved in 0.5.0 *)EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)ERROR_KEYWORD = \"error\";</pre> <pre></pre> <pre>ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>FIXED_KEYWORD = \"fixed\";FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>(* Never reserved *)FROM_KEYWORD = \"from\";</pre> <pre></pre> <pre>FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)(* Never reserved *)GLOBAL_KEYWORD = \"global\";</pre> <pre></pre> <pre>(* Introduced in 0.6.11 *)(* Reserved in 0.7.0 *)GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Introduced in 0.6.5 *)(* Reserved in 0.5.0 *)IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.5.0 *)OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>RETURN_KEYWORD = \"return\";</pre> <pre></pre> <pre>RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)REVERT_KEYWORD = \"revert\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)SUPER_KEYWORD = \"super\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)THIS_KEYWORD = \"this\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.8.27 *)(* Never reserved *)TRANSIENT_KEYWORD = \"transient\";</pre> <pre></pre> <pre>TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Introduced in 0.5.3 *)TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>UFIXED_KEYWORD = \"ufixed\";UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)(* Reserved in 0.5.0 *)UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.6.0 *)VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YEARS_KEYWORD = \"years\";</pre>"},{"location":"solidity-grammar/01-file-structure/08-keywords/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/01-file-structure/09-punctuation/","title":"1.9. Punctuation","text":""},{"location":"solidity-grammar/01-file-structure/09-punctuation/#19-punctuation","title":"1.9. Punctuation","text":""},{"location":"solidity-grammar/01-file-structure/09-punctuation/#syntax","title":"Syntax","text":"<pre>OPEN_PAREN = \"(\";</pre> <pre></pre> <pre>CLOSE_PAREN = \")\";</pre> <pre></pre> <pre>OPEN_BRACKET = \"[\";</pre> <pre></pre> <pre>CLOSE_BRACKET = \"]\";</pre> <pre></pre> <pre>OPEN_BRACE = \"{\";</pre> <pre></pre> <pre>CLOSE_BRACE = \"}\";</pre> <pre></pre> <pre>COMMA = \",\";</pre> <pre></pre> <pre>PERIOD = \".\";</pre> <pre></pre> <pre>QUESTION_MARK = \"?\";</pre> <pre></pre> <pre>SEMICOLON = \";\";</pre> <pre></pre> <pre>COLON = \":\";</pre> <pre></pre> <pre>COLON_EQUAL = \":=\";</pre> <pre></pre> <pre>EQUAL = \"=\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)EQUAL_COLON = \"=:\";</pre> <pre></pre> <pre>EQUAL_EQUAL = \"==\";</pre> <pre></pre> <pre>EQUAL_GREATER_THAN = \"=&gt;\";</pre> <pre></pre> <pre>ASTERISK = \"*\";</pre> <pre></pre> <pre>ASTERISK_EQUAL = \"*=\";</pre> <pre></pre> <pre>ASTERISK_ASTERISK = \"**\";</pre> <pre></pre> <pre>BAR = \"|\";</pre> <pre></pre> <pre>BAR_EQUAL = \"|=\";</pre> <pre></pre> <pre>BAR_BAR = \"||\";</pre> <pre></pre> <pre>AMPERSAND = \"&amp;\";</pre> <pre></pre> <pre>AMPERSAND_EQUAL = \"&amp;=\";</pre> <pre></pre> <pre>AMPERSAND_AMPERSAND = \"&amp;&amp;\";</pre> <pre></pre> <pre>LESS_THAN = \"&lt;\";</pre> <pre></pre> <pre>LESS_THAN_EQUAL = \"&lt;=\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN = \"&lt;&lt;\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN_EQUAL = \"&lt;&lt;=\";</pre> <pre></pre> <pre>GREATER_THAN = \"&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_EQUAL = \"&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN = \"&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN = \"&gt;&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;&gt;=\";</pre> <pre></pre> <pre>PLUS = \"+\";</pre> <pre></pre> <pre>PLUS_EQUAL = \"+=\";</pre> <pre></pre> <pre>PLUS_PLUS = \"++\";</pre> <pre></pre> <pre>MINUS = \"-\";</pre> <pre></pre> <pre>MINUS_EQUAL = \"-=\";</pre> <pre></pre> <pre>MINUS_MINUS = \"--\";</pre> <pre></pre> <pre>MINUS_GREATER_THAN = \"-&gt;\";</pre> <pre></pre> <pre>SLASH = \"/\" (?!\"*\" | \"/\" | \"=\");</pre> <pre></pre> <pre>SLASH_EQUAL = \"/=\";</pre> <pre></pre> <pre>PERCENT = \"%\";</pre> <pre></pre> <pre>PERCENT_EQUAL = \"%=\";</pre> <pre></pre> <pre>BANG = \"!\";</pre> <pre></pre> <pre>BANG_EQUAL = \"!=\";</pre> <pre></pre> <pre>CARET = \"^\";</pre> <pre></pre> <pre>CARET_EQUAL = \"^=\";</pre> <pre></pre> <pre>TILDE = \"~\";</pre>"},{"location":"solidity-grammar/01-file-structure/09-punctuation/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/","title":"2. Definitions","text":""},{"location":"solidity-grammar/02-definitions/#2-definitions","title":"2. Definitions","text":"<ul> <li>2.1. Contracts</li> <li>2.2. Interfaces</li> <li>2.3. Libraries</li> <li>2.4. Structs</li> <li>2.5. Enums</li> <li>2.6. Constants</li> <li>2.7. State Variables</li> <li>2.8. Functions</li> <li>2.9. Modifiers</li> <li>2.10. Events</li> <li>2.11. User Defined Value Types</li> <li>2.12. Errors</li> </ul>"},{"location":"solidity-grammar/02-definitions/01-contracts/","title":"2.1. Contracts","text":""},{"location":"solidity-grammar/02-definitions/01-contracts/#21-contracts","title":"2.1. Contracts","text":""},{"location":"solidity-grammar/02-definitions/01-contracts/#syntax","title":"Syntax","text":"<pre>ContractDefinition = (* abstract_keyword: *) ABSTRACT_KEYWORD? (* Introduced in 0.6.0 *)                     (* contract_keyword: *) CONTRACT_KEYWORD                     (* name: *) IDENTIFIER                     (* inheritance: *) InheritanceSpecifier?                     (* open_brace: *) OPEN_BRACE                     (* members: *) ContractMembers                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>InheritanceSpecifier = (* is_keyword: *) IS_KEYWORD                       (* types: *) InheritanceTypes;</pre> <pre></pre> <pre>InheritanceTypes = (* item: *) InheritanceType ((* separator: *) COMMA (* item: *) InheritanceType)*;</pre> <pre></pre> <pre>InheritanceType = (* type_name: *) IdentifierPath                  (* arguments: *) ArgumentsDeclaration?;</pre> <pre></pre> <pre>ContractMembers = (* item: *) ContractMember*;</pre> <pre></pre> <pre>ContractMember = (* variant: *) UsingDirective               | (* variant: *) FunctionDefinition               | (* variant: *) ConstructorDefinition (* Introduced in 0.4.22 *)               | (* variant: *) ReceiveFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) FallbackFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) UnnamedFunctionDefinition (* Deprecated in 0.6.0 *)               | (* variant: *) ModifierDefinition               | (* variant: *) StructDefinition               | (* variant: *) EnumDefinition               | (* variant: *) EventDefinition               | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)               | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)               | (* variant: *) StateVariableDefinition;</pre>"},{"location":"solidity-grammar/02-definitions/01-contracts/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/02-interfaces/","title":"2.2. Interfaces","text":""},{"location":"solidity-grammar/02-definitions/02-interfaces/#22-interfaces","title":"2.2. Interfaces","text":""},{"location":"solidity-grammar/02-definitions/02-interfaces/#syntax","title":"Syntax","text":"<pre>InterfaceDefinition = (* interface_keyword: *) INTERFACE_KEYWORD                      (* name: *) IDENTIFIER                      (* inheritance: *) InheritanceSpecifier?                      (* open_brace: *) OPEN_BRACE                      (* members: *) InterfaceMembers                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>InterfaceMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-grammar/02-definitions/02-interfaces/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/03-libraries/","title":"2.3. Libraries","text":""},{"location":"solidity-grammar/02-definitions/03-libraries/#23-libraries","title":"2.3. Libraries","text":""},{"location":"solidity-grammar/02-definitions/03-libraries/#syntax","title":"Syntax","text":"<pre>LibraryDefinition = (* library_keyword: *) LIBRARY_KEYWORD                    (* name: *) IDENTIFIER                    (* open_brace: *) OPEN_BRACE                    (* members: *) LibraryMembers                    (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>LibraryMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-grammar/02-definitions/03-libraries/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/04-structs/","title":"2.4. Structs","text":""},{"location":"solidity-grammar/02-definitions/04-structs/#24-structs","title":"2.4. Structs","text":""},{"location":"solidity-grammar/02-definitions/04-structs/#syntax","title":"Syntax","text":"<pre>StructDefinition = (* struct_keyword: *) STRUCT_KEYWORD                   (* name: *) IDENTIFIER                   (* open_brace: *) OPEN_BRACE                   (* members: *) StructMembers                   (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>StructMembers = (* item: *) StructMember*;</pre> <pre></pre> <pre>StructMember = (* type_name: *) TypeName               (* name: *) IDENTIFIER               (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/04-structs/#struct-types","title":"Struct Types","text":"<p>Structs are custom defined types that can group several variables. They can be defined inside or outside contracts.</p> <pre><code>struct Voter {\n    address delegate;\n    uint vote;\n}\n</code></pre> <p>You can also create new objects of this struct using the following syntax:</p> <pre><code>contract MyContract {\n    function create() public  {\n        Voter memory v = Voter({\n            delegate: msg.sender,\n            vote: 1\n        });\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/05-enums/","title":"2.5. Enums","text":""},{"location":"solidity-grammar/02-definitions/05-enums/#25-enums","title":"2.5. Enums","text":""},{"location":"solidity-grammar/02-definitions/05-enums/#syntax","title":"Syntax","text":"<pre>EnumDefinition = (* enum_keyword: *) ENUM_KEYWORD                 (* name: *) IDENTIFIER                 (* open_brace: *) OPEN_BRACE                 (* members: *) EnumMembers                 (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>EnumMembers = ((* item: *) IDENTIFIER ((* separator: *) COMMA (* item: *) IDENTIFIER)*)?;</pre>"},{"location":"solidity-grammar/02-definitions/05-enums/#enum-types","title":"Enum Types","text":"<p>Enums can be used to create custom types with a finite set of constant values. Enums can be declared on the file level, outside of contract or library definitions.</p> <pre><code>enum ActionChoices {\n    One,\n    Two\n}\n\ncontract MyContract {\n    function choose() public pure returns (ActionChoices) {\n        return ActionChoices.Two;\n    }\n}\n</code></pre> <p>Enums require at least one member, and its default value when declared is the first member. Enums cannot have more than 256 members.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/06-constants/","title":"2.6. Constants","text":""},{"location":"solidity-grammar/02-definitions/06-constants/#26-constants","title":"2.6. Constants","text":""},{"location":"solidity-grammar/02-definitions/06-constants/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.7.4 *)ConstantDefinition = (* type_name: *) TypeName                     (* constant_keyword: *) CONSTANT_KEYWORD                     (* name: *) IDENTIFIER                     (* equal: *) EQUAL                     (* value: *) Expression                     (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/06-constants/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/07-state-variables/","title":"2.7. State Variables","text":""},{"location":"solidity-grammar/02-definitions/07-state-variables/#27-state-variables","title":"2.7. State Variables","text":""},{"location":"solidity-grammar/02-definitions/07-state-variables/#syntax","title":"Syntax","text":"<pre>StateVariableDefinition = (* type_name: *) TypeName                          (* attributes: *) StateVariableAttributes                          (* name: *) IDENTIFIER                          (* value: *) StateVariableDefinitionValue?                          (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>StateVariableDefinitionValue = (* equal: *) EQUAL                               (* value: *) Expression;</pre> <pre></pre> <pre>StateVariableAttributes = (* item: *) StateVariableAttribute*;</pre> <pre></pre> <pre>StateVariableAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                       | (* variant: *) CONSTANT_KEYWORD                       | (* variant: *) INTERNAL_KEYWORD                       | (* variant: *) PRIVATE_KEYWORD                       | (* variant: *) PUBLIC_KEYWORD                       | (* variant: *) IMMUTABLE_KEYWORD (* Introduced in 0.6.5 *)                       | (* variant: *) TRANSIENT_KEYWORD; (* Introduced in 0.8.27 *)</pre>"},{"location":"solidity-grammar/02-definitions/07-state-variables/#state-variables","title":"State Variables","text":"<p>State variables are variables whose values are permanently stored in contract storage.</p> <pre><code>contract MyContract {\n    uint myStateVariable;\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/08-functions/","title":"2.8. Functions","text":""},{"location":"solidity-grammar/02-definitions/08-functions/#28-functions","title":"2.8. Functions","text":""},{"location":"solidity-grammar/02-definitions/08-functions/#syntax","title":"Syntax","text":"<pre>FunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                     (* name: *) FunctionName                     (* parameters: *) ParametersDeclaration                     (* attributes: *) FunctionAttributes                     (* returns: *) ReturnsDeclaration?                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>FunctionName = (* variant: *) IDENTIFIER             | (* variant: *) FALLBACK_KEYWORD             | (* variant: *) RECEIVE_KEYWORD;</pre> <pre></pre> <pre>ParametersDeclaration = (* open_paren: *) OPEN_PAREN                        (* parameters: *) Parameters                        (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>Parameters = ((* item: *) Parameter ((* separator: *) COMMA (* item: *) Parameter)*)?;</pre> <pre></pre> <pre>Parameter = (* type_name: *) TypeName            (* storage_location: *) StorageLocation?            (* name: *) IDENTIFIER?;</pre> <pre></pre> <pre>FunctionAttributes = (* item: *) FunctionAttribute*;</pre> <pre></pre> <pre>FunctionAttribute = (* variant: *) ModifierInvocation                  | (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                  | (* variant: *) EXTERNAL_KEYWORD                  | (* variant: *) INTERNAL_KEYWORD                  | (* variant: *) PAYABLE_KEYWORD                  | (* variant: *) PRIVATE_KEYWORD                  | (* variant: *) PUBLIC_KEYWORD                  | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverrideSpecifier = (* override_keyword: *) OVERRIDE_KEYWORD                    (* overridden: *) OverridePathsDeclaration?;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePathsDeclaration = (* open_paren: *) OPEN_PAREN                           (* paths: *) OverridePaths                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePaths = (* item: *) IdentifierPath ((* separator: *) COMMA (* item: *) IdentifierPath)*;</pre> <pre></pre> <pre>ReturnsDeclaration = (* returns_keyword: *) RETURNS_KEYWORD                     (* variables: *) ParametersDeclaration;</pre> <pre></pre> <pre>FunctionBody = (* variant: *) Block             | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorDefinition = (* constructor_keyword: *) CONSTRUCTOR_KEYWORD                        (* parameters: *) ParametersDeclaration                        (* attributes: *) ConstructorAttributes                        (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttributes = (* item: *) ConstructorAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttribute = (* variant: *) ModifierInvocation                     | (* variant: *) INTERNAL_KEYWORD                     | (* variant: *) OVERRIDE_KEYWORD (* Introduced in 0.6.0 and deprecated in 0.6.7. *)                     | (* variant: *) PAYABLE_KEYWORD                     | (* variant: *) PUBLIC_KEYWORD                     | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 and deprecated in 0.6.7. *)</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) UnnamedFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttributes = (* item: *) UnnamedFunctionAttribute*;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) INTERNAL_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) PRIVATE_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PUBLIC_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 and deprecated in 0.6.0. *)                         | (* variant: *) VIEW_KEYWORD; (* Introduced in 0.4.16 and deprecated in 0.6.0. *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionDefinition = (* fallback_keyword: *) FALLBACK_KEYWORD                             (* parameters: *) ParametersDeclaration                             (* attributes: *) FallbackFunctionAttributes                             (* returns: *) ReturnsDeclaration?                             (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttributes = (* item: *) FallbackFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttribute = (* variant: *) ModifierInvocation                          | (* variant: *) OverrideSpecifier                          | (* variant: *) EXTERNAL_KEYWORD                          | (* variant: *) PAYABLE_KEYWORD                          | (* variant: *) PURE_KEYWORD                          | (* variant: *) VIEW_KEYWORD                          | (* variant: *) VIRTUAL_KEYWORD;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionDefinition = (* receive_keyword: *) RECEIVE_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) ReceiveFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttributes = (* item: *) ReceiveFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) OverrideSpecifier                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) VIRTUAL_KEYWORD;</pre>"},{"location":"solidity-grammar/02-definitions/08-functions/#function-definitions","title":"Function Definitions","text":"<p>Functions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts.</p> <pre><code>contract MyContract {\n    function contractFunction() public {\n        // Inside the contract\n    }\n}\n\nfunction helperFunction() {\n    // Outside the contract\n}\n</code></pre> <p>Functions can be overloaded, where multiple functions with the same name, but with different parameters, can co-exist.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/09-modifiers/","title":"2.9. Modifiers","text":""},{"location":"solidity-grammar/02-definitions/09-modifiers/#29-modifiers","title":"2.9. Modifiers","text":""},{"location":"solidity-grammar/02-definitions/09-modifiers/#syntax","title":"Syntax","text":"<pre>ModifierDefinition = (* modifier_keyword: *) MODIFIER_KEYWORD                     (* name: *) IDENTIFIER                     (* parameters: *) ParametersDeclaration?                     (* attributes: *) ModifierAttributes                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>ModifierAttributes = (* item: *) ModifierAttribute*;</pre> <pre></pre> <pre>ModifierAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>ModifierInvocation = (* name: *) IdentifierPath                     (* arguments: *) ArgumentsDeclaration?;</pre>"},{"location":"solidity-grammar/02-definitions/09-modifiers/#function-modifiers","title":"Function Modifiers","text":"<p>Function modifiers can be used to amend the semantics of functions in a declarative way:</p> <pre><code>contract MyContract {\n    modifier onlySeller() {\n        require(msg.sender == seller, \"Only seller can call this.\");\n        _; // Function body will be inserted here\n    }\n\n    function myFunction() public view onlySeller {\n        // Code here will be executed after `onlySeller` is executed.\n    }\n}\n</code></pre> <p>Unlike functions, modifiers cannot be overloaded.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/10-events/","title":"2.10. Events","text":""},{"location":"solidity-grammar/02-definitions/10-events/#210-events","title":"2.10. Events","text":""},{"location":"solidity-grammar/02-definitions/10-events/#syntax","title":"Syntax","text":"<pre>EventDefinition = (* event_keyword: *) EVENT_KEYWORD                  (* name: *) IDENTIFIER                  (* parameters: *) EventParametersDeclaration                  (* anonymous_keyword: *) ANONYMOUS_KEYWORD?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>EventParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) EventParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>EventParameters = ((* item: *) EventParameter ((* separator: *) COMMA (* item: *) EventParameter)*)?;</pre> <pre></pre> <pre>EventParameter = (* type_name: *) TypeName                 (* indexed_keyword: *) INDEXED_KEYWORD?                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-grammar/02-definitions/10-events/#event-definitions","title":"Event Definitions","text":"<p>Events are convenient interfaces with the EVM logging facilities. They have to be defined inside a contract:</p> <pre><code>contract MyContract {\n    // Defining an event\n    event BidPlacedEvent(address bidder, uint amount);\n\n    function bid() public payable {\n        // Triggering an event\n        emit BidPlacedEvent(msg.sender, msg.value);\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/","title":"2.11. User Defined Value Types","text":""},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/#211-user-defined-value-types","title":"2.11. User Defined Value Types","text":""},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.8.8 *)UserDefinedValueTypeDefinition = (* type_keyword: *) TYPE_KEYWORD                                 (* name: *) IDENTIFIER                                 (* is_keyword: *) IS_KEYWORD                                 (* value_type: *) ElementaryType                                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/#user-defined-value-types","title":"User Defined Value Types","text":"<p>A user defined value type allows creating a zero cost abstraction over an elementary value type. This is similar to a type alias. A user defined value type is defined using <code>type C is V</code>, where <code>C</code> is the name of the newly introduced type and <code>V</code> has to be a built-in value type (the underlying type).</p> <pre><code>type MyInteger is uint256;\n\nlibrary MyLibrary {\n    function add(MyInteger a, MyInteger b) internal pure returns (MyInteger) {\n        return MyInteger.wrap(MyInteger.unwrap(a) + MyInteger.unwrap(b));\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/02-definitions/12-errors/","title":"2.12. Errors","text":""},{"location":"solidity-grammar/02-definitions/12-errors/#212-errors","title":"2.12. Errors","text":""},{"location":"solidity-grammar/02-definitions/12-errors/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.8.4 *)ErrorDefinition = (* error_keyword: *) ERROR_KEYWORD                  (* name: *) IDENTIFIER                  (* members: *) ErrorParametersDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) ErrorParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameters = ((* item: *) ErrorParameter ((* separator: *) COMMA (* item: *) ErrorParameter)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameter = (* type_name: *) TypeName                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-grammar/02-definitions/12-errors/#error-definitions","title":"Error Definitions","text":"<p>Errors allow you to define descriptive names and data for failure situations. Errors can be used in revert statements. In comparison to string descriptions, errors are much cheaper and allow you to encode additional data. You can use NatSpec to describe the error to the user. They can also be defined inside or outside contracts:</p> <pre><code>contract Token {\n    error NotEnoughFunds(uint requested, uint available);\n\n    function transfer(address to, uint amount) public {\n        uint balance = balances[msg.sender];\n        if (balance &lt; amount)\n            revert NotEnoughFunds(amount, balance);\n\n        // Continue with the transfer...\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/03-types/","title":"3. Types","text":""},{"location":"solidity-grammar/03-types/#3-types","title":"3. Types","text":"<ul> <li>3.1. Advanced Types</li> <li>3.2. Elementary Types</li> </ul>"},{"location":"solidity-grammar/03-types/01-advanced-types/","title":"3.1. Advanced Types","text":""},{"location":"solidity-grammar/03-types/01-advanced-types/#31-advanced-types","title":"3.1. Advanced Types","text":""},{"location":"solidity-grammar/03-types/01-advanced-types/#syntax","title":"Syntax","text":"<pre>TypeName = (* variant: *) ArrayTypeName         | (* variant: *) FunctionType         | (* variant: *) MappingType         | (* variant: *) ElementaryType         | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)ArrayTypeName = (* operand: *) TypeName                (* open_bracket: *) OPEN_BRACKET                (* index: *) Expression?                (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>FunctionType = (* function_keyword: *) FUNCTION_KEYWORD               (* parameters: *) ParametersDeclaration               (* attributes: *) FunctionTypeAttributes               (* returns: *) ReturnsDeclaration?;</pre> <pre></pre> <pre>FunctionTypeAttributes = (* item: *) FunctionTypeAttribute*;</pre> <pre></pre> <pre>FunctionTypeAttribute = (* variant: *) INTERNAL_KEYWORD                      | (* variant: *) EXTERNAL_KEYWORD                      | (* variant: *) PRIVATE_KEYWORD                      | (* variant: *) PUBLIC_KEYWORD                      | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                      | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) PAYABLE_KEYWORD;</pre> <pre></pre> <pre>MappingType = (* mapping_keyword: *) MAPPING_KEYWORD              (* open_paren: *) OPEN_PAREN              (* key_type: *) MappingKey              (* equal_greater_than: *) EQUAL_GREATER_THAN              (* value_type: *) MappingValue              (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>MappingKey = (* key_type: *) MappingKeyType             (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre> <pre></pre> <pre>MappingKeyType = (* variant: *) ElementaryType               | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>MappingValue = (* type_name: *) TypeName               (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre>"},{"location":"solidity-grammar/03-types/01-advanced-types/#function-types","title":"Function Types","text":"<p>Function types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. They come in two flavors, <code>internal</code> and <code>external</code>.</p> <p>Function types are notated as follows:</p> <pre><code>function (&lt;parameter types&gt;) {internal|external} [pure|view|payable] [returns (&lt;return types&gt;)]\n</code></pre> <p>In contrast to the parameter types, the return types cannot be empty. If the function type should not return anything, the whole <code>returns (&lt;return types&gt;)</code> part has to be omitted.</p> <p>By default, function types are internal, so the <code>internal</code> keyword can be omitted. Note that this only applies to function types. Visibility has to be specified explicitly for functions defined in contracts, they do not have a default.</p> <pre><code>contract Oracle {\n    Request[] private requests;\n\n    function query(bytes memory data, function(uint) external callback) public {\n        requests.push(Request(data, callback));\n    }\n\n    function reply(uint requestID, uint response) public {\n        requests[requestID].callback(response);\n    }\n}\n</code></pre>"},{"location":"solidity-grammar/03-types/01-advanced-types/#mapping-types","title":"Mapping Types","text":"<p>Mapping types use the syntax <code>mapping(_KeyType =&gt; _ValueType)</code> and variables of mapping type are declared using the syntax <code>mapping(_KeyType =&gt; _ValueType) _VariableName</code>.</p> <pre><code>contract MappingExample {\n    mapping(address =&gt; uint) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/03-types/02-elementary-types/","title":"3.2. Elementary Types","text":""},{"location":"solidity-grammar/03-types/02-elementary-types/#32-elementary-types","title":"3.2. Elementary Types","text":""},{"location":"solidity-grammar/03-types/02-elementary-types/#syntax","title":"Syntax","text":"<pre>ElementaryType = (* variant: *) BOOL_KEYWORD               | (* variant: *) BYTE_KEYWORD (* Deprecated in 0.8.0 *)               | (* variant: *) STRING_KEYWORD               | (* variant: *) AddressType               | (* variant: *) BYTES_KEYWORD               | (* variant: *) INT_KEYWORD               | (* variant: *) UINT_KEYWORD               | (* variant: *) FIXED_KEYWORD               | (* variant: *) UFIXED_KEYWORD;</pre> <pre></pre> <pre>AddressType = (* address_keyword: *) ADDRESS_KEYWORD              (* payable_keyword: *) PAYABLE_KEYWORD?; (* Introduced in 0.5.0 *)</pre>"},{"location":"solidity-grammar/03-types/02-elementary-types/#address-types","title":"Address Types","text":"<p>The address type comes in two flavours, which are largely identical:</p> <ul> <li><code>address</code>: Holds a 20 byte value (size of an Ethereum address).</li> <li><code>address payable</code>: Same as <code>address</code>, but with the additional members <code>transfer</code> and <code>send</code>.</li> </ul> <p>Hexadecimal literals that pass the address checksum test, for example <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> are of <code>address</code> type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. You can prepend (for <code>int</code> types) or append (for <code>bytesNN</code> types) zeros to remove the error.</p>"},{"location":"solidity-grammar/03-types/02-elementary-types/#fixed-size-byte-arrays","title":"Fixed-Size Byte Arrays","text":"<p>The value types <code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, \u2026, <code>bytes32</code> hold a sequence of bytes from one to up to 32.</p>"},{"location":"solidity-grammar/03-types/02-elementary-types/#dynamic-string-and-byte-arrays","title":"Dynamic String and Byte Arrays","text":"<p>The <code>bytes</code> type is similar to <code>bytes1[]</code>, but it is packed tightly in calldata and memory.</p> <p>Variables of type <code>string</code> are equal to <code>bytes</code> but do not allow length or index access. If you want to access the byte-representation of a string <code>s</code>, use <code>bytes(s)</code>. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters.</p> <p>Memory arrays with dynamic length can be created using the <code>new</code> keyword:</p> <pre><code>contract MyContract {\n    function myFunction(uint length) public pure {\n        bytes memory b = new bytes(length);\n    }\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/04-statements/","title":"4. Statements","text":""},{"location":"solidity-grammar/04-statements/#4-statements","title":"4. Statements","text":"<ul> <li>4.1. Blocks</li> <li>4.2. Declaration Statements</li> <li>4.3. Control Statements</li> <li>4.4. Error Handling</li> </ul>"},{"location":"solidity-grammar/04-statements/01-blocks/","title":"4.1. Blocks","text":""},{"location":"solidity-grammar/04-statements/01-blocks/#41-blocks","title":"4.1. Blocks","text":""},{"location":"solidity-grammar/04-statements/01-blocks/#syntax","title":"Syntax","text":"<pre>Block = (* open_brace: *) OPEN_BRACE        (* statements: *) Statements        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>Statements = (* item: *) Statement*;</pre> <pre></pre> <pre>Statement = (* variant: *) IfStatement          | (* variant: *) ForStatement          | (* variant: *) WhileStatement          | (* variant: *) DoWhileStatement          | (* variant: *) ContinueStatement          | (* variant: *) BreakStatement          | (* variant: *) ReturnStatement          | (* variant: *) ThrowStatement (* Deprecated in 0.5.0 *)          | (* variant: *) EmitStatement (* Introduced in 0.4.21 *)          | (* variant: *) TryStatement (* Introduced in 0.6.0 *)          | (* variant: *) RevertStatement (* Introduced in 0.8.4 *)          | (* variant: *) AssemblyStatement          | (* variant: *) Block          | (* variant: *) UncheckedBlock (* Introduced in 0.8.0 *)          | (* variant: *) TupleDeconstructionStatement          | (* variant: *) VariableDeclarationStatement          | (* variant: *) ExpressionStatement;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)UncheckedBlock = (* unchecked_keyword: *) UNCHECKED_KEYWORD                 (* block: *) Block;</pre> <pre></pre> <pre>ExpressionStatement = (* expression: *) Expression                      (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>AssemblyStatement = (* assembly_keyword: *) ASSEMBLY_KEYWORD                    (* label: *) StringLiteral?                    (* flags: *) AssemblyFlagsDeclaration? (* Introduced in 0.8.13 *)                    (* body: *) YulBlock;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)AssemblyFlagsDeclaration = (* open_paren: *) OPEN_PAREN                           (* flags: *) AssemblyFlags                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)AssemblyFlags = (* item: *) StringLiteral ((* separator: *) COMMA (* item: *) StringLiteral)*;</pre>"},{"location":"solidity-grammar/04-statements/01-blocks/#unchecked-blocks","title":"Unchecked Blocks","text":"<p>Starting with <code>v0.8.0</code>, by default, all arithmetic operations are checked for underflow or overflow, which means that if the result of an operation falls outside the value range of the type, the call is reverted through a failing assertion. This can be disabled using the <code>unchecked</code> block, resulting in wrapping arithmetic:</p> <pre><code>unchecked {\n  i++;\n}\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/04-statements/02-declaration-statements/","title":"4.2. Declaration Statements","text":""},{"location":"solidity-grammar/04-statements/02-declaration-statements/#42-declaration-statements","title":"4.2. Declaration Statements","text":""},{"location":"solidity-grammar/04-statements/02-declaration-statements/#syntax","title":"Syntax","text":"<pre>TupleDeconstructionStatement = (* var_keyword: *) VAR_KEYWORD? (* Deprecated in 0.5.0 *)                               (* open_paren: *) OPEN_PAREN                               (* elements: *) TupleDeconstructionElements                               (* close_paren: *) CLOSE_PAREN                               (* equal: *) EQUAL                               (* expression: *) Expression                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>TupleDeconstructionElements = (* item: *) TupleDeconstructionElement ((* separator: *) COMMA (* item: *) TupleDeconstructionElement)*;</pre> <pre></pre> <pre>TupleDeconstructionElement = (* member: *) TupleMember?;</pre> <pre></pre> <pre>TupleMember = (* variant: *) TypedTupleMember            | (* variant: *) UntypedTupleMember;</pre> <pre></pre> <pre>TypedTupleMember = (* type_name: *) TypeName                   (* storage_location: *) StorageLocation?                   (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>UntypedTupleMember = (* storage_location: *) StorageLocation?                     (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>VariableDeclarationStatement = (* variable_type: *) VariableDeclarationType                               (* storage_location: *) StorageLocation?                               (* name: *) IDENTIFIER                               (* value: *) VariableDeclarationValue?                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>VariableDeclarationType = (* variant: *) TypeName                        | (* variant: *) VAR_KEYWORD; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>VariableDeclarationValue = (* equal: *) EQUAL                           (* expression: *) Expression;</pre> <pre></pre> <pre>StorageLocation = (* variant: *) MEMORY_KEYWORD                | (* variant: *) STORAGE_KEYWORD                | (* variant: *) CALL_DATA_KEYWORD; (* Introduced in 0.5.0 *)</pre>"},{"location":"solidity-grammar/04-statements/02-declaration-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/04-statements/03-control-statements/","title":"4.3. Control Statements","text":""},{"location":"solidity-grammar/04-statements/03-control-statements/#43-control-statements","title":"4.3. Control Statements","text":""},{"location":"solidity-grammar/04-statements/03-control-statements/#syntax","title":"Syntax","text":"<pre>IfStatement = (* if_keyword: *) IF_KEYWORD              (* open_paren: *) OPEN_PAREN              (* condition: *) Expression              (* close_paren: *) CLOSE_PAREN              (* body: *) Statement              (* else_branch: *) ElseBranch?;</pre> <pre></pre> <pre>ElseBranch = (* else_keyword: *) ELSE_KEYWORD             (* body: *) Statement;</pre> <pre></pre> <pre>ForStatement = (* for_keyword: *) FOR_KEYWORD               (* open_paren: *) OPEN_PAREN               (* initialization: *) ForStatementInitialization               (* condition: *) ForStatementCondition               (* iterator: *) Expression?               (* close_paren: *) CLOSE_PAREN               (* body: *) Statement;</pre> <pre></pre> <pre>ForStatementInitialization = (* variant: *) TupleDeconstructionStatement                           | (* variant: *) VariableDeclarationStatement                           | (* variant: *) ExpressionStatement                           | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>ForStatementCondition = (* variant: *) ExpressionStatement                      | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>WhileStatement = (* while_keyword: *) WHILE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* condition: *) Expression                 (* close_paren: *) CLOSE_PAREN                 (* body: *) Statement;</pre> <pre></pre> <pre>DoWhileStatement = (* do_keyword: *) DO_KEYWORD                   (* body: *) Statement                   (* while_keyword: *) WHILE_KEYWORD                   (* open_paren: *) OPEN_PAREN                   (* condition: *) Expression                   (* close_paren: *) CLOSE_PAREN                   (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ContinueStatement = (* continue_keyword: *) CONTINUE_KEYWORD                    (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>BreakStatement = (* break_keyword: *) BREAK_KEYWORD                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ReturnStatement = (* return_keyword: *) RETURN_KEYWORD                  (* expression: *) Expression?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)EmitStatement = (* emit_keyword: *) EMIT_KEYWORD                (* event: *) IdentifierPath                (* arguments: *) ArgumentsDeclaration                (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/04-statements/03-control-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/04-statements/04-error-handling/","title":"4.4. Error Handling","text":""},{"location":"solidity-grammar/04-statements/04-error-handling/#44-error-handling","title":"4.4. Error Handling","text":""},{"location":"solidity-grammar/04-statements/04-error-handling/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.6.0 *)TryStatement = (* try_keyword: *) TRY_KEYWORD               (* expression: *) Expression               (* returns: *) ReturnsDeclaration?               (* body: *) Block               (* catch_clauses: *) CatchClauses;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauses = (* item: *) CatchClause+;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClause = (* catch_keyword: *) CATCH_KEYWORD              (* error: *) CatchClauseError?              (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauseError = (* name: *) IDENTIFIER?                   (* parameters: *) ParametersDeclaration;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)RevertStatement = (* revert_keyword: *) REVERT_KEYWORD                  (* error: *) IdentifierPath?                  (* arguments: *) ArgumentsDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)ThrowStatement = (* throw_keyword: *) THROW_KEYWORD                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/04-statements/04-error-handling/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/","title":"5. Expressions","text":""},{"location":"solidity-grammar/05-expressions/#5-expressions","title":"5. Expressions","text":"<ul> <li>5.1. Base Expressions</li> <li>5.2. Function Calls</li> <li>5.3. Primary Expressions</li> <li>5.4. Numbers</li> <li>5.5. Strings</li> <li>5.6. Identifiers</li> </ul>"},{"location":"solidity-grammar/05-expressions/01-base-expressions/","title":"5.1. Base Expressions","text":""},{"location":"solidity-grammar/05-expressions/01-base-expressions/#51-base-expressions","title":"5.1. Base Expressions","text":""},{"location":"solidity-grammar/05-expressions/01-base-expressions/#syntax","title":"Syntax","text":"<pre>Expression = (* variant: *) AssignmentExpression           | (* variant: *) ConditionalExpression           | (* variant: *) OrExpression           | (* variant: *) AndExpression           | (* variant: *) EqualityExpression           | (* variant: *) InequalityExpression           | (* variant: *) BitwiseOrExpression           | (* variant: *) BitwiseXorExpression           | (* variant: *) BitwiseAndExpression           | (* variant: *) ShiftExpression           | (* variant: *) AdditiveExpression           | (* variant: *) MultiplicativeExpression           | (* variant: *) ExponentiationExpression           | (* variant: *) PostfixExpression           | (* variant: *) PrefixExpression           | (* variant: *) FunctionCallExpression           | (* variant: *) CallOptionsExpression           | (* variant: *) MemberAccessExpression           | (* variant: *) IndexAccessExpression           | (* variant: *) NewExpression           | (* variant: *) TupleExpression           | (* variant: *) TypeExpression (* Introduced in 0.5.3 *)           | (* variant: *) ArrayExpression           | (* variant: *) HexNumberExpression           | (* variant: *) DecimalNumberExpression           | (* variant: *) StringExpression           | (* variant: *) ElementaryType           | (* variant: *) PAYABLE_KEYWORD (* Introduced in 0.6.0 *)           | (* variant: *) THIS_KEYWORD           | (* variant: *) SUPER_KEYWORD           | (* variant: *) TRUE_KEYWORD           | (* variant: *) FALSE_KEYWORD           | (* variant: *) IDENTIFIER;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) BAR_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PLUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) MINUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) CARET_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) SLASH_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PERCENT_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) ASTERISK_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)ConditionalExpression = (* operand: *) Expression                        (* question_mark: *) QUESTION_MARK                        (* true_expression: *) Expression                        (* colon: *) COLON                        (* false_expression: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)OrExpression = (* left_operand: *) Expression               (* operator: *) BAR_BAR               (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AndExpression = (* left_operand: *) Expression                (* operator: *) AMPERSAND_AMPERSAND                (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) EQUAL_EQUAL                     (* right_operand: *) Expression;(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) BANG_EQUAL                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseOrExpression = (* left_operand: *) Expression                      (* operator: *) BAR                      (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseXorExpression = (* left_operand: *) Expression                       (* operator: *) CARET                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseAndExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) LESS_THAN_LESS_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) PLUS                     (* right_operand: *) Expression;(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) MINUS                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) SLASH                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) PERCENT                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)(* Deprecated in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;(* Right-associative binary operator *)(* Introduced in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) PLUS_PLUS;(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) MINUS_MINUS;</pre> <pre></pre> <pre>(* Prefix unary operator *)PrefixExpression = (* operator: *) PLUS_PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS_MINUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) TILDE                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) BANG                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS                   (* operand: *) Expression;(* Prefix unary operator *)(* Deprecated in 0.5.0 *)PrefixExpression = (* operator: *) PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) DELETE_KEYWORD                   (* operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)FunctionCallExpression = (* operand: *) Expression                         (* arguments: *) ArgumentsDeclaration;</pre> <pre></pre> <pre>(* Postfix unary operator *)(* Introduced in 0.6.2 *)CallOptionsExpression = (* operand: *) Expression                        (* open_brace: *) OPEN_BRACE                        (* options: *) CallOptions                        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Postfix unary operator *)MemberAccessExpression = (* operand: *) Expression                         (* period: *) PERIOD                         (* member: *) IDENTIFIER;</pre> <pre></pre> <pre>(* Postfix unary operator *)IndexAccessExpression = (* operand: *) Expression                        (* open_bracket: *) OPEN_BRACKET                        (* start: *) Expression?                        (* end: *) IndexAccessEnd?                        (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>IndexAccessEnd = (* colon: *) COLON                 (* end: *) Expression?;</pre>"},{"location":"solidity-grammar/05-expressions/01-base-expressions/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/02-function-calls/","title":"5.2. Function Calls","text":""},{"location":"solidity-grammar/05-expressions/02-function-calls/#52-function-calls","title":"5.2. Function Calls","text":""},{"location":"solidity-grammar/05-expressions/02-function-calls/#syntax","title":"Syntax","text":"<pre>ArgumentsDeclaration = (* variant: *) PositionalArgumentsDeclaration                     | (* variant: *) NamedArgumentsDeclaration;</pre> <pre></pre> <pre>PositionalArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                                 (* arguments: *) PositionalArguments                                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>PositionalArguments = ((* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*)?;</pre> <pre></pre> <pre>NamedArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                            (* arguments: *) NamedArgumentGroup?                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NamedArgumentGroup = (* open_brace: *) OPEN_BRACE                     (* arguments: *) NamedArguments                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>NamedArguments = ((* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)CallOptions = (* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*;</pre> <pre></pre> <pre>NamedArgument = (* name: *) IDENTIFIER                (* colon: *) COLON                (* value: *) Expression;</pre>"},{"location":"solidity-grammar/05-expressions/02-function-calls/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/03-primary-expressions/","title":"5.3. Primary Expressions","text":""},{"location":"solidity-grammar/05-expressions/03-primary-expressions/#53-primary-expressions","title":"5.3. Primary Expressions","text":""},{"location":"solidity-grammar/05-expressions/03-primary-expressions/#syntax","title":"Syntax","text":"<pre>(* Introduced in 0.5.3 *)TypeExpression = (* type_keyword: *) TYPE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* type_name: *) TypeName                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NewExpression = (* new_keyword: *) NEW_KEYWORD                (* type_name: *) TypeName;</pre> <pre></pre> <pre>TupleExpression = (* open_paren: *) OPEN_PAREN                  (* items: *) TupleValues                  (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>TupleValues = (* item: *) TupleValue ((* separator: *) COMMA (* item: *) TupleValue)*;</pre> <pre></pre> <pre>TupleValue = (* expression: *) Expression?;</pre> <pre></pre> <pre>ArrayExpression = (* open_bracket: *) OPEN_BRACKET                  (* items: *) ArrayValues                  (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>ArrayValues = (* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*;</pre>"},{"location":"solidity-grammar/05-expressions/03-primary-expressions/#array-literals","title":"Array Literals","text":"<p>An array literal is a comma-separated list of one or more expressions, enclosed in square brackets (<code>[...]</code>). For example <code>[1, a, f(3)]</code>. It is always a statically-sized memory array whose length is the number of expressions.</p> <pre><code>contract MyContract {\n    function someFunction() public pure {\n        otherFunction([uint(1), 2, 3]);\n    }\n}\n</code></pre>"},{"location":"solidity-grammar/05-expressions/03-primary-expressions/#array-slices","title":"Array Slices","text":"<p>Array slices are a view on a contiguous portion of an array. They are written as <code>x[start:end]</code>, where <code>start</code> and <code>end</code> are expressions resulting in a uint256 type (or implicitly convertible to it). The first element of the slice is <code>x[start]</code> and the last element is <code>x[end - 1]</code>.</p> <p>Both <code>start</code> and <code>end</code> are optional: <code>start</code> defaults to <code>0</code> and <code>end</code> defaults to the length of the array.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/","title":"5.4. Numbers","text":""},{"location":"solidity-grammar/05-expressions/04-numbers/#54-numbers","title":"5.4. Numbers","text":""},{"location":"solidity-grammar/05-expressions/04-numbers/#syntax","title":"Syntax","text":"<pre>HexNumberExpression = (* literal: *) HEX_LITERAL                      (* unit: *) NumberUnit?; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>DecimalNumberExpression = (* literal: *) DECIMAL_LITERAL                          (* unit: *) NumberUnit?;</pre> <pre></pre> <pre>HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)* (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)HEX_LITERAL = \"0X\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)* (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>DECIMAL_LITERAL = \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb (?!\".\") \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" (?!\u00abDECIMAL_DIGITS\u00bb) \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Introduced in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb (\".\" \u00abDECIMAL_DIGITS\u00bb)? \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>\u00abDECIMAL_DIGITS\u00bb = \"0\"\u2026\"9\"+ (\"_\" \"0\"\u2026\"9\"+)*;</pre> <pre></pre> <pre>\u00abDECIMAL_EXPONENT\u00bb = (\"e\" | \"E\") \"-\"? \u00abDECIMAL_DIGITS\u00bb;</pre> <pre></pre> <pre>NumberUnit = (* variant: *) WEI_KEYWORD           | (* variant: *) GWEI_KEYWORD (* Introduced in 0.6.11 *)           | (* variant: *) SZABO_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) FINNEY_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) ETHER_KEYWORD           | (* variant: *) SECONDS_KEYWORD           | (* variant: *) MINUTES_KEYWORD           | (* variant: *) HOURS_KEYWORD           | (* variant: *) DAYS_KEYWORD           | (* variant: *) WEEKS_KEYWORD           | (* variant: *) YEARS_KEYWORD; (* Deprecated in 0.5.0 *)</pre>"},{"location":"solidity-grammar/05-expressions/04-numbers/#integers","title":"Integers","text":"<p>Signed (<code>int8</code>..<code>int256</code>) and unsigned (<code>uint8</code>..<code>uint256</code>) integers of various sizes, from 8 to 256 bits, moving up in steps of 8 bits. <code>uint</code> and <code>int</code> are aliases for <code>uint256</code> and <code>int256</code>, respectively.</p> <p>Integers in Solidity are restricted to a certain range. For example, with <code>uint32</code>, this is <code>0</code> up to <code>2**32 - 1</code>.</p> <p>Integer literals are formed from a sequence of digits in the range <code>0-9</code>. They are interpreted as decimals. For example, <code>69</code> means sixty nine.</p> <p>Octal literals do not exist in Solidity and leading zeros are invalid.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/#decimals","title":"Decimals","text":"<p>Decimal fractional literals are formed by a <code>.</code> with at least one number on one side. Examples include <code>1.</code>, <code>.1</code> and <code>1.3</code>.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/#fixed-point-numbers","title":"Fixed Point Numbers","text":"<p>Signed <code>fixed</code> and unsigned fixed <code>ufixed</code> point number of various sizes. Keywords <code>ufixedMxN</code> and <code>fixedMxN</code>, where <code>M</code> represents the number of bits taken by the type and <code>N</code> represents how many decimal points are available. <code>M</code> must be divisible by 8 and goes from 8 to 256 bits. <code>N</code> must be between 0 and 80, inclusive. <code>ufixed</code> and <code>fixed</code> are aliases for <code>ufixed128x18</code> and <code>fixed128x18</code>, respectively.</p> <p>Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/#scientific-notation","title":"Scientific Notation","text":"<p>Scientific notation in the form of <code>2e10</code> is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal <code>MeE</code> is equivalent to <code>M * 10**E</code>. Examples include <code>2e10</code>, <code>-2e10</code>, <code>2e-10</code>, <code>2.5e1</code>.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/#using-underscores","title":"Using Underscores","text":"<p>Underscores can be used to separate the digits of a numeric literal to aid readability. For example, decimal <code>123_000</code>, hexadecimal <code>0x2eff_abcde</code>, scientific decimal notation <code>1_2e345_678</code> are all valid. Underscores are only allowed between two digits and only one consecutive underscore is allowed. There is no additional semantic meaning added to a number literal containing underscores, the underscores are ignored.</p>"},{"location":"solidity-grammar/05-expressions/04-numbers/#ether-units","title":"Ether Units","text":"<p>A literal number can take a suffix of <code>wei</code>, <code>gwei</code> or <code>ether</code> to specify a sub-denomination of Ether, where Ether numbers without a postfix are assumed to be Wei.</p> <pre><code>assert(1 wei == 1);\nassert(1 gwei == 1e9);\nassert(1 szabo == 1e12);\nassert(1 finney == 1e15);\nassert(1 ether == 1e18);\n</code></pre>"},{"location":"solidity-grammar/05-expressions/04-numbers/#time-units","title":"Time Units","text":"<p>Suffixes that can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:</p> <pre><code>assert(1 == 1 seconds);\nassert(1 minutes == 60 seconds);\nassert(1 hours == 60 minutes);\nassert(1 days == 24 hours);\nassert(1 weeks == 7 days);\n</code></pre> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/05-strings/","title":"5.5. Strings","text":""},{"location":"solidity-grammar/05-expressions/05-strings/#55-strings","title":"5.5. Strings","text":""},{"location":"solidity-grammar/05-expressions/05-strings/#syntax","title":"Syntax","text":"<pre>StringExpression = (* variant: *) StringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) StringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) HexStringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) HexStringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) UnicodeStringLiterals; (* Introduced in 0.7.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)StringLiterals = (* item: *) StringLiteral+;</pre> <pre></pre> <pre>StringLiteral = (* variant: *) SINGLE_QUOTED_STRING_LITERAL              | (* variant: *) DOUBLE_QUOTED_STRING_LITERAL;</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";(* Introduced in 0.4.25 and deprecated in 0.7.0. *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | \" \"\u2026\"&amp;\" | \"(\"\u2026\"[\" | \"]\"\u2026\"~\")* \"'\";</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';(* Introduced in 0.4.25 and deprecated in 0.7.0. *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | \" \"\u2026\"!\" | \"#\"\u2026\"[\" | \"]\"\u2026\"~\")* '\"';</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)HexStringLiterals = (* item: *) HexStringLiteral+;</pre> <pre></pre> <pre>HexStringLiteral = (* variant: *) SINGLE_QUOTED_HEX_STRING_LITERAL                 | (* variant: *) DOUBLE_QUOTED_HEX_STRING_LITERAL;</pre> <pre></pre> <pre>SINGLE_QUOTED_HEX_STRING_LITERAL = \"hex'\" \u00abHEX_STRING_CONTENTS\u00bb? \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_HEX_STRING_LITERAL = 'hex\"' \u00abHEX_STRING_CONTENTS\u00bb? '\"';</pre> <pre></pre> <pre>\u00abHEX_STRING_CONTENTS\u00bb = \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb (\"_\"? \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb)*;</pre> <pre></pre> <pre>\u00abHEX_CHARACTER\u00bb = \"0\"\u2026\"9\" | \"a\"\u2026\"f\" | \"A\"\u2026\"F\";</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiterals = (* item: *) UnicodeStringLiteral+;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiteral = (* variant: *) SINGLE_QUOTED_UNICODE_STRING_LITERAL                     | (* variant: *) DOUBLE_QUOTED_UNICODE_STRING_LITERAL;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)SINGLE_QUOTED_UNICODE_STRING_LITERAL = \"unicode'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)DOUBLE_QUOTED_UNICODE_STRING_LITERAL = 'unicode\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';</pre> <pre></pre> <pre>\u00abESCAPE_SEQUENCE\u00bb = \"\\\\\" (\u00abASCII_ESCAPE\u00bb | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb = \"\\\\\" (!(\"x\" | \"u\") | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>\u00abASCII_ESCAPE\u00bb = \"n\" | \"r\" | \"t\" | \"'\" | '\"' | \"\\\\\" | \"\\r\\n\" | \"\\r\" | \"\\n\";</pre> <pre></pre> <pre>\u00abHEX_BYTE_ESCAPE\u00bb = \"x\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre> <pre></pre> <pre>\u00abUNICODE_ESCAPE\u00bb = \"u\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre>"},{"location":"solidity-grammar/05-expressions/05-strings/#string-literals","title":"String Literals","text":"<p>String literals are written with either double or single-quotes (<code>\"foo\"</code> or <code>'bar'</code>), and they can also be split into multiple consecutive parts (<code>\"foo\" \"bar\"</code> is equivalent to <code>\"foobar\"</code>) which can be helpful when dealing with long strings. They do not imply trailing zeroes as in C; <code>\"foo\"</code> represents three bytes, not four. As with integer literals, their type can vary, but they are implicitly convertible to <code>bytes1</code>, ..., <code>bytes32</code> if they fit.</p> <p>String literals can only contain printable ASCII characters, which means the characters between <code>0x20</code> and <code>0x7E</code> inclusively.</p>"},{"location":"solidity-grammar/05-expressions/05-strings/#unicode-literals","title":"Unicode Literals","text":"<p>While regular string literals can only contain ASCII, unicode literals (prefixed with the keyword <code>unicode</code>) can contain any valid UTF-8 sequence. They also support the very same escape sequences as regular string literals.</p> <pre><code>string memory a = unicode\"Hello \ud83d\ude03\";\n</code></pre>"},{"location":"solidity-grammar/05-expressions/05-strings/#hexadecimal-literals","title":"Hexadecimal Literals","text":"<p>Hexadecimal literals are prefixed with the keyword <code>hex</code> and are enclosed in double or single-quotes (<code>hex\"001122FF\"</code>, <code>hex'0011_22_FF'</code>). Their content must be hexadecimal digits which can optionally use a single underscore as separator between byte boundaries. The value of the literal will be the binary representation of the hexadecimal sequence.</p> <p>Hexadecimal literals behave like string literals and have the same convertibility restrictions. Additionally, multiple hexadecimal literals separated by whitespace are concatenated into a single literal: <code>hex\"00112233\" hex\"44556677\"</code> is equivalent to <code>hex\"0011223344556677\"</code></p>"},{"location":"solidity-grammar/05-expressions/05-strings/#escape-sequences","title":"Escape Sequences","text":"<p>String literals also support the following escape characters:</p> <ul> <li><code>\\&lt;newline&gt;</code> (escapes an actual newline)</li> <li><code>\\\\</code> (backslash)</li> <li><code>\\'</code> (single quote)</li> <li><code>\\\"</code> (double quote)</li> <li><code>\\n</code> (newline)break</li> <li><code>\\r</code> (carriage return)</li> <li><code>\\t</code> (tab)</li> <li><code>\\xNN</code> (hex escape, takes a hex value and inserts the appropriate byte)</li> <li><code>\\uNNNN</code> (unicode escape, takes a Unicode code point and inserts an UTF-8 sequence)</li> </ul> <p>Any Unicode line terminator which is not a newline (i.e. LF, VF, FF, CR, NEL, LS, PS) is considered to terminate the string literal. Newline only terminates the string literal if it is not preceded by a <code>\\</code>.</p> <p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/05-expressions/06-identifiers/","title":"5.6. Identifiers","text":""},{"location":"solidity-grammar/05-expressions/06-identifiers/#56-identifiers","title":"5.6. Identifiers","text":""},{"location":"solidity-grammar/05-expressions/06-identifiers/#syntax","title":"Syntax","text":"<pre>IdentifierPath = (* item: *) IDENTIFIER ((* separator: *) PERIOD (* item: *) IDENTIFIER)*;</pre> <pre></pre> <pre>IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>\u00abIDENTIFIER_START\u00bb = \"_\" | \"$\" | \"a\"\u2026\"z\" | \"A\"\u2026\"Z\";</pre> <pre></pre> <pre>\u00abIDENTIFIER_PART\u00bb = \u00abIDENTIFIER_START\u00bb | \"0\"\u2026\"9\";</pre>"},{"location":"solidity-grammar/05-expressions/06-identifiers/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/06-yul/","title":"6. Yul","text":""},{"location":"solidity-grammar/06-yul/#6-yul","title":"6. Yul","text":"<ul> <li>6.1. Yul Statements</li> <li>6.2. Yul Expressions</li> <li>6.3. Yul Keywords</li> </ul>"},{"location":"solidity-grammar/06-yul/01-yul-statements/","title":"6.1. Yul Statements","text":""},{"location":"solidity-grammar/06-yul/01-yul-statements/#61-yul-statements","title":"6.1. Yul Statements","text":""},{"location":"solidity-grammar/06-yul/01-yul-statements/#syntax","title":"Syntax","text":"<pre>YulBlock = (* open_brace: *) OPEN_BRACE           (* statements: *) YulStatements           (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>YulStatements = (* item: *) YulStatement*;</pre> <pre></pre> <pre>YulStatement = (* variant: *) YulBlock             | (* variant: *) YulFunctionDefinition             | (* variant: *) YulStackAssignmentStatement (* Deprecated in 0.5.0 *)             | (* variant: *) YulIfStatement             | (* variant: *) YulForStatement             | (* variant: *) YulSwitchStatement             | (* variant: *) YulLeaveStatement (* Introduced in 0.6.0 *)             | (* variant: *) YulBreakStatement             | (* variant: *) YulContinueStatement             | (* variant: *) YulVariableAssignmentStatement             | (* variant: *) YulLabel (* Deprecated in 0.5.0 *)             | (* variant: *) YulVariableDeclarationStatement             | (* variant: *) YulExpression;</pre> <pre></pre> <pre>YulFunctionDefinition = (* function_keyword: *) YUL_FUNCTION_KEYWORD                        (* name: *) YUL_IDENTIFIER                        (* parameters: *) YulParametersDeclaration                        (* returns: *) YulReturnsDeclaration?                        (* body: *) YulBlock;</pre> <pre></pre> <pre>YulParametersDeclaration = (* open_paren: *) OPEN_PAREN                           (* parameters: *) YulParameters                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulParameters = ((* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*)?;</pre> <pre></pre> <pre>YulReturnsDeclaration = (* minus_greater_than: *) MINUS_GREATER_THAN                        (* variables: *) YulVariableNames;</pre> <pre></pre> <pre>YulVariableNames = (* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*;</pre> <pre></pre> <pre>YulVariableDeclarationStatement = (* let_keyword: *) YUL_LET_KEYWORD                                  (* variables: *) YulVariableNames                                  (* value: *) YulVariableDeclarationValue?;</pre> <pre></pre> <pre>YulVariableDeclarationValue = (* assignment: *) YulAssignmentOperator                              (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulVariableAssignmentStatement = (* variables: *) YulPaths                                 (* assignment: *) YulAssignmentOperator                                 (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulAssignmentOperator = (* variant: *) COLON_EQUAL                      | (* variant: *) YulColonAndEqual; (* Deprecated in 0.5.5 *)</pre> <pre></pre> <pre>(* Deprecated in 0.5.5 *)YulColonAndEqual = (* colon: *) COLON                   (* equal: *) EQUAL;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentStatement = (* assignment: *) YulStackAssignmentOperator                              (* variable: *) YUL_IDENTIFIER;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentOperator = (* variant: *) EQUAL_COLON                           | (* variant: *) YulEqualAndColon;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulEqualAndColon = (* equal: *) EQUAL                   (* colon: *) COLON;</pre> <pre></pre> <pre>YulIfStatement = (* if_keyword: *) YUL_IF_KEYWORD                 (* condition: *) YulExpression                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulForStatement = (* for_keyword: *) YUL_FOR_KEYWORD                  (* initialization: *) YulBlock                  (* condition: *) YulExpression                  (* iterator: *) YulBlock                  (* body: *) YulBlock;</pre> <pre></pre> <pre>YulSwitchStatement = (* switch_keyword: *) YUL_SWITCH_KEYWORD                     (* expression: *) YulExpression                     (* cases: *) YulSwitchCases;</pre> <pre></pre> <pre>YulSwitchCases = (* item: *) YulSwitchCase+;</pre> <pre></pre> <pre>YulSwitchCase = (* variant: *) YulDefaultCase              | (* variant: *) YulValueCase;</pre> <pre></pre> <pre>YulDefaultCase = (* default_keyword: *) YUL_DEFAULT_KEYWORD                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulValueCase = (* case_keyword: *) YUL_CASE_KEYWORD               (* value: *) YulLiteral               (* body: *) YulBlock;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)YulLeaveStatement = (* leave_keyword: *) YUL_LEAVE_KEYWORD;</pre> <pre></pre> <pre>YulBreakStatement = (* break_keyword: *) YUL_BREAK_KEYWORD;</pre> <pre></pre> <pre>YulContinueStatement = (* continue_keyword: *) YUL_CONTINUE_KEYWORD;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulLabel = (* label: *) YUL_IDENTIFIER           (* colon: *) COLON;</pre>"},{"location":"solidity-grammar/06-yul/01-yul-statements/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/06-yul/02-yul-expressions/","title":"6.2. Yul Expressions","text":""},{"location":"solidity-grammar/06-yul/02-yul-expressions/#62-yul-expressions","title":"6.2. Yul Expressions","text":""},{"location":"solidity-grammar/06-yul/02-yul-expressions/#syntax","title":"Syntax","text":"<pre>YulExpression = (* variant: *) YulFunctionCallExpression              | (* variant: *) YulLiteral              | (* variant: *) YulPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)YulFunctionCallExpression = (* operand: *) YulExpression                            (* open_paren: *) OPEN_PAREN                            (* arguments: *) YulArguments                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulArguments = ((* item: *) YulExpression ((* separator: *) COMMA (* item: *) YulExpression)*)?;</pre> <pre></pre> <pre>YulPaths = (* item: *) YulPath ((* separator: *) COMMA (* item: *) YulPath)*;</pre> <pre></pre> <pre>YulPath = (* item: *) YUL_IDENTIFIER ((* separator: *) PERIOD (* item: *) YUL_IDENTIFIER)*;</pre> <pre></pre> <pre>(* Introduced in 0.5.8 and deprecated in 0.7.0. *)YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb (\u00abIDENTIFIER_PART\u00bb | \".\")*;YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>YulLiteral = (* variant: *) YUL_TRUE_KEYWORD (* Introduced in 0.6.2 *)           | (* variant: *) YUL_FALSE_KEYWORD (* Introduced in 0.6.2 *)           | (* variant: *) YUL_DECIMAL_LITERAL           | (* variant: *) YUL_HEX_LITERAL           | (* variant: *) HexStringLiteral           | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>YUL_DECIMAL_LITERAL = (\"0\" | (\"1\"\u2026\"9\" \"0\"\u2026\"9\"*)) (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>YUL_HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+ (?!\u00abIDENTIFIER_START\u00bb);</pre>"},{"location":"solidity-grammar/06-yul/02-yul-expressions/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"solidity-grammar/06-yul/03-yul-keywords/","title":"6.3. Yul Keywords","text":""},{"location":"solidity-grammar/06-yul/03-yul-keywords/#63-yul-keywords","title":"6.3. Yul Keywords","text":""},{"location":"solidity-grammar/06-yul/03-yul-keywords/#syntax","title":"Syntax","text":"<pre>(* Reserved until 0.7.1 *)YUL_ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>(* Reserved until 0.5.10 *)YUL_BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>YUL_BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>YUL_CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>YUL_CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>YUL_DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)YUL_FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\";(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>YUL_FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>YUL_FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>(* Reserved from 0.7.0 until 0.7.1 *)YUL_GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>YUL_HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>YUL_IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>(* Reserved until 0.6.8 *)YUL_IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.7.1 *)YUL_LEAVE_KEYWORD = \"leave\";</pre> <pre></pre> <pre>YUL_LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)YUL_SUPER_KEYWORD = \"super\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>YUL_SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)YUL_THIS_KEYWORD = \"this\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)YUL_TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\";(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Reserved until 0.6.5 *)YUL_VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_YEARS_KEYWORD = \"years\";</pre>"},{"location":"solidity-grammar/06-yul/03-yul-keywords/#documentation","title":"Documentation","text":"<p>Note</p> <p>This section is under construction. You are more than welcome to contribute suggestions to our GitHub repository.</p>"},{"location":"user-guide/","title":"User Guide","text":"<ul> <li>1. Introduction</li> <li>2. Powered By Slang</li> <li>3. Concepts</li> <li>4. Getting Started</li> <li>5. Syntax Trees</li> <li>6. Query Language</li> <li>7. Semantic Analysis</li> <li>8. Examples</li> </ul>"},{"location":"user-guide/01-introduction/","title":"1. Introduction","text":"<p>Welcome to the Slang user guide! This aims to be an introduction to Slang itself, its concepts and also contains a collection of guides how you can achieve basic tasks with it.</p>"},{"location":"user-guide/01-introduction/#what-is-slang","title":"What is Slang?","text":"<p>Slang is intended to be a modular Solidity compiler, specifically targeting code analysis and developer tooling. This means servicing tools with domain-specific APIs and, in general, facilitating working with and analyzing the Solidity source code. If you're in the editor writing Solidity or performing linting or additional validation, there's a chance that you are, or could be, running Slang!</p> <p>To get a good grasp on the concepts used in Slang, see the Concepts page.</p>"},{"location":"user-guide/01-introduction/#what-slang-is-not","title":"What Slang is not?","text":"<p>First and foremost, it is not a replacement for <code>solc</code>, the standard Solidity compiler. We do not plan at the moment to support emitting optimized EVM bytecode for use in production. Secondly, it does not perform formal verification of contracts or Solidity logic in general. However, other tools that serve this purpose are intended to be built on top of it.</p>"},{"location":"user-guide/01-introduction/#supporting-multiple-versions","title":"Supporting multiple versions","text":"<p>The Solidity programming language has evolved quite a bit since its inception. Some features were introduced, some changed, while some eventually became obsolete and were removed altogether.</p> <p>While it's good for a programming language to evolve and better serve the needs of its users, not being able to easily upgrade or re-deploy existing contracts poses a unique challenge. Developer tooling must be able to understand and consume older contracts that are still being used on the blockchain, written in older versions of Solidity.</p> <p>Because of that, Slang must be able to reason about different versions of Solidity; how the language grammar, name capture rules, and semantics have changed across different versions. One of our goals is to document differences as part of our Solidity Grammar.</p> <p>This is why, instead of having to download separate versions of the tool for each Solidity version, you can access the Slang language APIs by simply specifying the Solidity version that you want to work with.</p>"},{"location":"user-guide/01-introduction/#error-tolerance-as-a-feature","title":"Error Tolerance as a feature","text":"<p>A core feature of Slang is that it is designed to be tolerant of errors. All of its APIs don't expect the input to be correct or complete.</p> <p>For example, when users are actively editing code in an IDE, the code will often have syntax errors or incomplete constructs. In that case, the parser will detect syntax errors, and instead of just stopping at the first error, it will mark the erroneous part as either unrecognized or missing, creating an error node, and continue to parse the rest of the file (example).</p> <p>Another example is the binding graph, which will work even when there are missing source files. The graph will mark any missing definitions as <code>undefined</code>, and still resolve all other symbols in files that do exist. This is critical for tools that need to work with Solidity code in any environment, even when dependencies are missing or not yet installed locally (example).</p>"},{"location":"user-guide/01-introduction/#distributions","title":"Distributions","text":"<p>Slang itself is written in Rust, compiled as a WASM component, and distributed as an npm package with a TypeScript interface. In the future, we are also looking into publishing it as a Rust crate, a Python library, and possibly more.</p>"},{"location":"user-guide/02-powered-by-slang/","title":"2. Powered By Slang","text":"<p>If you are interested in using Slang in your project, we would love to hear from you! Please reach out to us on our Telegram group, or via GitHub issues.</p> <p>Slang is already being used by a number of Solidity developer tools today, to name a few:</p>"},{"location":"user-guide/02-powered-by-slang/#solidity-vscode","title":"Solidity VSCode","text":"<p>Nomic Foundation\u2019s own Solidity VSCode extension, with over 300k downloads, is using it to provide advanced language features like Semantic Highlighting and Document Symbols. Other features are being migrated to Slang soon.</p> <ul> <li>VSCode Marketplace Page</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#prettier-solidity","title":"Prettier Solidity","text":"<p>The upcoming v2 release of the popular Prettier plugin for Solidity, enhancing code formatting speed and correctness for tens of thousands of Solidity projects across the ecosystem.</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#openzeppelin-upgrades","title":"OpenZeppelin Upgrades","text":"<p>OpenZeppelin Upgrades uses Slang to analyze the NatSpec comments to implement namespaced storage layout (ERC-7201).</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#sspec","title":"SSpec","text":"<p>SSpec is a Solidity specification generator for Foundry projects. Using test names it produces human readable descriptions for smart contracts, their functions, and facilitates navigation across tests providing links to functions in test files.</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#lintspec","title":"LintSpec","text":"<p>LintSpec is a tool for finding common errors in Solidity documentation. It is a port of natspec-smells to Rust, based on Slang, that is reported to be 214x faster.</p> <ul> <li>Rust Crate</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/03-concepts/","title":"3. Concepts","text":"<p>At its core, Slang is a collection of APIs that are meant to analyze the source code, starting with the source code itself and ending with a rich structure that can be reasoned about. This is a departure from the classic approach of \"black-box\" compilers, which are handed the input and only their output can be observed.</p>"},{"location":"user-guide/03-concepts/#language-grammar","title":"Language Grammar","text":"<p>The entire Solidity grammar (Across all supported versions) is defined in the Solidity Grammar section. You can use this as a guide when developing your own tools using Slang. The grammar is also included as documentation on top of the corresponding APIs (like <code>TerminalKind</code>, <code>NonterminalKind</code>, and <code>EdgeLabel</code> variants). It explains the structure of each node, and the relationships between each parent and its children.</p>"},{"location":"user-guide/03-concepts/#parser","title":"Parser","text":"<p>The <code>Parser</code> API is used to produce a Concrete Syntax Tree (CST) from Solidity source code. Each <code>Parser</code> object is initialized with a specific Solidity version.</p> <p>With a <code>Parser</code> object, you can analyze any source text according to the grammar of that specific version. Providing an accurate language version is important, as it affects the shape of the syntax tree, and possible errors produced. Check the Solidity Grammar for a list of supported versions.</p> <p>Each parse operation will produce a <code>ParseOutput</code> object, which contains the root of the CST corresponding to the input source code, and any syntax errors found during parsing.</p>"},{"location":"user-guide/03-concepts/#concrete-syntax-trees-cst","title":"Concrete Syntax Trees (CST)","text":"<p>Slang is capable of parsing the source code into a Concrete Syntax Tree (CST), which is a tree structure representing the entire source code. It includes the contracts, functions, statements, and expressions within. It also includes things like comments, whitespace, and punctuation. This is sometimes called a \"full-fidelity\" CST, and it can be used to reconstruct the original source code when needed.</p> <p>The tree nodes are represented by the <code>Node</code> structure, which can be one of two kinds:</p> <ul> <li><code>NonterminalNode</code> represents parent nodes, possibly containing children (sub-trees).</li> <li><code>TerminalNode</code> represents leaves (i.e. an identifier, keyword, or punctuation) in the tree.</li> </ul> <p>Nodes are connected through <code>Edge</code> objects, which contain a single child <code>Node</code>, and an <code>EdgeLabel</code> that describes the relationship between the parent and child.</p> <p>You can find a complete list of all grammar nodes and edges in the Solidity Grammar section.</p>"},{"location":"user-guide/03-concepts/#cursors","title":"Cursors","text":"<p>For many code analysis tasks, it is useful to traverse the parse tree and visit each node. The <code>Cursor</code> object allows callers to traverse the parse tree in an efficient pre-order manner.</p> <p>It provides several <code>goTo*()</code> navigation functions, each returning <code>true</code> if the cursor was successfully moved, and <code>false</code> otherwise. There are three main ways to do it:</p> <ul> <li>According to the order they appear in the tree, i.e. <code>goToNext()</code> and <code>goToPrevious()</code>,</li> <li>According to the relationship between the current node and the next node, i.e. <code>goToParent()</code>, <code>goToFirstChild()</code>, <code>goToNextNonDescendant()</code></li> <li>According to the kind of the next node, i.e. <code>goToNextTerminalWithKind(kind)</code>, <code>goToNextNonterminalWithKind(kind)</code></li> </ul> <p>As such, the cursor is stateful and keeps track of the path it has taken through the CST. It starts at the root it was created at and is completed when it reaches its root when navigating forward.</p> <p>Cursors can also be cloned, to allow for multiple traversals of the same tree, or spawned, to allow for traversing the subtree of the current node.</p>"},{"location":"user-guide/03-concepts/#queries","title":"Queries","text":"<p>The <code>Cursor</code> API is a low-level API that allows you to traverse the CST in a procedural manner. However, it is often more convenient to use the declarative <code>Query</code> API. Queries allow you to express your intent more concisely, and also allows you to reuse the same query in multiple places. Queries can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The tree query language is based on pattern matching, and the execution semantics are closer to unification than to regular expression matching i.e. a query returns all possible matches, not just the longest/shortest/first/last match. There is no concept of a 'greedy' operator for example.</p> <p>Query execution is based on cursors, and the resulting matches and unification captures are returned as cursors as well. This allows you to mix and match manual traversal, cursors, and queries.</p> <p>Multiple queries can be executed in a batch, and efficiently traverse the tree looking for matches. This mode of operation can replace all visitor patterns.</p>"},{"location":"user-guide/03-concepts/#abstract-syntax-trees-ast","title":"Abstract Syntax Trees (AST)","text":"<p>AST types are a set of abstractions that provide a typed view of the untyped CST nodes. You can convert any untyped CST node to its corresponding AST type using their constructors.</p> <p>There is a corresponding type for each <code>NonterminalKind</code> in the language. AST types are immutable. Additionally, their fields are constructed lazily as they are accessed for the first time.</p> <p>AST nodes maintain a reference to the CST node they were constructed from, and can be used to navigate to the corresponding CST node.</p>"},{"location":"user-guide/03-concepts/#compilation-unit","title":"Compilation Unit","text":"<p>A <code>CompilationUnit</code> is a collection of all source files that should be compiled together. This includes your main contract, and any imported files or dependencies that are used there.</p> <p>A <code>CompilationBuilder</code> is used to build a <code>CompilationUnit</code>. It is provided with a Solidity version, then the list of source files are incrementally added to it in any order. With each source file added, the builder will analyze all import statements within, and ask the user to resolve them to the imported source files, and continue loading/analyzing them, until it is complete.</p>"},{"location":"user-guide/03-concepts/#binding-graph","title":"Binding Graph","text":"<p>The <code>BindingGraph</code> is a graph structure that represents the relationships between identifiers across source files in a <code>CompilationUnit</code>. For each identifier, it will analyze if it is acting as a <code>Definition</code> or a <code>Reference</code> (aliases for example), and provide an API for users to resolve them.</p> <p>It can also be used to query the relationships between them; finding all references to a specific definition, or all definitions that are bound by a specific reference.</p>"},{"location":"user-guide/04-getting-started/","title":"4. Getting Started","text":"<ul> <li>4.1. Installation</li> <li>4.2. Choosing a Solidity Version</li> </ul>"},{"location":"user-guide/04-getting-started/01-installation/","title":"4.1. Installation","text":""},{"location":"user-guide/04-getting-started/01-installation/#adding-the-npm-package","title":"Adding the NPM package","text":"<p>You can install Slang NPM package simply by running the following <code>npm</code> command:</p> bash<pre><code>npm install \"@nomicfoundation/slang\"\n</code></pre> <p>Or if you are using <code>yarn</code> for package management:</p> bash<pre><code>yarn add \"@nomicfoundation/slang\"\n</code></pre>"},{"location":"user-guide/04-getting-started/01-installation/#esm-vs-commonjs","title":"ESM vs CommonJS","text":"<p>Slang is implemented in Rust, and compiled as a WASM component, which is exposed to TypeScript/JavaScript, and loaded asynchronously. If you are working with a modern ESM project, this will just work out of the box, with no additional configuration needed.</p> use-from-esm.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\n\ntest(\"top-level ESM import\", () =&gt; {\n  const parser = Parser.create(\"0.8.28\");\n  assert(parser);\n});\n</code></pre> <p>But if you are working with a legacy CommonJS project, asynchronous imports are not supported. In that case, you can use the <code>await import()</code> syntax to load Slang:</p> use-from-commonjs.mts<pre><code>import assert from \"node:assert\";\n\ntest(\"CommonJS await import\", async () =&gt; {\n  const { Parser } = await import(\"@nomicfoundation/slang/parser\");\n\n  const parser = Parser.create(\"0.8.28\");\n  assert(parser);\n});\n</code></pre>"},{"location":"user-guide/04-getting-started/02-choosing-a-solidity-version/","title":"4.2. Choosing a Solidity Version","text":"<p>Slang aims to support all Solidity language versions, starting with <code>0.4.11</code>, and adding support for all future versions as they are released.</p> <p>In order to use many of the Slang APIs, you will need to specify the Solidity version that you want to work with. You can see a list of all supported Solidity versions here.</p> <p>You can also access this list programmatically, by using the <code>LanguageFacts</code> API:</p> supported-versions.mts<pre><code>import assert from \"node:assert\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"supported versions\", () =&gt; {\n  assert.strictEqual(LanguageFacts.allVersions().length, 83);\n\n  assert.strictEqual(LanguageFacts.earliestVersion(), \"0.4.11\");\n\n  assert.strictEqual(LanguageFacts.latestVersion(), \"0.8.28\");\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/","title":"5. Syntax Trees","text":"<ul> <li>5.1. Parsing Source Code</li> <li>5.2. Handling Syntax Errors</li> <li>5.3. Navigating with Cursors</li> <li>5.4. Using AST Types</li> </ul>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/","title":"5.1. Using the Parser","text":"<p>The Parser API provides us with fine-grained control over the parsing process. It allows us to parse not just the input as a top-level source unit, but also individual constructs like contracts, various definitions, and even expressions.</p>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#parsing-source-files","title":"Parsing Source Files","text":"<p>Let's start with this simple source file, that contains a single contract, and parse it into a concrete syntax tree. The parser will produce a <code>ParseOutput</code> object, which contains a <code>SourceUnit</code> root node:</p> parsing-source-files.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { assertNonterminalNode, NonterminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"parsing source files\", () =&gt; {\n  const source = `\n    contract Foo {}\n  `;\n\n  const parser = Parser.create(\"0.8.28\");\n  const parseOutput = parser.parseFileContents(source);\n\n  assert(parseOutput.isValid());\n  assertNonterminalNode(parseOutput.tree, NonterminalKind.SourceUnit, source);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#parsing-nonterminals","title":"Parsing Nonterminals","text":"<p>The parser API also allows you to parse specific nonterminal nodes, like statements or expressions. This is useful when you want to parse a snippet, and not an entire source file, like the <code>AdditiveExpression</code> node below:</p> parsing-nonterminals.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertNonterminalNode,\n  assertTerminalNode,\n  EdgeLabel,\n  NonterminalKind,\n  TerminalKind,\n} from \"@nomicfoundation/slang/cst\";\n\ntest(\"parsing nonterminals\", () =&gt; {\n  const source = `x+y`;\n\n  const parser = Parser.create(\"0.8.28\");\n  const parseOutput = parser.parseNonterminal(NonterminalKind.AdditiveExpression, source);\n\n  assert(parseOutput.isValid());\n  assertNonterminalNode(parseOutput.tree, NonterminalKind.AdditiveExpression, source);\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assert.strictEqual(children[0].label, EdgeLabel.LeftOperand);\n  assertNonterminalNode(children[0].node, NonterminalKind.Expression, \"x\");\n\n  assert.strictEqual(children[1].label, EdgeLabel.Operator);\n  assertTerminalNode(children[1].node, TerminalKind.Plus, \"+\");\n\n  assert.strictEqual(children[2].label, EdgeLabel.RightOperand);\n  assertNonterminalNode(children[2].node, NonterminalKind.Expression, \"y\");\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#handling-trivia-nodes","title":"Handling Trivia Nodes","text":"<p>Trivia nodes represent comments, whitespace, newlines, and other non-essential terminals that can appear anywhere in the source code, and they are categorized by the parser into two groups:</p> <ul> <li>Leading Trivia: terminals that appear before a significant terminal, and can span multiple lines (for example, documentation comments).</li> <li>Trailing Trivia: terminals that appear after a significant terminal on the same line, leading to, and including, the following newline terminal.</li> </ul> <p>You can use the <code>TerminalKindExtensions.isTrivia()</code> API to check if a terminal is a trivia terminal.</p> handling-trivia.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertTerminalNode,\n  EdgeLabel,\n  NonterminalKind,\n  TerminalKind,\n  TerminalKindExtensions,\n} from \"@nomicfoundation/slang/cst\";\n\ntest(\"handling trivia\", () =&gt; {\n  const source = `  true\\n`;\n\n  const parser = Parser.create(\"0.8.28\");\n  const parseOutput = parser.parseNonterminal(NonterminalKind.Expression, source);\n  assert(parseOutput.isValid());\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assert.strictEqual(children[0].label, EdgeLabel.LeadingTrivia);\n  assertTerminalNode(children[0].node, TerminalKind.Whitespace, \"  \");\n  assert(TerminalKindExtensions.isTrivia(children[0].node.kind));\n\n  assert.strictEqual(children[1].label, EdgeLabel.Variant);\n  assertTerminalNode(children[1].node, TerminalKind.TrueKeyword, \"true\");\n  assert(!TerminalKindExtensions.isTrivia(children[1].node.kind));\n\n  assert.strictEqual(children[2].label, EdgeLabel.TrailingTrivia);\n  assertTerminalNode(children[2].node, TerminalKind.EndOfLine, \"\\n\");\n  assert(TerminalKindExtensions.isTrivia(children[2].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/","title":"5.2. Handling Syntax Errors","text":"<p>If there are syntax errors with the input, the <code>ParseOutput</code> object will contain the list of errors found. Each error will have a message, and a <code>TextRange</code> that indicates the location of the error in the input.</p> <p>Additionally, the parsed tree will contain an error node for each error encountered, which can be one of two kinds, missing or unrecognized, depending on the error.</p> <p>You can use the <code>TerminalKindExtensions.isValid()</code> API to check if a terminal is valid or is an error node.</p>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/#missing-nodes","title":"Missing Nodes","text":"<p>These occur when the parser expects a certain node to be present, but it is not. It will create a missing node in its place, and continue parsing as if it was present.</p> missing-error-nodes.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { assertTerminalNode, NonterminalKind, TerminalKind, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\n\ntest(\"missing error nodes\", () =&gt; {\n  const source = `contract`;\n\n  const parser = Parser.create(\"0.8.28\");\n  const parseOutput = parser.parseNonterminal(NonterminalKind.ContractDefinition, source);\n  assert(!parseOutput.isValid());\n\n  const errors = parseOutput.errors();\n  assert.strictEqual(errors.length, 1);\n\n  assert.strictEqual(errors[0].message, \"Expected Identifier.\");\n  assert.deepStrictEqual(errors[0].textRange, {\n    start: { line: 0, column: 8, utf8: 8, utf16: 8 },\n    end: { line: 0, column: 8, utf8: 8, utf16: 8 },\n  });\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 2);\n\n  assertTerminalNode(children[0].node, TerminalKind.ContractKeyword, \"contract\");\n\n  assertTerminalNode(children[1].node, TerminalKind.Missing, \"\");\n  assert(!TerminalKindExtensions.isValid(children[1].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/#unrecognized-nodes","title":"Unrecognized Nodes","text":"<p>These occur when the parser encounters a token that it does not recognize, and it cannot parse. It will create an unrecognized node in its place, and continue parsing as if it doesn't exist.</p> unrecognized-error-nodes.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertNonterminalNode,\n  assertTerminalNode,\n  NonterminalKind,\n  TerminalKind,\n  TerminalKindExtensions,\n} from \"@nomicfoundation/slang/cst\";\n\ntest(\"unrecognized error nodes\", () =&gt; {\n  const source = `\n    foo();\n    %`;\n\n  const parser = Parser.create(\"0.8.28\");\n  const parseOutput = parser.parseNonterminal(NonterminalKind.Statements, source);\n  assert(!parseOutput.isValid());\n\n  const errors = parseOutput.errors();\n  assert.strictEqual(errors.length, 1);\n\n  assert.match(errors[0].message, /^Expected AddressKeyword or/);\n  assert.deepStrictEqual(errors[0].textRange, {\n    start: { line: 2, column: 4, utf8: 16, utf16: 16 },\n    end: { line: 2, column: 5, utf8: 17, utf16: 17 },\n  });\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assertNonterminalNode(children[0].node, NonterminalKind.Statement);\n\n  assertTerminalNode(children[1].node, TerminalKind.Whitespace, \"    \");\n  assert(TerminalKindExtensions.isValid(children[1].node.kind));\n\n  assertTerminalNode(children[2].node, TerminalKind.Unrecognized, \"%\");\n  assert(!TerminalKindExtensions.isValid(children[2].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/","title":"5.3. Using Cursors","text":"<p>This guide will walk you through the basics of using a CST cursor in your project. Let's start with this source file, that contains three contracts:</p> common.mts<pre><code>import assert from \"node:assert\";\nimport { ParseOutput, Parser } from \"@nomicfoundation/slang/parser\";\n\nexport function createTree(): ParseOutput {\n  const source = `\n    contract Foo {\n      function foo_func() {}\n    }\n    contract Bar {\n      function bar_func() {}\n    }\n    contract Baz {\n      function baz_func() {}\n    }\n  `;\n\n  const parser = Parser.create(\"0.8.28\");\n\n  const parseOutput = parser.parseFileContents(source.trim());\n  assert(parseOutput.isValid());\n\n  return parseOutput;\n}\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#listing-contract-names","title":"Listing Contract Names","text":"<p>The below example uses a cursor to list the names of all contracts in a source file:</p> listing-contract-names.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"listing contract names\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const contracts = [];\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n    assert(cursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n    contracts.push(cursor.node.unparse());\n  }\n\n  assert.deepStrictEqual(contracts, [\"Foo\", \"Bar\", \"Baz\"]);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#visiting-only-a-sub-tree","title":"Visiting Only a Sub-tree","text":"<p>Next, we will try to get the names of all contract functions, grouped by the contract name. In this case, it is not enough to just visit all instances of <code>FunctionDefinition</code> nodes, since we want to exclude the ones that are not part of a contract.</p> <p>We need first to find all <code>ContractDefinition</code> nodes, and then for each contract, look for all <code>FunctionDefinition</code> nodes, limiting the search to just the contract's subtree. To do that, we need to use the <code>cursor.spawn()</code> API, which cheaply creates a new cursor that starts at the given node, without copying the ancestry information, so it will only be able to see the sub-tree of the current node.</p> visiting-subtrees.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"visiting subtrees\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const results: { [contractName: string]: string[] } = {};\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n    const childCursor = cursor.spawn();\n    assert(childCursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n    const contractName = childCursor.node.unparse();\n    results[contractName] = [];\n\n    while (childCursor.goToNextNonterminalWithKind(NonterminalKind.FunctionDefinition)) {\n      assert(childCursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n      results[contractName].push(childCursor.node.unparse());\n    }\n  }\n\n  assert.deepStrictEqual(results, {\n    Foo: [\"foo_func\"],\n    Bar: [\"bar_func\"],\n    Baz: [\"baz_func\"],\n  });\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#accessing-node-positions","title":"Accessing Node Positions","text":"<p>The <code>Cursor</code> API also tracks the position and range of the current node it is visiting. Here is an example that records the line number of each function, along with its text:</p> accessing-node-positions.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"accessing node positions\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const functions = [];\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.FunctionDefinition)) {\n    const line = cursor.textRange.start.line;\n    const text = cursor.node.unparse().trim();\n\n    functions.push({ line, text });\n  }\n\n  assert.deepStrictEqual(functions, [\n    { line: 1, text: \"function foo_func() {}\" },\n    { line: 4, text: \"function bar_func() {}\" },\n    { line: 7, text: \"function baz_func() {}\" },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/04-using-ast-types/","title":"5.4. Using AST Types","text":"<p>So far we've been using the CST of a Solidity file or fragment. However, the CST is too verbose, and not always convenient to use for extracting information of the program. In the following example, we are going to show how to obtain the parameters and attributes of a function using the AST, an abstract representation of the program tree.</p> <p>We start as usual by parsing the input, and then we can use the <code>ParseOutput</code> root to create the CST type. Since it is a node of kind <code>FunctionDefinition</code>, we are using the AST type of the same name to analyze it.</p> <p>The <code>FunctionDefinition</code> type has named fields to access all its children. For example, we can check the name of the function, list its parameters, or attributes:</p> using-ast-types.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { FunctionDefinition } from \"@nomicfoundation/slang/ast\";\n\ntest(\"using the ast\", async () =&gt; {\n  const source = `\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\n      return a + b;\n    }\n  `;\n\n  const parser = Parser.create(\"0.8.28\");\n\n  const parseOutput = parser.parseNonterminal(NonterminalKind.FunctionDefinition, source);\n  assert(parseOutput.isValid());\n\n  const func = new FunctionDefinition(parseOutput.tree);\n  assert.strictEqual(func.name.variant.unparse(), \"add\");\n\n  const parameters = func.parameters.parameters.items.map((parameter) =&gt; parameter.cst.unparse().trim());\n  assert.deepEqual(parameters, [\"uint256 a\", \"uint256 b\"]);\n\n  const attributes = func.attributes.items.map((attribute) =&gt; attribute.cst.unparse().trim());\n  assert.deepEqual(attributes, [\"public\", \"pure\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/","title":"6. Query Language","text":"<ul> <li>6.1. Query Syntax</li> <li>6.2. Executing Queries</li> </ul>"},{"location":"user-guide/06-query-language/01-query-syntax/","title":"6.1. Query Syntax","text":"<p>It's often more convenient to use the declarative <code>Query</code> API to traverse the CST, as they allow you to express your intent more concisely and can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The query engine performs pattern matching, and the execution semantics are closer to unification than to regular expression matching. A query returns all possible matches, not just the longest/shortest/first/last match.</p>"},{"location":"user-guide/06-query-language/01-query-syntax/#matching","title":"Matching","text":"<p>A query is a pattern that matches a certain set of nodes in a tree. The expression to match a given node consists of a pair of brackets (<code>[]</code>) containing two things: the node's kind, and optionally, a series of other patterns that match the node's children. For example, this pattern would match any <code>MultiplicativeExpression</code> node that has two children <code>Expression</code> nodes, with an <code>Asterisk</code> node in between:</p> <pre><code>[MultiplicativeExpression\n  [Expression]\n  [Asterisk]\n  [Expression]\n]\n</code></pre> <p>The children of a node can optionally be labeled. The label is a property of the edge from the node to the child, and is not a property of the child. For example, this pattern will match a <code>MultiplicativeExpression</code> node with the two <code>Expression</code> children labeled <code>left_operand</code> and <code>right_operand</code>:</p> <pre><code>[MultiplicativeExpression\n  left_operand: [Expression]\n  [Asterisk]\n  right_operand: [Expression]\n]\n</code></pre> <p>You can also match a node's textual content using a string literal. For example, this pattern would match a <code>MultiplicativeExpression</code> with a <code>*</code> operator (for clarity):</p> <pre><code>[MultiplicativeExpression\n  left_operand: [_]\n  operator: [\"*\"]\n  right_operand: [_]\n]\n</code></pre> <p>If you don't care about the kind of a node, you can use an underscore <code>_</code>, which matches any kind. For example, this pattern will match a <code>MultiplicativeExpression</code> node with any two children with any kind, as long as one of them is labeled <code>left_operand</code>:</p> <pre><code>[MultiplicativeExpression\n  left_operand: [_]\n  [_]\n]\n</code></pre> <p>Children can be elided. For example, this would produce multiple matches for a <code>MultiplicativeExpression</code> where at least one of the children is an expression of a <code>StringExpression</code> variant, where each match is associated with each of the <code>StringExpression</code> children:</p> <pre><code>[MultiplicativeExpression\n  [Expression\n    [StringExpression]\n  ]\n]\n</code></pre> <p>Trivia nodes (whitespace, comments, etc.) will be skipped over when running a query. Furthermore, trivia nodes cannot be explicitly (or implicitly with <code>_</code>) matched by queries.</p>"},{"location":"user-guide/06-query-language/01-query-syntax/#capturing","title":"Capturing","text":"<p>When matching patterns, you may want to process specific nodes within the pattern. Captures allow you to associate names with specific nodes in a pattern, so that you can later refer to those nodes by those names. Capture names are written before the nodes that they refer to, and start with an <code>@</code> character.</p> <p>For example, this pattern would match any struct definition and it would associate the name <code>struct_name</code> with the identifier:</p> <pre><code>[StructDefinition\n  @struct_name name: [Identifier]\n]\n</code></pre> <p>And this pattern would match all event definitions for a contract, associating the name <code>event_name</code> with the event name, <code>contract_name</code> with the containing contract name:</p> <pre><code>[ContractDefinition\n  @contract_name name: [Identifier]\n  members: [ContractMembers\n    [ContractMember\n      [EventDefinition\n        @event_name name: [Identifier]\n      ]\n    ]\n  ]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#quantification","title":"Quantification","text":"<p>You can surround a sequence of patterns in parenthesis (<code>()</code>), followed by a <code>?</code>, <code>*</code> or <code>+</code> operator. The <code>?</code> operator matches zero or one repetitions of a pattern, the <code>*</code> operator matches zero or more, and the <code>+</code> operator matches one or more.</p> <p>For example, this pattern would match a sequence of one or more import directives at the top of the file:</p> <pre><code>[SourceUnit\n  members: [\n    _\n    ([_ @import [ImportDirective]])+\n  ]\n]\n</code></pre> <p>This pattern would match a structure definition with one or more members, capturing their names:</p> <pre><code>[StructDefinition\n  @name name: [_]\n  members: [\n    _\n    ([_ @member [Identifier]])+\n  ]\n]\n</code></pre> <p>This pattern would match all function calls, capturing a string argument if one was present:</p> <pre><code>[FunctionCallExpression\n  arguments: [ArgumentsDeclaration\n    variant: [PositionalArgumentsDeclaration\n      arguments: [PositionalArguments\n        (@arg [Expression variant: [StringExpression]])?\n      ]\n    ]\n  ]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#alternation","title":"Alternation","text":"<p>An alternation is written as a sequence of patterns separated by <code>|</code> and surrounded by parentheses.</p> <p>For example, this pattern would match a call to either a variable or an object property. In the case of a variable, capture it as <code>@function</code>, and in the case of a property, capture it as <code>@method</code>:</p> <pre><code>[FunctionCallExpression\n  operand: [Expression\n    (\n        @function variant: [Identifier]\n      | @method variant: [MemberAccessExpression]\n    )\n  ]\n]\n</code></pre> <p>This pattern would match a set of possible keyword terminals, capturing them as <code>@keyword</code>:</p> <pre><code>@keyword (\n    [\"break\"]\n  | [\"delete\"]\n  | [\"else\"]\n  | [\"for\"]\n  | [\"function\"]\n  | [\"if\"]\n  | [\"return\"]\n  | [\"try\"]\n  | [\"while\"]\n)\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#adjacency","title":"Adjacency","text":"<p>By using the adjacency operator <code>.</code> you can constrain a pattern to only match the first or the last child nodes.</p> <p>For example, the following pattern would match only the first parameter declaration in a function definition:</p> <pre><code>[FunctionDefinition\n  [ParametersDeclaration\n    [Parameters\n      .\n      @first_param [Parameter]\n    ]\n  ]\n]\n</code></pre> <p>And conversely the following will match only the last parameter:</p> <pre><code>[FunctionDefinition\n  [ParametersDeclaration\n    [Parameters\n      @last_param [Parameter]\n      .\n    ]\n  ]\n]\n</code></pre> <p>If the adjacency operator is used in between two patterns it constrains matches on both patterns to occur consecutively, ie. without any other sibling node in between. For example, this pattern matches pairs of consecutive statements:</p> <pre><code>[Statements\n  @stmt1 [Statement]\n  .\n  @stmt2 [Statement]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/","title":"6.2. Executing Queries","text":"<p>Queries are executed starting from any cursor that you can create with the Parser and Cursor APIs. Usually you'll run a query from either the root of the parse result <code>parseOutput.createTreeCursor()</code> or from a cursor created with <code>cursor.spawn()</code> to restrict the search to a given sub-tree.</p>"},{"location":"user-guide/06-query-language/02-executing-queries/#creating-and-executing-queries","title":"Creating and executing queries","text":"<p>You can create a <code>Query</code> object using <code>Query.create()</code>, which accepts a string value. These can be then used by <code>cursor.query()</code> to execute it.</p> <p>You can pass multiple queries to a cursor to and efficiently traverse the tree looking for matches. They will be executed simultaneously, returning matches in the order they appear in input.</p> common.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { Query, QueryMatchIterator } from \"@nomicfoundation/slang/cst\";\n\nexport function executeQueries(soliditySource: string, queries: Query[]): QueryMatchIterator {\n  const parser = Parser.create(\"0.8.28\");\n\n  const parseOutput = parser.parseFileContents(soliditySource);\n  assert(parseOutput.isValid());\n\n  return parseOutput.createTreeCursor().query(queries);\n}\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#iterating-over-node-patterns","title":"Iterating over node patterns","text":"<p>Queries allow you to iterate over all node patterns that match the query, which can replace your need for manual iteration via cursors or visitors. Each match has a cursor that points to the node matched by the outermost pattern in the query. This is called the match root.</p> <p>Let's use this to list all the contract definitions in a source file:</p> match-roots.mts<pre><code>import assert from \"node:assert\";\nimport { executeQueries } from \"./common.mjs\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\n\ntest(\"match roots\", () =&gt; {\n  const matches = executeQueries(\n    `\n      contract Foo {}\n      contract Bar {}\n      contract Baz {}\n    `,\n    [\n      Query.create(`\n        [ContractDefinition]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    found.push(match.root.node.unparse().trim());\n  }\n\n  assert.deepStrictEqual(found, [\"contract Foo {}\", \"contract Bar {}\", \"contract Baz {}\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#capturing-nodes-by-name","title":"Capturing nodes by name","text":"<p>You can also capture specific nodes in the query by name, and get a cursor to each of them:</p> <p>Let's use this to list all the contract names:</p> match-captures.mts<pre><code>import assert from \"node:assert\";\nimport { executeQueries } from \"./common.mjs\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\n\ntest(\"match captures\", () =&gt; {\n  const matches = executeQueries(\n    `\n      contract Foo {}\n      contract Bar {}\n      contract Baz {}\n    `,\n    [\n      Query.create(`\n        [ContractDefinition\n          @name name: [Identifier]\n        ]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    const names = match.captures[\"name\"];\n    assert.strictEqual(names.length, 1);\n\n    found.push(names[0].node.unparse());\n  }\n\n  assert.deepStrictEqual(found, [\"Foo\", \"Bar\", \"Baz\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#detecting-query-errors","title":"Detecting Query errors","text":"<p>If there is a mistake in your query, for example, if you use an invalid node kind, you will get a <code>QueryError</code> exception. The error will contain a message to indicate what went wrong, and the text range in the query where the error occurred.</p> query-errors.mts<pre><code>import assert from \"node:assert\";\nimport { Query, QueryError } from \"@nomicfoundation/slang/cst\";\n\ntest(\"query errors\", () =&gt; {\n  try {\n    Query.create(`\n      [NonExistingNode]\n    `);\n  } catch (error) {\n    const queryError = error as QueryError;\n\n    assert.strictEqual(\n      queryError.message.trim(),\n      `Parse error:\\n'NonExistingNode' is not a valid node kind at: NonExistingNode]`,\n    );\n\n    assert.deepStrictEqual(queryError.textRange, {\n      start: { line: 1, column: 7, utf8: 8, utf16: 8 },\n      end: { line: 2, column: 4, utf8: 29, utf16: 29 },\n    });\n  }\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#multiple-queries-simultaneously","title":"Multiple queries simultaneously","text":"<p>We can also execute multiple queries simultaneously, which will return all the matches for as they are found in the tree. This can be useful when you want to match multiple types of nodes in a single pass. Results will be reported in order, and each will have an index that can be used to identify which query is matched.</p> multiple-queries.mts<pre><code>import assert from \"node:assert\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\nimport { executeQueries } from \"./common.mjs\";\n\ntest(\"multiple queries\", () =&gt; {\n  const matches = executeQueries(\n    `\n      struct Foo { uint a; }\n      enum Bar { A, B }\n      struct Baz { uint b; uint c; }\n      enum Qux { C, D }\n    `,\n    [\n      Query.create(`\n        [StructDefinition\n          @name [Identifier]\n        ]\n      `),\n      Query.create(`\n        [EnumDefinition\n          @name [Identifier]\n        ]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    const names = match.captures[\"name\"];\n    assert.strictEqual(names.length, 1);\n\n    found.push({\n      queryIndex: match.queryIndex,\n      name: names[0].node.unparse(),\n    });\n  }\n\n  assert.deepStrictEqual(found, [\n    { queryIndex: 0, name: \"Foo\" },\n    { queryIndex: 1, name: \"Bar\" },\n    { queryIndex: 0, name: \"Baz\" },\n    { queryIndex: 1, name: \"Qux\" },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/","title":"7. Semantic Analysis","text":"<ul> <li>7.1. Compilation Units</li> <li>7.2. Binding Graph</li> <li>7.3. Solidity Builtins</li> </ul>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/","title":"7.1. Compilation Units","text":"<p>In order for Slang to perform semantic analysis on a program, it first needs to compile a list of all source files into a single <code>CompilationUnit</code>.</p> <p>We offer a <code>CompilationBuilder</code> API that allows you easily do that. It will parse the provided source files, analyze the import statements within, and then transitively resolve all dependencies, until all source files have been loaded.</p> <p>It is important to note that Slang is designed to be modular, and work in any environment (CLI, browser, etc..). This means it cannot access the file system directly, or make any assumptions about where your contracts are, and where their dependencies are installed.</p> <p>Instead, it expects the user to provide it with a couple of callbacks to handle these tasks:</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#reading-files","title":"Reading Files","text":"<p>The first callback is a function that will read the contents of a source file. That typically means using an API like NodeJS's <code>fs.readFile()</code> for local files, or browser's <code>fetch()</code> for remote ones.</p> <p>Note that this API is also error-tolerant. If the file is not found, or cannot be read, your callback can simply return <code>undefined</code> to indicate that the file is not available.</p> <p>For simplicity, let's assume that we have the source files defined in code:</p> read-file.mts<pre><code>const VIRTUAL_FS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\n      import { Log } from \"events.sol\";\n\n      contract MyContract {\n        function test() public {\n          emit Log(msg.sender, \"Hello World!\");\n        }\n      }\n    `,\n  ],\n  [\n    \"events.sol\",\n    `\n      event Log(address indexed sender, string message);\n    `,\n  ],\n]);\n\nexport async function readFile(fileId: string) {\n  return VIRTUAL_FS.get(fileId);\n}\n</code></pre> <p>The exact semantics of the <code>fileId</code> used throughout the Compilation API will depend on your implementation of the <code>readFile</code> callback. They could be paths, URLs, or opaque IDs.</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#resolving-imports","title":"Resolving Imports","text":"<p>The second callback is a function that will resolve an import statement to the imported source file. In a real-world scenario, dependencies can be imported from relative paths on disk, a remote provider like IPFS, or even NPM packages.</p> <p>For example, a package manager like <code>npm</code> would install the dependencies into sub-directory of <code>node_modules</code>, and users can then resolve their locations via NodeJS <code>path.resolve()</code> or browsers <code>import.meta.resolve()</code> APIs.</p> <p>Note that likewise, this API is also error-tolerant. If the import cannot be resolved, your callback can also return <code>undefined</code> to indicate that the import is not available, and the builder will skip it.</p> <p>For simplicity, let's just assume that dependencies will always be imported by their bare file name:</p> resolve-import.mts<pre><code>import { Cursor } from \"@nomicfoundation/slang/cst\";\n\nexport async function resolveImport(_sourceFileId: string, importPath: Cursor) {\n  // cursor points to the import string literal:\n  const importLiteral = importPath.node.unparse();\n\n  // remove surrounding quotes:\n  const importString = importLiteral.replace(/^[\"']/, \"\").replace(/[\"']$/, \"\");\n\n  return importString;\n}\n</code></pre> <p>The import resolution callback should return a <code>fileId</code>, and should be meaningful to the <code>readFile</code> callback. We use filenames here, but URLs or opaque unique IDs would work as well.</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#running-the-compilation-builder","title":"Running the compilation builder","text":"<p>With these callbacks defined, we can now create a <code>CompilationBuilder</code> and add our source files to it. Note that in the example below, we don't need to add dependencies, as they will be resolved and loaded automatically.</p> compilation-builder.mts<pre><code>import { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { readFile } from \"./read-file.mjs\";\nimport { resolveImport } from \"./resolve-import.mjs\";\n\nexport async function buildCompilationUnit(): Promise&lt;CompilationUnit&gt; {\n  const builder = CompilationBuilder.create({\n    languageVersion: \"0.8.28\",\n    readFile,\n    resolveImport,\n  });\n\n  await builder.addFile(\"contract.sol\");\n\n  return builder.build();\n}\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#inspecting-the-compilation-unit","title":"Inspecting the compilation unit","text":"<p>The built <code>CompilationUnit</code> will then contain all the source files, along with their syntax trees.</p> compilation-unit.mts<pre><code>import assert from \"node:assert\";\nimport { assertNonterminalNode, NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\n\ntest(\"compilation unit\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n\n  const files = unit.files();\n  assert.equal(files.length, 2);\n\n  assert.equal(files[0].id, \"contract.sol\");\n  assertNonterminalNode(files[0].tree, NonterminalKind.SourceUnit);\n\n  assert.equal(files[1].id, \"events.sol\");\n  assertNonterminalNode(files[1].tree, NonterminalKind.SourceUnit);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/","title":"7.2. Binding Graph","text":"<p>The binding graph is a graph structure that represents the relationships between identifiers across source files in a <code>CompilationUnit</code>. It stores cursors to all definitions and references, and can resolve the edges between them.</p> <p>Building this graph can be an expensive operation. So, it is constructed lazily on the first access, and cached thereafter. You can use cursors to query the graph for definitions or references.</p> <p>Any identifier in the tree can be resolved to a definition or a reference. Note that there are multiple kinds of identifiers. For example, Solidity has <code>Identifier</code>, and Yul has <code>YulIdentifier</code>. To find/filter terminals that are identifiers, you can use the <code>TerminalKindExtensions.isIdentifier()</code> API to test for that.</p>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#resolving-definitions","title":"Resolving Definitions","text":"<p>To resolve definitions we need to provide the binding graph with a cursor pointing to the identifier. Some identifiers in the code may not be acting as definitions. In those cases, <code>definitionAt()</code> will return <code>undefined</code>.</p> <p><code>Definition</code> objects will contain two binding locations:</p> <ul> <li><code>nameLocation</code> referring to the identifier that resolved to the definition</li> <li><code>definiensLocation</code> referring to the CST node that is being defined (a contract, function, struct, etc)</li> </ul> <p>Because binding graphs span multiple files, these locations are not simple <code>Cursor</code> objects. Instead they are <code>BindingLocation</code> objects, which can refer to locations in user files or built-ins:</p> <ul> <li><code>UserFileLocation</code> in turn contains the <code>fileId</code> and the <code>cursor</code> in the CST tree of the file.</li> <li><code>BuiltInLocation</code> refers to a location in system defined built-in. You may get a definition on such a location when finding which definitions a <code>Reference</code> binds to (see section below), but never when resolving to a definition from a cursor.</li> </ul> find-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation, Definition } from \"@nomicfoundation/slang/bindings\";\n\nexport function findDefinitionsInFile(unit: CompilationUnit, fileId: string): Definition[] {\n  const file = unit.file(fileId);\n  assert(file);\n\n  const definitions = [];\n\n  // traverse the file's CST tree looking for identifiers\n  const cursor = file.createTreeCursor();\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n      continue;\n    }\n\n    // attempt to resolve a definition\n    const definition = unit.bindingGraph.definitionAt(cursor);\n\n    if (definition) {\n      // name should be located in the file we queried\n      assertUserFileLocation(definition.nameLocation);\n      assert.strictEqual(definition.nameLocation.fileId, fileId);\n\n      // definiens should too be located in the file we queried\n      assertUserFileLocation(definition.definiensLocation);\n      assert.strictEqual(definition.definiensLocation.fileId, fileId);\n\n      definitions.push(definition);\n    }\n  }\n\n  return definitions;\n}\n</code></pre> <p>User file binding locations will also contain a <code>cursor</code> to the underlying identifier or CST node of the entity defined. Using the same contract from last section, we can look for definitions in the <code>contract.sol</code> file:</p> resolving-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findDefinitionsInFile } from \"./find-definitions.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"find definitions in file\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const definitions = findDefinitionsInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const definition of definitions) {\n    assertUserFileLocation(definition.nameLocation);\n    const name = definition.nameLocation.cursor.node.unparse();\n\n    assertUserFileLocation(definition.definiensLocation);\n    const kind = definition.definiensLocation.cursor.node.kind;\n\n    found.push({ name, kind });\n  }\n\n  assert.strictEqual(found.length, 3);\n  assert.deepEqual(found, [\n    { name: \"Log\", kind: NonterminalKind.ImportDeconstructionSymbol },\n    { name: \"MyContract\", kind: NonterminalKind.ContractDefinition },\n    { name: \"test\", kind: NonterminalKind.FunctionDefinition },\n  ]);\n});\n</code></pre> <p>We find 3 definitions:</p> <ul> <li>the <code>Log</code> imported symbol</li> <li>the <code>MyContract</code> contract</li> <li>the <code>test</code> method</li> </ul> <p>The <code>Log</code> import symbol is a special case and also acts as a reference to the actual event type defined in <code>events.sol</code>. Let's find all references in the file next.</p>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#resolving-references","title":"Resolving References","text":"<p>In the same way to resolving definitions, we can also attempt to resolve a cursor to an identifier to a reference. If the resolution is successful, the returned <code>Reference</code> will have a <code>location</code> pointing to the identifier. As before, we can expect this location to be in the user file whose CST tree we are querying.</p> find-references.mts<pre><code>import assert from \"node:assert\";\nimport { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation, Reference } from \"@nomicfoundation/slang/bindings\";\n\nexport function findReferencesInFile(unit: CompilationUnit, fileId: string): Reference[] {\n  const file = unit.file(fileId);\n  assert(file);\n\n  const references = [];\n\n  // traverse the file's CST tree looking for identifiers\n  const cursor = file.createTreeCursor();\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n      continue;\n    }\n\n    // attempt to resolve a reference\n    const reference = unit.bindingGraph.referenceAt(cursor);\n\n    if (reference) {\n      // should be located in the file we queried\n      assertUserFileLocation(reference.location);\n      assert.strictEqual(reference.location.fileId, fileId);\n\n      references.push(reference);\n    }\n  }\n\n  return references;\n}\n</code></pre> <p>We can now find all the references in the same <code>contract.sol</code> file:</p> resolving-references.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findReferencesInFile } from \"./find-references.mjs\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"find references in file\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const references = findReferencesInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    const name = reference.location.cursor.node.unparse();\n    const line = reference.location.cursor.textRange.start.line;\n\n    found.push({ name, line });\n  }\n\n  assert.strictEqual(found.length, 4);\n  assert.deepEqual(found, [\n    { name: \"Log\", line: 1 },\n    { name: \"Log\", line: 5 },\n    { name: \"msg\", line: 5 },\n    { name: \"sender\", line: 5 },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#navigating-between-definitions-and-references","title":"Navigating between definitions and references","text":"<p>Iterating over the references found in the last section, we can find where are the definitions they refer to by using the <code>definitions()</code> method of <code>Reference</code>:</p> references-to-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findReferencesInFile } from \"./find-references.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"navigate from references to definitions\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const references = findReferencesInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    const name = reference.location.cursor.node.unparse();\n    const line = reference.location.cursor.textRange.start.line;\n\n    // find definitions this reference binds to\n    const definitions = [];\n    for (const definition of reference.definitions()) {\n      if (definition.nameLocation.isUserFileLocation() &amp;&amp; definition.definiensLocation.isUserFileLocation()) {\n        // it's a user provided definition\n        definitions.push({\n          file: definition.nameLocation.fileId,\n          kind: definition.definiensLocation.cursor.node.kind,\n        });\n      } else {\n        // it's a built-in\n        definitions.push({ file: \"BUILT-IN\" });\n      }\n    }\n\n    found.push({ name, line, definitions });\n  }\n\n  assert.strictEqual(found.length, 4);\n  assert.deepEqual(found, [\n    { name: \"Log\", line: 1, definitions: [{ file: \"events.sol\", kind: NonterminalKind.EventDefinition }] },\n    {\n      name: \"Log\",\n      line: 5,\n      definitions: [\n        { file: \"contract.sol\", kind: NonterminalKind.ImportDeconstructionSymbol },\n        { file: \"events.sol\", kind: NonterminalKind.EventDefinition },\n      ],\n    },\n    { name: \"msg\", line: 5, definitions: [{ file: \"BUILT-IN\" }] },\n    { name: \"sender\", line: 5, definitions: [{ file: \"BUILT-IN\" }] },\n  ]);\n});\n</code></pre> <p>There are two interesting observations here:</p> <ul> <li>Slang recognizes the Solidity built-in global variable <code>msg</code> and its member <code>sender</code>. See next section for more details and an example use case.</li> <li>There may be multiple definitions bound to our reference: the <code>Log</code> identifier in the <code>emit</code> statement refers to the imported symbol, and also to the event type which is declared in a different file.</li> </ul> <p>There are other cases where Slang may return multiple definitions for a reference. Function overloads and virtual method calls are typical examples.</p> <p>Starting from a definition, we can also query the binding graph for all places where it's being referred to with the method <code>references()</code> of <code>Definition</code> objects. In this example, we navigate from the <code>Log</code> event definition in <code>events.sol</code> back to the two references in <code>contract.sol</code>:</p> definitions-to-references.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findDefinitionsInFile } from \"./find-definitions.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"navigate from definitions to references\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const definitions = findDefinitionsInFile(unit, \"events.sol\");\n\n  // there are three definitions in the file: the event and its two parameters\n  assert.strictEqual(definitions.length, 3);\n\n  // we only care about the event type definition for this example\n  const logEvent = definitions[0];\n  assertUserFileLocation(logEvent.definiensLocation);\n  assert.strictEqual(logEvent.definiensLocation.cursor.node.kind, NonterminalKind.EventDefinition);\n\n  // find references bound to its definition\n  const references = logEvent.references();\n  assert.strictEqual(references.length, 2);\n\n  // first should be the import statement\n  assertUserFileLocation(references[0].location);\n  assert.strictEqual(references[0].location.fileId, \"contract.sol\");\n  assert.strictEqual(references[0].location.cursor.textRange.start.line, 1);\n\n  // second should be the emit statement\n  assertUserFileLocation(references[1].location);\n  assert.strictEqual(references[1].location.fileId, \"contract.sol\");\n  assert.strictEqual(references[1].location.cursor.textRange.start.line, 5);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/03-solidity-builtins/","title":"7.3. Solidity Builtins","text":"<p>When resolving references, Slang can differentiate between user provided definitions and Solidity built-ins. This makes it possible to perform deeper semantic analysis which is not possible with only the results of parsing.</p> <p>For example, we can easily detect incorrect usages of the deprecated <code>tx.origin</code> (as recommended here) but distinguish it from valid user code that syntactically looks exactly the same:</p> solidity-builtins.mts<pre><code>import assert from \"node:assert\";\nimport { Cursor, NonterminalKind, Query } from \"@nomicfoundation/slang/cst\";\nimport { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\n\ntest(\"solidity builtins\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n\n  const query = Query.create(`\n    [MemberAccessExpression\n      [Expression @start [\"tx\"]]\n      [\"origin\"]\n    ]\n  `);\n\n  const cursor = unit.file(\"contract.sol\")!.createTreeCursor();\n  const matches = cursor.query([query]);\n  for (const match of matches) {\n    const txIdentifier = match.captures[\"start\"][0];\n    const reference = unit.bindingGraph.referenceAt(txIdentifier)!;\n    const definitions = reference.definitions();\n\n    if (definitions[0].nameLocation.isBuiltInLocation()) {\n      // incorrect use of `tx.origin` detected!\n      assert.strictEqual(txIdentifier.textRange.start.line, 13);\n    } else {\n      // this is ok: the `tx` builtin is shadowed by a parameter\n      const definitionLocation = definitions[0].definiensLocation.asUserFileLocation()!;\n      assert.strictEqual(definitionLocation.fileId, \"contract.sol\");\n      assert.strictEqual(definitionLocation.cursor.node.kind, NonterminalKind.Parameter);\n    }\n  }\n});\n\nasync function buildCompilationUnit(): Promise&lt;CompilationUnit&gt; {\n  // we don't need to resolve imports for this example\n  const resolveImport = async (_sourceId: string, _importPath: Cursor) =&gt; undefined;\n  const readFile = async (fileId: string) =&gt; {\n    assert(fileId == \"contract.sol\");\n    return `\n// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract TxUserWallet {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferTo(address payable dest, uint amount) public {\n        // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n\n    struct UserTx {\n        address origin;\n    }\n\n    function checkOwner(UserTx memory tx) public pure returns (bool) {\n        // This use of tx.origin is fine\n        return tx.origin == owner;\n    }\n}\n    `;\n  };\n\n  const builder = CompilationBuilder.create({\n    languageVersion: \"0.8.28\",\n    readFile,\n    resolveImport,\n  });\n\n  await builder.addFile(\"contract.sol\");\n\n  return builder.build();\n}\n</code></pre>"},{"location":"user-guide/08-examples/","title":"8. Examples","text":"<ul> <li>8.1. List functions in a contract</li> <li>8.2. Find usages</li> <li>8.3. Jump to definition</li> </ul> <p>Throughout the examples in this section we will use a sample contract. We need some setup code to create a <code>CompilationUnit</code> with the contents of the contract:</p> sample-contract.mts<pre><code>import { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { buildCompilationUnit } from \"./compilation-builder.mjs\";\n\nconst CONTRACT_VFS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\ncontract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n    `,\n  ],\n]);\n\nexport default function (): Promise&lt;CompilationUnit&gt; {\n  return buildCompilationUnit(CONTRACT_VFS, \"0.8.0\", \"contract.sol\");\n}\n</code></pre> compilation-builder.mts<pre><code>import { Cursor } from \"@nomicfoundation/slang/cst\";\nimport { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\n\nfunction buildReadFile(virtualFs: Map&lt;string, string&gt;): (fileId: string) =&gt; Promise&lt;string&gt; {\n  return async (fileId: string) =&gt; {\n    const contents = virtualFs.get(fileId);\n    if (!contents) {\n      throw new Error(`${fileId} not found`);\n    }\n    return contents;\n  };\n}\n\nasync function resolveImport(_sourceFileId: string, importPath: Cursor) {\n  const importLiteral = importPath.node.unparse();\n  const importString = importLiteral.replace(/^[\"']/, \"\").replace(/[\"']$/, \"\");\n  return importString;\n}\n\nexport async function buildCompilationUnit(\n  virtualFs: Map&lt;string, string&gt;,\n  version: string,\n  mainFileId: string,\n): Promise&lt;CompilationUnit&gt; {\n  const builder = CompilationBuilder.create({\n    languageVersion: version,\n    readFile: buildReadFile(virtualFs),\n    resolveImport,\n  });\n\n  await builder.addFile(mainFileId);\n\n  return builder.build();\n}\n</code></pre> <p>For the last two examples we also need an easy way to obtain a <code>Cursor</code> pointing to a specific line and column in a file. This can be achieved using the Cursor Navigation API:</p> find-terminal-node-at.mts<pre><code>import assert from \"node:assert\";\nimport { Cursor } from \"@nomicfoundation/slang/cst\";\n\nexport function findTerminalNodeAt(cursor: Cursor, line: number, column: number): Cursor | undefined {\n  const range = cursor.textRange;\n  if (\n    line &lt; range.start.line ||\n    (line == range.start.line &amp;&amp; column &lt; range.start.column) ||\n    line &gt; range.end.line ||\n    (line == range.end.line &amp;&amp; column &gt; range.end.column)\n  ) {\n    // initial cursor is outside of the range of the CST tree\n    return undefined;\n  }\n\n  outer: while (cursor.node.isNonterminalNode()) {\n    assert(cursor.goToFirstChild());\n    do {\n      const childRange = cursor.textRange;\n      if (line &lt; childRange.end.line || (line == childRange.end.line &amp;&amp; column &lt;= childRange.end.column)) {\n        continue outer;\n      }\n    } while (cursor.goToNextSibling());\n\n    // we should have found a child to recurse into (or the target terminal node)\n    throw new Error(\"should not be reached\");\n  }\n  assert(cursor.node.isTerminalNode());\n  return cursor;\n}\n</code></pre>"},{"location":"user-guide/08-examples/01-list-functions-in-contract/","title":"8.1. List functions in a contract","text":"<p>This function finds a contract in the compilation unit with the given name and returns a list of <code>FunctionDefinition</code> within it. We use a combination of the Query API and the AST types:</p> list-functions-in-contract.mts<pre><code>import { assertNonterminalNode, Query } from \"@nomicfoundation/slang/cst\";\nimport { ContractDefinition, FunctionDefinition } from \"@nomicfoundation/slang/ast\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\n\nexport function listFunctionsInContract(unit: CompilationUnit, contractName: string): FunctionDefinition[] {\n  for (const file of unit.files()) {\n    const cursor = file.createTreeCursor();\n    const query = Query.create(`\n      [ContractDefinition\n        @name name: [Identifier]\n      ]\n    `);\n    const matches = cursor.query([query]);\n\n    for (const match of matches) {\n      const contractNode = match.root.node;\n      assertNonterminalNode(contractNode);\n      const name = match.captures[\"name\"][0].node.unparse();\n      if (name == contractName) {\n        // found the contract\n        const contract = new ContractDefinition(contractNode);\n        const functions = contract.members.items\n          .map((member) =&gt; member.variant)\n          .filter((member) =&gt; member instanceof FunctionDefinition);\n        return functions;\n      }\n    }\n  }\n\n  throw new Error(`Could not find contract named ${contractName}`);\n}\n</code></pre> <p>From the list of <code>FunctionDefinition</code>s it's easy to obtain the names of the functions:</p> test-list-functions.test.mts<pre><code>import assert from \"node:assert\";\nimport { listFunctionsInContract } from \"./list-functions-in-contract.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"list functions by contract name\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  const functions = listFunctionsInContract(unit, \"Counter\");\n  const functionNames = functions.map((fun) =&gt; fun.name.cst.unparse().trim());\n  assert.deepEqual(functionNames, [\"count\", \"increment\"]);\n});\n</code></pre>"},{"location":"user-guide/08-examples/02-find-usages/","title":"8.2. Find usages","text":"<p>A typical use case for an IDE is finding where some variable, function, or type is used in the code base. In Slang this can be easily accomplished by using the Binding Graph API:</p> find-usages.mts<pre><code>import { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\nimport { findTerminalNodeAt } from \"../../common/find-terminal-node-at.mjs\";\n\ntype Usage = {\n  file: string;\n  line: number;\n  column: number;\n};\n\nexport function findUsages(unit: CompilationUnit, fileId: string, line: number, column: number): Usage[] {\n  const file = unit.file(fileId);\n  if (!file) {\n    throw new Error(`${fileId} not found in compilation unit`);\n  }\n\n  const cursor = findTerminalNodeAt(file.createTreeCursor(), line, column);\n  if (!cursor) {\n    throw new Error(`${fileId}:${line}:${column} is not a valid text location`);\n  }\n\n  assertTerminalNode(cursor.node);\n  if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n    // location is not a valid identifier\n    throw new Error(`Could not find a valid identifier at ${fileId}:${line}:${column}`);\n  }\n\n  const definition = unit.bindingGraph.definitionAt(cursor);\n  if (!definition) {\n    throw new Error(`Identifier ${cursor.node.unparse()} is not a definition at ${fileId}:${line}:${column}`);\n  }\n\n  const references = definition.references();\n  const usages = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    usages.push({\n      file: reference.location.fileId,\n      line: reference.location.cursor.textOffset.line,\n      column: reference.location.cursor.textOffset.column,\n    });\n  }\n  return usages;\n}\n</code></pre> <p>For example, we can look for usages of the <code>_count</code> state variable defined in line 2 of the sample contract:</p> <pre><code>contract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n</code></pre> test-find-usages.test.mts<pre><code>import assert from \"node:assert\";\nimport { findUsages } from \"./find-usages.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"find usages\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  // the _count state variable definition\n  const usages = findUsages(unit, \"contract.sol\", 2, 10);\n\n  assert.deepEqual(usages, [\n    { file: \"contract.sol\", line: 4, column: 4 },\n    { file: \"contract.sol\", line: 7, column: 11 },\n    { file: \"contract.sol\", line: 11, column: 4 },\n    { file: \"contract.sol\", line: 12, column: 11 },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/08-examples/03-jump-to-definition/","title":"8.3. Jump to definition","text":"<p>Another often used feature of an IDE is the ability to jump to the definition of a given identifier. Again, we can use the Binding Graph API to do it:</p> jump-to-definition.mts<pre><code>import { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { findTerminalNodeAt } from \"../../common/find-terminal-node-at.mjs\";\n\ntype Target = {\n  file: string;\n  line: number;\n  column: number;\n};\n\nexport function jumpToDefinition(unit: CompilationUnit, fileId: string, line: number, column: number): Target {\n  const file = unit.file(fileId);\n  if (!file) {\n    throw new Error(`${fileId} not found in compilation unit`);\n  }\n\n  const cursor = findTerminalNodeAt(file.createTreeCursor(), line, column);\n  if (!cursor) {\n    throw new Error(`${fileId}:${line}:${column} is not a valid text location`);\n  }\n\n  assertTerminalNode(cursor.node);\n  if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n    // location is not a valid identifier\n    throw new Error(`Could not find a valid identifier at ${fileId}:${line}:${column}`);\n  }\n\n  const reference = unit.bindingGraph.referenceAt(cursor);\n  if (!reference) {\n    throw new Error(`Identifier ${cursor.node.unparse()} is not a reference at ${fileId}:${line}:${column}`);\n  }\n\n  const definitions = reference.definitions();\n  if (definitions.length == 0) {\n    throw new Error(`${cursor.node.unparse()} is not defined`);\n  }\n\n  // we take the first definition arbitrarily\n  const location = definitions[0].nameLocation;\n  if (!location.isUserFileLocation()) {\n    throw new Error(`${cursor.node.unparse()} is a built-in`);\n  }\n\n  return {\n    file: location.fileId,\n    line: location.cursor.textOffset.line,\n    column: location.cursor.textOffset.column,\n  };\n}\n</code></pre> <p>The following example shows jumping to the definition of the parameter <code>delta</code> in line 11:</p> <pre><code>contract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n</code></pre> test-jump-to-definition.test.mts<pre><code>import assert from \"node:assert\";\nimport { jumpToDefinition } from \"./jump-to-definition.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"jump to definition\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  // the reference to `delta` in the assignment addition\n  const definition = jumpToDefinition(unit, \"contract.sol\", 11, 16);\n\n  assert.deepEqual(definition, { file: \"contract.sol\", line: 9, column: 26 });\n});\n</code></pre>"}]}