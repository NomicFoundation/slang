{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"slang","text":""},{"location":"#solidity-compiler-tooling-by-nomicfoundation","title":"Solidity compiler tooling by @NomicFoundation","text":"<p>A modular set of compiler APIs empowering the next generation of Solidity code analysis and developer tooling. Written in Rust and distributed in multiple languages.</p> <p>Slang analyzes Solidity source code and generates a rich concrete syntax tree (CST) that can be reasoned about. This is a departure from the classic approach of \"black-box\" compilers, which are handed the input and only their output can be observed.</p>"},{"location":"#supporting-multiple-solidity-versions","title":"Supporting Multiple Solidity Versions","text":"<p>The Solidity programming language has evolved quite a bit since its inception. Some features were introduced, some changed, while some eventually became obsolete and were removed altogether. Developer tooling must be able to understand and consume older contracts that are still being used on the blockchain, written in older versions of Solidity.</p> <p>Because of that, Slang must be able to reason about different versions of Solidity; how the language grammar, name capture rules, and semantics have changed across different versions. One of our goals is to document differences as part of our Solidity Grammar.</p> <p>This is why, instead of having to download separate versions of Slang for each Solidity version, you specify the Solidity version that you want to work with when you use the Slang language APIs.</p> <ul> <li>See our supported versions.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install the Slang NPM package with the following <code>npm</code> command:</p> <pre><code>npm install \"@nomicfoundation/slang\"\n</code></pre> <p>Or if you are using <code>yarn</code>:</p> <pre><code>yarn add \"@nomicfoundation/slang\"\n</code></pre> <ul> <li>Learn more about how to get started with Slang.</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>import assert from \"node:assert\";\nimport { ParseOutput, Parser } from \"@nomicfoundation/slang/parser\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\nfunction createTree(): ParseOutput {\n    const source = `\n    contract Foo {}\n    contract Bar {}\n    contract Baz {}\n  `;\n\n    const parser = Parser.create(LanguageFacts.latestVersion());\n\n    const parseOutput = parser.parseFileContents(source.trim());\n    assert(parseOutput.isValid());\n\n    return parseOutput;\n}\n\ntest(\"Get contract names\", () =&gt; {\n    const tree = createTree();\n    const cursor = tree.createTreeCursor();\n\n    const contracts = [];\n\n    while (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n        assert(cursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n        contracts.push(cursor.node.unparse());\n    }\n\n    assert.deepStrictEqual(contracts, [\"Foo\", \"Bar\", \"Baz\"]);\n});\n</code></pre> <p>Slang is not a replacement for solc, the standard Solidity compiler. We do not plan at the moment to support emitting optimized EVM bytecode for use in production. It does not perform formal verification of contracts or Solidity logic in general. However, it is designed to empower such tools to be built on top of it.</p> <ul> <li>Slang v1 Announcement - Blog Post</li> <li>Slang User Guide</li> </ul>"},{"location":"#using-slang","title":"Using Slang","text":"<p>We have several examples showing some of the ways that you can use Slang APIs to develop your own Solidity tooling. For more detailed information about Slang concepts please check our user guide.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#concrete-syntax-trees","title":"Concrete Syntax Trees","text":"<p>Slang is capable of parsing the source code into a Concrete Syntax Tree (CST), which is a tree structure representing the entire source code. It includes the contracts, functions, statements, and expressions within. It also includes things like comments, whitespace, and punctuation. This is sometimes called a \"full-fidelity\" CST, and it can be used to reconstruct the original source code when needed.</p>"},{"location":"#parser","title":"Parser","text":"<p>The <code>Parser</code> API is used to produce a CST from Solidity source code. Each <code>Parser</code> object is initialized with a specific Solidity version.</p> <p>With a <code>Parser</code> object, you can analyze any source text according to the grammar of that specific version. Therefore, providing an accurate language version is important as it affects the shape of the syntax tree and the set of possible errors.</p> <ul> <li>Learn more about the Parser API.</li> </ul>"},{"location":"#cursors","title":"Cursors","text":"<p>For many code analysis tasks it is useful to traverse the CST and visit each node. Slang provides this functionality through cursors. Cursors provide an efficient pre-order traversal API for both complete CSTs and arbitrary subtrees.</p> <ul> <li>Learn more about using cursors.</li> </ul>"},{"location":"#queries","title":"Queries","text":"<p>The <code>Cursor</code> API is a low-level API that allows you to traverse the CST in a procedural manner. However, it is often more convenient to use the declarative <code>Query</code> API. Queries allow you to express your intent more concisely, and also allows you to reuse the same query in multiple places. Queries can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <ul> <li>Learn more about using queries.</li> </ul>"},{"location":"#compilation-units","title":"Compilation Units","text":"<p>Solidity projects are usually composed of multiple files. Slang has the concept of a <code>CompilationUnit</code>, which is built from parsing Solidity source files and their dependencies, transitively. This allows performing further analysis on the source code, such as semantic analysis.</p> <ul> <li>Learn more about using compilation units.</li> </ul>"},{"location":"#binding-graph","title":"Binding Graph","text":"<p>The binding graph is a structure that represents the relationships between identifiers across source files in a <code>CompilationUnit</code>. It stores <code>Cursor</code> objects to all Solidity definitions (contracts, functions, state variables, etc.), the references to them, and can resolve the links between the two.</p> <ul> <li>Learn more about using the binding graph.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Please check our contributors guide to learn about how you can get started on Slang development.</p>"},{"location":"#built-with-slang","title":"Built with Slang","text":"<p>We're proud to support other projects in the Solidity ecosystem with our developer tools. Here are some of the projects currently using Slang:</p> <ul> <li>Hardhat Solidity VSCode Extension</li> <li>prettier-plugin-solidity</li> <li> <p>openzeppelin-upgrades</p> </li> <li> <p>Learn more about projects using Slang.</p> </li> </ul> <ul> <li>Slang NPM Package</li> <li>Slang User Guide</li> <li>Slang Telegram Group</li> <li>We are hiring!</li> </ul>"},{"location":"solidity-grammar/","title":"Solidity Grammar","text":""},{"location":"solidity-grammar/#solidity-grammar","title":"Solidity Grammar","text":"<ul> <li>Supported Versions</li> <li>1. File Structure</li> <li>2. Definitions</li> <li>3. Types</li> <li>4. Statements</li> <li>5. Expressions</li> <li>6. Yul</li> </ul>"},{"location":"solidity-grammar/supported-versions/","title":"Supported Versions","text":"<p>This grammar compiles information from 85 publicly released versions of Solidity:</p> <p><code>0.4.11</code> <code>0.4.12</code> <code>0.4.13</code> <code>0.4.14</code> <code>0.4.15</code> <code>0.4.16</code> <code>0.4.17</code> <code>0.4.18</code> <code>0.4.19</code> <code>0.4.20</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.23</code> <code>0.4.24</code> <code>0.4.25</code> <code>0.4.26</code> <code>0.5.0</code> <code>0.5.1</code> <code>0.5.2</code> <code>0.5.3</code> <code>0.5.4</code> <code>0.5.5</code> <code>0.5.6</code> <code>0.5.7</code> <code>0.5.8</code> <code>0.5.9</code> <code>0.5.10</code> <code>0.5.11</code> <code>0.5.12</code> <code>0.5.13</code> <code>0.5.14</code> <code>0.5.15</code> <code>0.5.16</code> <code>0.5.17</code> <code>0.6.0</code> <code>0.6.1</code> <code>0.6.2</code> <code>0.6.3</code> <code>0.6.4</code> <code>0.6.5</code> <code>0.6.6</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.9</code> <code>0.6.10</code> <code>0.6.11</code> <code>0.6.12</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.2</code> <code>0.7.3</code> <code>0.7.4</code> <code>0.7.5</code> <code>0.7.6</code> <code>0.8.0</code> <code>0.8.1</code> <code>0.8.2</code> <code>0.8.3</code> <code>0.8.4</code> <code>0.8.5</code> <code>0.8.6</code> <code>0.8.7</code> <code>0.8.8</code> <code>0.8.9</code> <code>0.8.10</code> <code>0.8.11</code> <code>0.8.12</code> <code>0.8.13</code> <code>0.8.14</code> <code>0.8.15</code> <code>0.8.16</code> <code>0.8.17</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.20</code> <code>0.8.21</code> <code>0.8.22</code> <code>0.8.23</code> <code>0.8.24</code> <code>0.8.25</code> <code>0.8.26</code> <code>0.8.27</code> <code>0.8.28</code> <code>0.8.29</code> <code>0.8.30</code></p> <p>Among which, 31 versions have breaking changes:</p> <p><code>0.4.11</code> <code>0.4.14</code> <code>0.4.16</code> <code>0.4.21</code> <code>0.4.22</code> <code>0.4.25</code> <code>0.5.0</code> <code>0.5.3</code> <code>0.5.5</code> <code>0.5.8</code> <code>0.5.10</code> <code>0.5.14</code> <code>0.6.0</code> <code>0.6.2</code> <code>0.6.5</code> <code>0.6.7</code> <code>0.6.8</code> <code>0.6.11</code> <code>0.7.0</code> <code>0.7.1</code> <code>0.7.4</code> <code>0.7.5</code> <code>0.8.0</code> <code>0.8.4</code> <code>0.8.8</code> <code>0.8.13</code> <code>0.8.18</code> <code>0.8.19</code> <code>0.8.22</code> <code>0.8.27</code> <code>0.8.29</code></p>"},{"location":"solidity-grammar/01-file-structure/","title":"1. File Structure","text":""},{"location":"solidity-grammar/01-file-structure/#1-file-structure","title":"1. File Structure","text":"<ul> <li>1.1. Source Unit</li> <li>1.2. Pragma Directives</li> <li>1.3. Import Directives</li> <li>1.4. Using Directives</li> <li>1.5. Trivia</li> <li>1.6. Keywords</li> <li>1.7. Punctuation</li> </ul>"},{"location":"solidity-grammar/01-file-structure/01-source-unit/","title":"1.1. Source Unit","text":""},{"location":"solidity-grammar/01-file-structure/01-source-unit/#11-source-unit","title":"1.1. Source Unit","text":"<pre>SourceUnit = (* members: *) SourceUnitMembers;</pre> <pre></pre> <pre>SourceUnitMembers = (* item: *) SourceUnitMember*;</pre> <pre></pre> <pre>SourceUnitMember = (* variant: *) PragmaDirective                 | (* variant: *) ImportDirective                 | (* variant: *) ContractDefinition                 | (* variant: *) InterfaceDefinition                 | (* variant: *) LibraryDefinition                 | (* variant: *) StructDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) EnumDefinition (* Introduced in 0.6.0 *)                 | (* variant: *) FunctionDefinition (* Introduced in 0.7.1 *)                 | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)                 | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)                 | (* variant: *) UsingDirective (* Introduced in 0.8.13 *)                 | (* variant: *) EventDefinition (* Introduced in 0.8.22 *)                 | (* variant: *) ConstantDefinition; (* Introduced in 0.7.4 *)</pre>"},{"location":"solidity-grammar/01-file-structure/02-pragma-directives/","title":"1.2. Pragma Directives","text":""},{"location":"solidity-grammar/01-file-structure/02-pragma-directives/#12-pragma-directives","title":"1.2. Pragma Directives","text":"<pre>PragmaDirective = (* pragma_keyword: *) PRAGMA_KEYWORD                  (* pragma: *) Pragma                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>Pragma = (* variant: *) VersionPragma       | (* variant: *) AbicoderPragma (* Introduced in 0.7.5 *)       | (* variant: *) ExperimentalPragma; (* Introduced in 0.4.16 *)</pre> <pre></pre> <pre>(* Introduced in 0.7.5 *)AbicoderPragma = (* abicoder_keyword: *) ABICODER_KEYWORD                 (* version: *) AbicoderVersion;</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)ExperimentalPragma = (* experimental_keyword: *) EXPERIMENTAL_KEYWORD                     (* feature: *) ExperimentalFeature;</pre> <pre></pre> <pre>(* Introduced in 0.7.5 *)AbicoderVersion = (* variant: *) ABICODER_V1_KEYWORD                | (* variant: *) ABICODER_V2_KEYWORD;</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)ExperimentalFeature = (* variant: *) ABI_ENCODER_V2_KEYWORD                    | (* variant: *) SMT_CHECKER_KEYWORD                    | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>VersionPragma = (* solidity_keyword: *) SOLIDITY_KEYWORD                (* sets: *) VersionExpressionSets;</pre> <pre></pre> <pre>VersionExpressionSets = (* item: *) VersionExpressionSet ((* separator: *) BAR_BAR (* item: *) VersionExpressionSet)*;</pre> <pre></pre> <pre>VersionExpressionSet = (* item: *) VersionExpression+;</pre> <pre></pre> <pre>VersionExpression = (* variant: *) VersionRange                  | (* variant: *) VersionTerm;</pre> <pre></pre> <pre>VersionRange = (* start: *) VersionLiteral               (* minus: *) MINUS               (* end: *) VersionLiteral;</pre> <pre></pre> <pre>VersionTerm = (* operator: *) VersionOperator?              (* literal: *) VersionLiteral;</pre> <pre></pre> <pre>VersionOperator = (* variant: *) CARET                | (* variant: *) TILDE                | (* variant: *) EQUAL                | (* variant: *) LESS_THAN                | (* variant: *) GREATER_THAN                | (* variant: *) LESS_THAN_EQUAL                | (* variant: *) GREATER_THAN_EQUAL;</pre> <pre></pre> <pre>VersionLiteral = (* variant: *) SimpleVersionLiteral               | (* variant: *) SINGLE_QUOTED_VERSION_LITERAL               | (* variant: *) DOUBLE_QUOTED_VERSION_LITERAL;</pre> <pre></pre> <pre>SimpleVersionLiteral = (* item: *) VERSION_SPECIFIER ((* separator: *) PERIOD (* item: *) VERSION_SPECIFIER)*;</pre> <pre></pre> <pre>VERSION_SPECIFIER = \u00abVERSION_SPECIFIER_FRAGMENT\u00bb;</pre> <pre></pre> <pre>SINGLE_QUOTED_VERSION_LITERAL = \"'\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_VERSION_LITERAL = '\"' \u00abVERSION_SPECIFIER_FRAGMENT\u00bb (\".\" \u00abVERSION_SPECIFIER_FRAGMENT\u00bb)* '\"';</pre> <pre></pre> <pre>\u00abVERSION_SPECIFIER_FRAGMENT\u00bb = (\"0\"\u2026\"9\" | \"x\" | \"X\" | \"*\")+;</pre>"},{"location":"solidity-grammar/01-file-structure/03-import-directives/","title":"1.3. Import Directives","text":""},{"location":"solidity-grammar/01-file-structure/03-import-directives/#13-import-directives","title":"1.3. Import Directives","text":"<pre>ImportDirective = (* import_keyword: *) IMPORT_KEYWORD                  (* clause: *) ImportClause                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ImportClause = (* variant: *) PathImport             | (* variant: *) NamedImport             | (* variant: *) ImportDeconstruction;</pre> <pre></pre> <pre>PathImport = (* path: *) StringLiteral             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>NamedImport = (* asterisk: *) ASTERISK              (* alias: *) ImportAlias              (* from_keyword: *) FROM_KEYWORD              (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstruction = (* open_brace: *) OPEN_BRACE                       (* symbols: *) ImportDeconstructionSymbols                       (* close_brace: *) CLOSE_BRACE                       (* from_keyword: *) FROM_KEYWORD                       (* path: *) StringLiteral;</pre> <pre></pre> <pre>ImportDeconstructionSymbols = (* item: *) ImportDeconstructionSymbol ((* separator: *) COMMA (* item: *) ImportDeconstructionSymbol)*;</pre> <pre></pre> <pre>ImportDeconstructionSymbol = (* name: *) IDENTIFIER                             (* alias: *) ImportAlias?;</pre> <pre></pre> <pre>ImportAlias = (* as_keyword: *) AS_KEYWORD              (* identifier: *) IDENTIFIER;</pre>"},{"location":"solidity-grammar/01-file-structure/04-using-directives/","title":"1.4. Using Directives","text":""},{"location":"solidity-grammar/01-file-structure/04-using-directives/#14-using-directives","title":"1.4. Using Directives","text":"<pre>UsingDirective = (* using_keyword: *) USING_KEYWORD                 (* clause: *) UsingClause                 (* for_keyword: *) FOR_KEYWORD                 (* target: *) UsingTarget                 (* global_keyword: *) GLOBAL_KEYWORD? (* Introduced in 0.8.13 *)                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>UsingClause = (* variant: *) IdentifierPath            | (* variant: *) UsingDeconstruction; (* Introduced in 0.8.13 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstruction = (* open_brace: *) OPEN_BRACE                      (* symbols: *) UsingDeconstructionSymbols                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbols = (* item: *) UsingDeconstructionSymbol ((* separator: *) COMMA (* item: *) UsingDeconstructionSymbol)*;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)UsingDeconstructionSymbol = (* name: *) IdentifierPath                            (* alias: *) UsingAlias?; (* Introduced in 0.8.19 *)</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingAlias = (* as_keyword: *) AS_KEYWORD             (* operator: *) UsingOperator;</pre> <pre></pre> <pre>(* Introduced in 0.8.19 *)UsingOperator = (* variant: *) AMPERSAND              | (* variant: *) ASTERISK              | (* variant: *) BANG_EQUAL              | (* variant: *) BAR              | (* variant: *) CARET              | (* variant: *) EQUAL_EQUAL              | (* variant: *) GREATER_THAN              | (* variant: *) GREATER_THAN_EQUAL              | (* variant: *) LESS_THAN              | (* variant: *) LESS_THAN_EQUAL              | (* variant: *) MINUS              | (* variant: *) PERCENT              | (* variant: *) PLUS              | (* variant: *) SLASH              | (* variant: *) TILDE;</pre> <pre></pre> <pre>UsingTarget = (* variant: *) TypeName            | (* variant: *) ASTERISK;</pre>"},{"location":"solidity-grammar/01-file-structure/05-trivia/","title":"1.5. Trivia","text":""},{"location":"solidity-grammar/01-file-structure/05-trivia/#15-trivia","title":"1.5. Trivia","text":"<pre>WHITESPACE = (\" \" | \"\\t\")+;</pre> <pre></pre> <pre>END_OF_LINE = \"\\n\" | (\"\\r\" \"\\n\"?);</pre> <pre></pre> <pre>SINGLE_LINE_COMMENT = \"//\" (?!\"/\") (!(\"\\r\" | \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_COMMENT = \"/*\" (?!\"*\" !\"/\") (!\"*\" | (\"*\" (?!\"/\")))* \"*/\";</pre> <pre></pre> <pre>SINGLE_LINE_NAT_SPEC_COMMENT = \"///\" (!(\"\\r\" | \"\\n\"))*;</pre> <pre></pre> <pre>MULTI_LINE_NAT_SPEC_COMMENT = \"/**\" (?!\"/\") (!\"*\" | (\"*\" (?!\"/\")))* \"*/\";</pre>"},{"location":"solidity-grammar/01-file-structure/06-keywords/","title":"1.6. Keywords","text":""},{"location":"solidity-grammar/01-file-structure/06-keywords/#16-keywords","title":"1.6. Keywords","text":"<pre>(* Introduced in 0.7.5 *)(* Never reserved *)ABICODER_KEYWORD = \"abicoder\";</pre> <pre></pre> <pre>(* Introduced in 0.7.5 *)(* Never reserved *)ABICODER_V1_KEYWORD = \"v1\";</pre> <pre></pre> <pre>(* Introduced in 0.7.5 *)(* Never reserved *)ABICODER_V2_KEYWORD = \"v2\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)(* Never reserved *)ABI_ENCODER_V2_KEYWORD = \"ABIEncoderV2\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>(* Never reserved *)ADDRESS_KEYWORD = \"address\";</pre> <pre></pre> <pre>AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Introduced in 0.8.29 *)(* Never reserved *)AT_KEYWORD = \"at\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>(* Deprecated in 0.8.0 *)BYTE_KEYWORD = \"byte\";</pre> <pre></pre> <pre>BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>(* Introduced in 0.5.0 *)(* Reserved in 0.5.0 *)CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)(* Reserved in 0.5.0 *)CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)(* Reserved in 0.5.0 *)EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)ERROR_KEYWORD = \"error\";</pre> <pre></pre> <pre>ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)(* Never reserved *)EXPERIMENTAL_KEYWORD = \"experimental\";</pre> <pre></pre> <pre>EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>FIXED_KEYWORD = \"fixed\";FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>(* Never reserved *)FROM_KEYWORD = \"from\";</pre> <pre></pre> <pre>FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)(* Never reserved *)GLOBAL_KEYWORD = \"global\";</pre> <pre></pre> <pre>(* Introduced in 0.6.11 *)(* Reserved in 0.7.0 *)GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Introduced in 0.6.5 *)(* Reserved in 0.5.0 *)IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>(* Introduced in 0.8.29 *)(* Never reserved *)LAYOUT_KEYWORD = \"layout\";</pre> <pre></pre> <pre>LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.5.0 *)OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved in 0.6.0 *)RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>RETURN_KEYWORD = \"return\";</pre> <pre></pre> <pre>RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)(* Never reserved *)REVERT_KEYWORD = \"revert\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)(* Never reserved *)SMT_CHECKER_KEYWORD = \"SMTChecker\";</pre> <pre></pre> <pre>(* Never reserved *)SOLIDITY_KEYWORD = \"solidity\";</pre> <pre></pre> <pre>STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)SUPER_KEYWORD = \"super\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Deprecated in 0.7.0 *)(* Reserved until 0.7.0 *)SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)THIS_KEYWORD = \"this\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.8.27 *)(* Never reserved *)TRANSIENT_KEYWORD = \"transient\";</pre> <pre></pre> <pre>TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved in 0.5.0 *)TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Introduced in 0.5.3 *)TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>UFIXED_KEYWORD = \"ufixed\";UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved in 0.4.14 *)UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)(* Reserved in 0.5.0 *)UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Introduced in 0.4.16 *)VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.6.0 *)VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YEARS_KEYWORD = \"years\";</pre>"},{"location":"solidity-grammar/01-file-structure/07-punctuation/","title":"1.7. Punctuation","text":""},{"location":"solidity-grammar/01-file-structure/07-punctuation/#17-punctuation","title":"1.7. Punctuation","text":"<pre>OPEN_PAREN = \"(\";</pre> <pre></pre> <pre>CLOSE_PAREN = \")\";</pre> <pre></pre> <pre>OPEN_BRACKET = \"[\";</pre> <pre></pre> <pre>CLOSE_BRACKET = \"]\";</pre> <pre></pre> <pre>OPEN_BRACE = \"{\";</pre> <pre></pre> <pre>CLOSE_BRACE = \"}\";</pre> <pre></pre> <pre>COMMA = \",\";</pre> <pre></pre> <pre>PERIOD = \".\";</pre> <pre></pre> <pre>QUESTION_MARK = \"?\";</pre> <pre></pre> <pre>SEMICOLON = \";\";</pre> <pre></pre> <pre>COLON = \":\";</pre> <pre></pre> <pre>COLON_EQUAL = \":=\";</pre> <pre></pre> <pre>EQUAL = \"=\";</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)EQUAL_COLON = \"=:\";</pre> <pre></pre> <pre>EQUAL_EQUAL = \"==\";</pre> <pre></pre> <pre>EQUAL_GREATER_THAN = \"=&gt;\";</pre> <pre></pre> <pre>ASTERISK = \"*\";</pre> <pre></pre> <pre>ASTERISK_EQUAL = \"*=\";</pre> <pre></pre> <pre>ASTERISK_ASTERISK = \"**\";</pre> <pre></pre> <pre>BAR = \"|\";</pre> <pre></pre> <pre>BAR_EQUAL = \"|=\";</pre> <pre></pre> <pre>BAR_BAR = \"||\";</pre> <pre></pre> <pre>AMPERSAND = \"&amp;\";</pre> <pre></pre> <pre>AMPERSAND_EQUAL = \"&amp;=\";</pre> <pre></pre> <pre>AMPERSAND_AMPERSAND = \"&amp;&amp;\";</pre> <pre></pre> <pre>LESS_THAN = \"&lt;\";</pre> <pre></pre> <pre>LESS_THAN_EQUAL = \"&lt;=\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN = \"&lt;&lt;\";</pre> <pre></pre> <pre>LESS_THAN_LESS_THAN_EQUAL = \"&lt;&lt;=\";</pre> <pre></pre> <pre>GREATER_THAN = \"&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_EQUAL = \"&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN = \"&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;=\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN = \"&gt;&gt;&gt;\";</pre> <pre></pre> <pre>GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL = \"&gt;&gt;&gt;=\";</pre> <pre></pre> <pre>PLUS = \"+\";</pre> <pre></pre> <pre>PLUS_EQUAL = \"+=\";</pre> <pre></pre> <pre>PLUS_PLUS = \"++\";</pre> <pre></pre> <pre>MINUS = \"-\";</pre> <pre></pre> <pre>MINUS_EQUAL = \"-=\";</pre> <pre></pre> <pre>MINUS_MINUS = \"--\";</pre> <pre></pre> <pre>MINUS_GREATER_THAN = \"-&gt;\";</pre> <pre></pre> <pre>SLASH = \"/\" (?!\"*\" | \"/\" | \"=\");</pre> <pre></pre> <pre>SLASH_EQUAL = \"/=\";</pre> <pre></pre> <pre>PERCENT = \"%\";</pre> <pre></pre> <pre>PERCENT_EQUAL = \"%=\";</pre> <pre></pre> <pre>BANG = \"!\";</pre> <pre></pre> <pre>BANG_EQUAL = \"!=\";</pre> <pre></pre> <pre>CARET = \"^\";</pre> <pre></pre> <pre>CARET_EQUAL = \"^=\";</pre> <pre></pre> <pre>TILDE = \"~\";</pre>"},{"location":"solidity-grammar/02-definitions/","title":"2. Definitions","text":""},{"location":"solidity-grammar/02-definitions/#2-definitions","title":"2. Definitions","text":"<ul> <li>2.1. Contracts</li> <li>2.2. Interfaces</li> <li>2.3. Libraries</li> <li>2.4. Structs</li> <li>2.5. Enums</li> <li>2.6. Constants</li> <li>2.7. State Variables</li> <li>2.8. Functions</li> <li>2.9. Modifiers</li> <li>2.10. Events</li> <li>2.11. User Defined Value Types</li> <li>2.12. Errors</li> </ul>"},{"location":"solidity-grammar/02-definitions/01-contracts/","title":"2.1. Contracts","text":""},{"location":"solidity-grammar/02-definitions/01-contracts/#21-contracts","title":"2.1. Contracts","text":"<pre>ContractDefinition = (* abstract_keyword: *) ABSTRACT_KEYWORD? (* Introduced in 0.6.0 *)                     (* contract_keyword: *) CONTRACT_KEYWORD                     (* name: *) IDENTIFIER                     (* specifiers: *) ContractSpecifiers                     (* open_brace: *) OPEN_BRACE                     (* members: *) ContractMembers                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>ContractSpecifiers = (* item: *) ContractSpecifier*;</pre> <pre></pre> <pre>ContractSpecifier = (* variant: *) InheritanceSpecifier                  | (* variant: *) StorageLayoutSpecifier; (* Introduced in 0.8.29 *)</pre> <pre></pre> <pre>InheritanceSpecifier = (* is_keyword: *) IS_KEYWORD                       (* types: *) InheritanceTypes;</pre> <pre></pre> <pre>InheritanceTypes = (* item: *) InheritanceType ((* separator: *) COMMA (* item: *) InheritanceType)*;</pre> <pre></pre> <pre>InheritanceType = (* type_name: *) IdentifierPath                  (* arguments: *) ArgumentsDeclaration?;</pre> <pre></pre> <pre>(* Introduced in 0.8.29 *)StorageLayoutSpecifier = (* layout_keyword: *) LAYOUT_KEYWORD                         (* at_keyword: *) AT_KEYWORD                         (* expression: *) Expression;</pre> <pre></pre> <pre>ContractMembers = (* item: *) ContractMember*;</pre> <pre></pre> <pre>ContractMember = (* variant: *) UsingDirective               | (* variant: *) FunctionDefinition               | (* variant: *) ConstructorDefinition (* Introduced in 0.4.22 *)               | (* variant: *) ReceiveFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) FallbackFunctionDefinition (* Introduced in 0.6.0 *)               | (* variant: *) UnnamedFunctionDefinition (* Deprecated in 0.6.0 *)               | (* variant: *) ModifierDefinition               | (* variant: *) StructDefinition               | (* variant: *) EnumDefinition               | (* variant: *) EventDefinition               | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)               | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)               | (* variant: *) StateVariableDefinition;</pre>"},{"location":"solidity-grammar/02-definitions/02-interfaces/","title":"2.2. Interfaces","text":""},{"location":"solidity-grammar/02-definitions/02-interfaces/#22-interfaces","title":"2.2. Interfaces","text":"<pre>InterfaceDefinition = (* interface_keyword: *) INTERFACE_KEYWORD                      (* name: *) IDENTIFIER                      (* inheritance: *) InheritanceSpecifier?                      (* open_brace: *) OPEN_BRACE                      (* members: *) InterfaceMembers                      (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>InterfaceMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-grammar/02-definitions/03-libraries/","title":"2.3. Libraries","text":""},{"location":"solidity-grammar/02-definitions/03-libraries/#23-libraries","title":"2.3. Libraries","text":"<pre>LibraryDefinition = (* library_keyword: *) LIBRARY_KEYWORD                    (* name: *) IDENTIFIER                    (* open_brace: *) OPEN_BRACE                    (* members: *) LibraryMembers                    (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>LibraryMembers = (* item: *) ContractMember*;</pre>"},{"location":"solidity-grammar/02-definitions/04-structs/","title":"2.4. Structs","text":""},{"location":"solidity-grammar/02-definitions/04-structs/#24-structs","title":"2.4. Structs","text":"<pre>StructDefinition = (* struct_keyword: *) STRUCT_KEYWORD                   (* name: *) IDENTIFIER                   (* open_brace: *) OPEN_BRACE                   (* members: *) StructMembers                   (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>StructMembers = (* item: *) StructMember*;</pre> <pre></pre> <pre>StructMember = (* type_name: *) TypeName               (* name: *) IDENTIFIER               (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/05-enums/","title":"2.5. Enums","text":""},{"location":"solidity-grammar/02-definitions/05-enums/#25-enums","title":"2.5. Enums","text":"<pre>EnumDefinition = (* enum_keyword: *) ENUM_KEYWORD                 (* name: *) IDENTIFIER                 (* open_brace: *) OPEN_BRACE                 (* members: *) EnumMembers                 (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>EnumMembers = ((* item: *) IDENTIFIER ((* separator: *) COMMA (* item: *) IDENTIFIER)*)?;</pre>"},{"location":"solidity-grammar/02-definitions/06-constants/","title":"2.6. Constants","text":""},{"location":"solidity-grammar/02-definitions/06-constants/#26-constants","title":"2.6. Constants","text":"<pre>(* Introduced in 0.7.4 *)ConstantDefinition = (* type_name: *) TypeName                     (* constant_keyword: *) CONSTANT_KEYWORD                     (* name: *) IDENTIFIER                     (* equal: *) EQUAL                     (* value: *) Expression                     (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/07-state-variables/","title":"2.7. State Variables","text":""},{"location":"solidity-grammar/02-definitions/07-state-variables/#27-state-variables","title":"2.7. State Variables","text":"<pre>StateVariableDefinition = (* type_name: *) TypeName                          (* attributes: *) StateVariableAttributes                          (* name: *) IDENTIFIER                          (* value: *) StateVariableDefinitionValue?                          (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>StateVariableDefinitionValue = (* equal: *) EQUAL                               (* value: *) Expression;</pre> <pre></pre> <pre>StateVariableAttributes = (* item: *) StateVariableAttribute*;</pre> <pre></pre> <pre>StateVariableAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                       | (* variant: *) CONSTANT_KEYWORD                       | (* variant: *) INTERNAL_KEYWORD                       | (* variant: *) PRIVATE_KEYWORD                       | (* variant: *) PUBLIC_KEYWORD                       | (* variant: *) IMMUTABLE_KEYWORD (* Introduced in 0.6.5 *)                       | (* variant: *) TRANSIENT_KEYWORD; (* Introduced in 0.8.27 *)</pre>"},{"location":"solidity-grammar/02-definitions/08-functions/","title":"2.8. Functions","text":""},{"location":"solidity-grammar/02-definitions/08-functions/#28-functions","title":"2.8. Functions","text":"<pre>FunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                     (* name: *) FunctionName                     (* parameters: *) ParametersDeclaration                     (* attributes: *) FunctionAttributes                     (* returns: *) ReturnsDeclaration?                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>FunctionName = (* variant: *) IDENTIFIER             | (* variant: *) FALLBACK_KEYWORD             | (* variant: *) RECEIVE_KEYWORD;</pre> <pre></pre> <pre>ParametersDeclaration = (* open_paren: *) OPEN_PAREN                        (* parameters: *) Parameters                        (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>Parameters = ((* item: *) Parameter ((* separator: *) COMMA (* item: *) Parameter)*)?;</pre> <pre></pre> <pre>Parameter = (* type_name: *) TypeName            (* storage_location: *) StorageLocation?            (* name: *) IDENTIFIER?;</pre> <pre></pre> <pre>FunctionAttributes = (* item: *) FunctionAttribute*;</pre> <pre></pre> <pre>FunctionAttribute = (* variant: *) ModifierInvocation                  | (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                  | (* variant: *) EXTERNAL_KEYWORD                  | (* variant: *) INTERNAL_KEYWORD                  | (* variant: *) PAYABLE_KEYWORD                  | (* variant: *) PRIVATE_KEYWORD                  | (* variant: *) PUBLIC_KEYWORD                  | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverrideSpecifier = (* override_keyword: *) OVERRIDE_KEYWORD                    (* overridden: *) OverridePathsDeclaration?;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePathsDeclaration = (* open_paren: *) OPEN_PAREN                           (* paths: *) OverridePaths                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)OverridePaths = (* item: *) IdentifierPath ((* separator: *) COMMA (* item: *) IdentifierPath)*;</pre> <pre></pre> <pre>ReturnsDeclaration = (* returns_keyword: *) RETURNS_KEYWORD                     (* variables: *) ParametersDeclaration;</pre> <pre></pre> <pre>FunctionBody = (* variant: *) Block             | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorDefinition = (* constructor_keyword: *) CONSTRUCTOR_KEYWORD                        (* parameters: *) ParametersDeclaration                        (* attributes: *) ConstructorAttributes                        (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttributes = (* item: *) ConstructorAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.4.22 *)ConstructorAttribute = (* variant: *) ModifierInvocation                     | (* variant: *) INTERNAL_KEYWORD                     | (* variant: *) OVERRIDE_KEYWORD (* Introduced in 0.6.0 and deprecated in 0.6.7. *)                     | (* variant: *) PAYABLE_KEYWORD                     | (* variant: *) PUBLIC_KEYWORD                     | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 and deprecated in 0.6.7. *)</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) UnnamedFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttributes = (* item: *) UnnamedFunctionAttribute*;</pre> <pre></pre> <pre>(* Deprecated in 0.6.0 *)UnnamedFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) INTERNAL_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) PRIVATE_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PUBLIC_KEYWORD (* Deprecated in 0.5.0 *)                         | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 and deprecated in 0.6.0. *)                         | (* variant: *) VIEW_KEYWORD; (* Introduced in 0.4.16 and deprecated in 0.6.0. *)</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionDefinition = (* fallback_keyword: *) FALLBACK_KEYWORD                             (* parameters: *) ParametersDeclaration                             (* attributes: *) FallbackFunctionAttributes                             (* returns: *) ReturnsDeclaration?                             (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttributes = (* item: *) FallbackFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)FallbackFunctionAttribute = (* variant: *) ModifierInvocation                          | (* variant: *) OverrideSpecifier                          | (* variant: *) EXTERNAL_KEYWORD                          | (* variant: *) PAYABLE_KEYWORD                          | (* variant: *) PURE_KEYWORD                          | (* variant: *) VIEW_KEYWORD                          | (* variant: *) VIRTUAL_KEYWORD;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionDefinition = (* receive_keyword: *) RECEIVE_KEYWORD                            (* parameters: *) ParametersDeclaration                            (* attributes: *) ReceiveFunctionAttributes                            (* body: *) FunctionBody;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttributes = (* item: *) ReceiveFunctionAttribute*;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)ReceiveFunctionAttribute = (* variant: *) ModifierInvocation                         | (* variant: *) OverrideSpecifier                         | (* variant: *) EXTERNAL_KEYWORD                         | (* variant: *) PAYABLE_KEYWORD                         | (* variant: *) VIRTUAL_KEYWORD;</pre>"},{"location":"solidity-grammar/02-definitions/09-modifiers/","title":"2.9. Modifiers","text":""},{"location":"solidity-grammar/02-definitions/09-modifiers/#29-modifiers","title":"2.9. Modifiers","text":"<pre>ModifierDefinition = (* modifier_keyword: *) MODIFIER_KEYWORD                     (* name: *) IDENTIFIER                     (* parameters: *) ParametersDeclaration?                     (* attributes: *) ModifierAttributes                     (* body: *) FunctionBody;</pre> <pre></pre> <pre>ModifierAttributes = (* item: *) ModifierAttribute*;</pre> <pre></pre> <pre>ModifierAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)</pre> <pre></pre> <pre>ModifierInvocation = (* name: *) IdentifierPath                     (* arguments: *) ArgumentsDeclaration?;</pre>"},{"location":"solidity-grammar/02-definitions/10-events/","title":"2.10. Events","text":""},{"location":"solidity-grammar/02-definitions/10-events/#210-events","title":"2.10. Events","text":"<pre>EventDefinition = (* event_keyword: *) EVENT_KEYWORD                  (* name: *) IDENTIFIER                  (* parameters: *) EventParametersDeclaration                  (* anonymous_keyword: *) ANONYMOUS_KEYWORD?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>EventParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) EventParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>EventParameters = ((* item: *) EventParameter ((* separator: *) COMMA (* item: *) EventParameter)*)?;</pre> <pre></pre> <pre>EventParameter = (* type_name: *) TypeName                 (* indexed_keyword: *) INDEXED_KEYWORD?                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/","title":"2.11. User Defined Value Types","text":""},{"location":"solidity-grammar/02-definitions/11-user-defined-value-types/#211-user-defined-value-types","title":"2.11. User Defined Value Types","text":"<pre>(* Introduced in 0.8.8 *)UserDefinedValueTypeDefinition = (* type_keyword: *) TYPE_KEYWORD                                 (* name: *) IDENTIFIER                                 (* is_keyword: *) IS_KEYWORD                                 (* value_type: *) ElementaryType                                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/02-definitions/12-errors/","title":"2.12. Errors","text":""},{"location":"solidity-grammar/02-definitions/12-errors/#212-errors","title":"2.12. Errors","text":"<pre>(* Introduced in 0.8.4 *)ErrorDefinition = (* error_keyword: *) ERROR_KEYWORD                  (* name: *) IDENTIFIER                  (* members: *) ErrorParametersDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParametersDeclaration = (* open_paren: *) OPEN_PAREN                             (* parameters: *) ErrorParameters                             (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameters = ((* item: *) ErrorParameter ((* separator: *) COMMA (* item: *) ErrorParameter)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)ErrorParameter = (* type_name: *) TypeName                 (* name: *) IDENTIFIER?;</pre>"},{"location":"solidity-grammar/03-types/","title":"3. Types","text":""},{"location":"solidity-grammar/03-types/#3-types","title":"3. Types","text":"<ul> <li>3.1. Advanced Types</li> <li>3.2. Elementary Types</li> </ul>"},{"location":"solidity-grammar/03-types/01-advanced-types/","title":"3.1. Advanced Types","text":""},{"location":"solidity-grammar/03-types/01-advanced-types/#31-advanced-types","title":"3.1. Advanced Types","text":"<pre>TypeName = (* variant: *) ArrayTypeName         | (* variant: *) FunctionType         | (* variant: *) MappingType         | (* variant: *) ElementaryType         | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)ArrayTypeName = (* operand: *) TypeName                (* open_bracket: *) OPEN_BRACKET                (* index: *) Expression?                (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>FunctionType = (* function_keyword: *) FUNCTION_KEYWORD               (* parameters: *) ParametersDeclaration               (* attributes: *) FunctionTypeAttributes               (* returns: *) ReturnsDeclaration?;</pre> <pre></pre> <pre>FunctionTypeAttributes = (* item: *) FunctionTypeAttribute*;</pre> <pre></pre> <pre>FunctionTypeAttribute = (* variant: *) INTERNAL_KEYWORD                      | (* variant: *) EXTERNAL_KEYWORD                      | (* variant: *) PRIVATE_KEYWORD                      | (* variant: *) PUBLIC_KEYWORD                      | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)                      | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)                      | (* variant: *) PAYABLE_KEYWORD;</pre> <pre></pre> <pre>MappingType = (* mapping_keyword: *) MAPPING_KEYWORD              (* open_paren: *) OPEN_PAREN              (* key_type: *) MappingKey              (* equal_greater_than: *) EQUAL_GREATER_THAN              (* value_type: *) MappingValue              (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>MappingKey = (* key_type: *) MappingKeyType             (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre> <pre></pre> <pre>MappingKeyType = (* variant: *) ElementaryType               | (* variant: *) IdentifierPath;</pre> <pre></pre> <pre>MappingValue = (* type_name: *) TypeName               (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)</pre>"},{"location":"solidity-grammar/03-types/02-elementary-types/","title":"3.2. Elementary Types","text":""},{"location":"solidity-grammar/03-types/02-elementary-types/#32-elementary-types","title":"3.2. Elementary Types","text":"<pre>ElementaryType = (* variant: *) BOOL_KEYWORD               | (* variant: *) BYTE_KEYWORD (* Deprecated in 0.8.0 *)               | (* variant: *) STRING_KEYWORD               | (* variant: *) AddressType               | (* variant: *) BYTES_KEYWORD               | (* variant: *) INT_KEYWORD               | (* variant: *) UINT_KEYWORD               | (* variant: *) FIXED_KEYWORD               | (* variant: *) UFIXED_KEYWORD;</pre> <pre></pre> <pre>AddressType = (* address_keyword: *) ADDRESS_KEYWORD              (* payable_keyword: *) PAYABLE_KEYWORD?; (* Introduced in 0.5.0 *)</pre>"},{"location":"solidity-grammar/04-statements/","title":"4. Statements","text":""},{"location":"solidity-grammar/04-statements/#4-statements","title":"4. Statements","text":"<ul> <li>4.1. Blocks</li> <li>4.2. Declaration Statements</li> <li>4.3. Control Statements</li> <li>4.4. Error Handling</li> </ul>"},{"location":"solidity-grammar/04-statements/01-blocks/","title":"4.1. Blocks","text":""},{"location":"solidity-grammar/04-statements/01-blocks/#41-blocks","title":"4.1. Blocks","text":"<pre>Block = (* open_brace: *) OPEN_BRACE        (* statements: *) Statements        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>Statements = (* item: *) Statement*;</pre> <pre></pre> <pre>Statement = (* variant: *) IfStatement          | (* variant: *) ForStatement          | (* variant: *) WhileStatement          | (* variant: *) DoWhileStatement          | (* variant: *) ContinueStatement          | (* variant: *) BreakStatement          | (* variant: *) ReturnStatement          | (* variant: *) ThrowStatement (* Deprecated in 0.5.0 *)          | (* variant: *) EmitStatement (* Introduced in 0.4.21 *)          | (* variant: *) TryStatement (* Introduced in 0.6.0 *)          | (* variant: *) RevertStatement (* Introduced in 0.8.4 *)          | (* variant: *) AssemblyStatement          | (* variant: *) Block          | (* variant: *) UncheckedBlock (* Introduced in 0.8.0 *)          | (* variant: *) TupleDeconstructionStatement          | (* variant: *) VariableDeclarationStatement          | (* variant: *) ExpressionStatement;</pre> <pre></pre> <pre>(* Introduced in 0.8.0 *)UncheckedBlock = (* unchecked_keyword: *) UNCHECKED_KEYWORD                 (* block: *) Block;</pre> <pre></pre> <pre>ExpressionStatement = (* expression: *) Expression                      (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>AssemblyStatement = (* assembly_keyword: *) ASSEMBLY_KEYWORD                    (* label: *) StringLiteral?                    (* flags: *) AssemblyFlagsDeclaration? (* Introduced in 0.8.13 *)                    (* body: *) YulBlock;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)AssemblyFlagsDeclaration = (* open_paren: *) OPEN_PAREN                           (* flags: *) AssemblyFlags                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>(* Introduced in 0.8.13 *)AssemblyFlags = (* item: *) StringLiteral ((* separator: *) COMMA (* item: *) StringLiteral)*;</pre>"},{"location":"solidity-grammar/04-statements/02-declaration-statements/","title":"4.2. Declaration Statements","text":""},{"location":"solidity-grammar/04-statements/02-declaration-statements/#42-declaration-statements","title":"4.2. Declaration Statements","text":"<pre>TupleDeconstructionStatement = (* var_keyword: *) VAR_KEYWORD? (* Deprecated in 0.5.0 *)                               (* open_paren: *) OPEN_PAREN                               (* elements: *) TupleDeconstructionElements                               (* close_paren: *) CLOSE_PAREN                               (* equal: *) EQUAL                               (* expression: *) Expression                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>TupleDeconstructionElements = (* item: *) TupleDeconstructionElement ((* separator: *) COMMA (* item: *) TupleDeconstructionElement)*;</pre> <pre></pre> <pre>TupleDeconstructionElement = (* member: *) TupleMember?;</pre> <pre></pre> <pre>TupleMember = (* variant: *) TypedTupleMember            | (* variant: *) UntypedTupleMember;</pre> <pre></pre> <pre>TypedTupleMember = (* type_name: *) TypeName                   (* storage_location: *) StorageLocation?                   (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>UntypedTupleMember = (* storage_location: *) StorageLocation?                     (* name: *) IDENTIFIER;</pre> <pre></pre> <pre>VariableDeclarationStatement = (* variable_type: *) VariableDeclarationType                               (* storage_location: *) StorageLocation?                               (* name: *) IDENTIFIER                               (* value: *) VariableDeclarationValue?                               (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>VariableDeclarationType = (* variant: *) TypeName                        | (* variant: *) VAR_KEYWORD; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>VariableDeclarationValue = (* equal: *) EQUAL                           (* expression: *) Expression;</pre> <pre></pre> <pre>StorageLocation = (* variant: *) MEMORY_KEYWORD                | (* variant: *) STORAGE_KEYWORD                | (* variant: *) CALL_DATA_KEYWORD; (* Introduced in 0.5.0 *)</pre>"},{"location":"solidity-grammar/04-statements/03-control-statements/","title":"4.3. Control Statements","text":""},{"location":"solidity-grammar/04-statements/03-control-statements/#43-control-statements","title":"4.3. Control Statements","text":"<pre>IfStatement = (* if_keyword: *) IF_KEYWORD              (* open_paren: *) OPEN_PAREN              (* condition: *) Expression              (* close_paren: *) CLOSE_PAREN              (* body: *) Statement              (* else_branch: *) ElseBranch?;</pre> <pre></pre> <pre>ElseBranch = (* else_keyword: *) ELSE_KEYWORD             (* body: *) Statement;</pre> <pre></pre> <pre>ForStatement = (* for_keyword: *) FOR_KEYWORD               (* open_paren: *) OPEN_PAREN               (* initialization: *) ForStatementInitialization               (* condition: *) ForStatementCondition               (* iterator: *) Expression?               (* close_paren: *) CLOSE_PAREN               (* body: *) Statement;</pre> <pre></pre> <pre>ForStatementInitialization = (* variant: *) TupleDeconstructionStatement                           | (* variant: *) VariableDeclarationStatement                           | (* variant: *) ExpressionStatement                           | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>ForStatementCondition = (* variant: *) ExpressionStatement                      | (* variant: *) SEMICOLON;</pre> <pre></pre> <pre>WhileStatement = (* while_keyword: *) WHILE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* condition: *) Expression                 (* close_paren: *) CLOSE_PAREN                 (* body: *) Statement;</pre> <pre></pre> <pre>DoWhileStatement = (* do_keyword: *) DO_KEYWORD                   (* body: *) Statement                   (* while_keyword: *) WHILE_KEYWORD                   (* open_paren: *) OPEN_PAREN                   (* condition: *) Expression                   (* close_paren: *) CLOSE_PAREN                   (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ContinueStatement = (* continue_keyword: *) CONTINUE_KEYWORD                    (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>BreakStatement = (* break_keyword: *) BREAK_KEYWORD                 (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>ReturnStatement = (* return_keyword: *) RETURN_KEYWORD                  (* expression: *) Expression?                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Introduced in 0.4.21 *)EmitStatement = (* emit_keyword: *) EMIT_KEYWORD                (* event: *) IdentifierPath                (* arguments: *) ArgumentsDeclaration                (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/04-statements/04-error-handling/","title":"4.4. Error Handling","text":""},{"location":"solidity-grammar/04-statements/04-error-handling/#44-error-handling","title":"4.4. Error Handling","text":"<pre>(* Introduced in 0.6.0 *)TryStatement = (* try_keyword: *) TRY_KEYWORD               (* expression: *) Expression               (* returns: *) ReturnsDeclaration?               (* body: *) Block               (* catch_clauses: *) CatchClauses;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauses = (* item: *) CatchClause+;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClause = (* catch_keyword: *) CATCH_KEYWORD              (* error: *) CatchClauseError?              (* body: *) Block;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)CatchClauseError = (* name: *) IDENTIFIER?                   (* parameters: *) ParametersDeclaration;</pre> <pre></pre> <pre>(* Introduced in 0.8.4 *)RevertStatement = (* revert_keyword: *) REVERT_KEYWORD                  (* error: *) IdentifierPath?                  (* arguments: *) ArgumentsDeclaration                  (* semicolon: *) SEMICOLON;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)ThrowStatement = (* throw_keyword: *) THROW_KEYWORD                 (* semicolon: *) SEMICOLON;</pre>"},{"location":"solidity-grammar/05-expressions/","title":"5. Expressions","text":""},{"location":"solidity-grammar/05-expressions/#5-expressions","title":"5. Expressions","text":"<ul> <li>5.1. Base Expressions</li> <li>5.2. Function Calls</li> <li>5.3. Primary Expressions</li> <li>5.4. Numbers</li> <li>5.5. Strings</li> <li>5.6. Identifiers</li> </ul>"},{"location":"solidity-grammar/05-expressions/01-base-expressions/","title":"5.1. Base Expressions","text":""},{"location":"solidity-grammar/05-expressions/01-base-expressions/#51-base-expressions","title":"5.1. Base Expressions","text":"<pre>Expression = (* variant: *) AssignmentExpression           | (* variant: *) ConditionalExpression           | (* variant: *) OrExpression           | (* variant: *) AndExpression           | (* variant: *) EqualityExpression           | (* variant: *) InequalityExpression           | (* variant: *) BitwiseOrExpression           | (* variant: *) BitwiseXorExpression           | (* variant: *) BitwiseAndExpression           | (* variant: *) ShiftExpression           | (* variant: *) AdditiveExpression           | (* variant: *) MultiplicativeExpression           | (* variant: *) ExponentiationExpression           | (* variant: *) PostfixExpression           | (* variant: *) PrefixExpression           | (* variant: *) FunctionCallExpression           | (* variant: *) CallOptionsExpression           | (* variant: *) MemberAccessExpression           | (* variant: *) IndexAccessExpression           | (* variant: *) NewExpression           | (* variant: *) TupleExpression           | (* variant: *) TypeExpression (* Introduced in 0.5.3 *)           | (* variant: *) ArrayExpression           | (* variant: *) HexNumberExpression           | (* variant: *) DecimalNumberExpression           | (* variant: *) StringExpression           | (* variant: *) ElementaryType           | (* variant: *) PAYABLE_KEYWORD (* Introduced in 0.6.0 *)           | (* variant: *) THIS_KEYWORD           | (* variant: *) SUPER_KEYWORD           | (* variant: *) TRUE_KEYWORD           | (* variant: *) FALSE_KEYWORD           | (* variant: *) IDENTIFIER;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) BAR_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PLUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) MINUS_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) CARET_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) SLASH_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) PERCENT_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) ASTERISK_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)AssignmentExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)ConditionalExpression = (* operand: *) Expression                        (* question_mark: *) QUESTION_MARK                        (* true_expression: *) Expression                        (* colon: *) COLON                        (* false_expression: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)OrExpression = (* left_operand: *) Expression               (* operator: *) BAR_BAR               (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AndExpression = (* left_operand: *) Expression                (* operator: *) AMPERSAND_AMPERSAND                (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) EQUAL_EQUAL                     (* right_operand: *) Expression;(* Left-associative binary operator *)EqualityExpression = (* left_operand: *) Expression                     (* operator: *) BANG_EQUAL                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) LESS_THAN_EQUAL                       (* right_operand: *) Expression;(* Left-associative binary operator *)InequalityExpression = (* left_operand: *) Expression                       (* operator: *) GREATER_THAN_EQUAL                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseOrExpression = (* left_operand: *) Expression                      (* operator: *) BAR                      (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseXorExpression = (* left_operand: *) Expression                       (* operator: *) CARET                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)BitwiseAndExpression = (* left_operand: *) Expression                       (* operator: *) AMPERSAND                       (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) LESS_THAN_LESS_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;(* Left-associative binary operator *)ShiftExpression = (* left_operand: *) Expression                  (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN                  (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) PLUS                     (* right_operand: *) Expression;(* Left-associative binary operator *)AdditiveExpression = (* left_operand: *) Expression                     (* operator: *) MINUS                     (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) SLASH                           (* right_operand: *) Expression;(* Left-associative binary operator *)MultiplicativeExpression = (* left_operand: *) Expression                           (* operator: *) PERCENT                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Left-associative binary operator *)(* Deprecated in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;(* Right-associative binary operator *)(* Introduced in 0.8.0 *)ExponentiationExpression = (* left_operand: *) Expression                           (* operator: *) ASTERISK_ASTERISK                           (* right_operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) PLUS_PLUS;(* Postfix unary operator *)PostfixExpression = (* operand: *) Expression                    (* operator: *) MINUS_MINUS;</pre> <pre></pre> <pre>(* Prefix unary operator *)PrefixExpression = (* operator: *) PLUS_PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS_MINUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) TILDE                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) BANG                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) MINUS                   (* operand: *) Expression;(* Prefix unary operator *)(* Deprecated in 0.5.0 *)PrefixExpression = (* operator: *) PLUS                   (* operand: *) Expression;(* Prefix unary operator *)PrefixExpression = (* operator: *) DELETE_KEYWORD                   (* operand: *) Expression;</pre> <pre></pre> <pre>(* Postfix unary operator *)FunctionCallExpression = (* operand: *) Expression                         (* arguments: *) ArgumentsDeclaration;</pre> <pre></pre> <pre>(* Postfix unary operator *)(* Introduced in 0.6.2 *)CallOptionsExpression = (* operand: *) Expression                        (* open_brace: *) OPEN_BRACE                        (* options: *) CallOptions                        (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>(* Postfix unary operator *)MemberAccessExpression = (* operand: *) Expression                         (* period: *) PERIOD                         (* member: *) IDENTIFIER;</pre> <pre></pre> <pre>(* Postfix unary operator *)IndexAccessExpression = (* operand: *) Expression                        (* open_bracket: *) OPEN_BRACKET                        (* start: *) Expression?                        (* end: *) IndexAccessEnd?                        (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>IndexAccessEnd = (* colon: *) COLON                 (* end: *) Expression?;</pre>"},{"location":"solidity-grammar/05-expressions/02-function-calls/","title":"5.2. Function Calls","text":""},{"location":"solidity-grammar/05-expressions/02-function-calls/#52-function-calls","title":"5.2. Function Calls","text":"<pre>ArgumentsDeclaration = (* variant: *) PositionalArgumentsDeclaration                     | (* variant: *) NamedArgumentsDeclaration;</pre> <pre></pre> <pre>PositionalArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                                 (* arguments: *) PositionalArguments                                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>PositionalArguments = ((* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*)?;</pre> <pre></pre> <pre>NamedArgumentsDeclaration = (* open_paren: *) OPEN_PAREN                            (* arguments: *) NamedArgumentGroup?                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NamedArgumentGroup = (* open_brace: *) OPEN_BRACE                     (* arguments: *) NamedArguments                     (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>NamedArguments = ((* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*)?;</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)CallOptions = (* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*;</pre> <pre></pre> <pre>NamedArgument = (* name: *) IDENTIFIER                (* colon: *) COLON                (* value: *) Expression;</pre>"},{"location":"solidity-grammar/05-expressions/03-primary-expressions/","title":"5.3. Primary Expressions","text":""},{"location":"solidity-grammar/05-expressions/03-primary-expressions/#53-primary-expressions","title":"5.3. Primary Expressions","text":"<pre>(* Introduced in 0.5.3 *)TypeExpression = (* type_keyword: *) TYPE_KEYWORD                 (* open_paren: *) OPEN_PAREN                 (* type_name: *) TypeName                 (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>NewExpression = (* new_keyword: *) NEW_KEYWORD                (* type_name: *) TypeName;</pre> <pre></pre> <pre>TupleExpression = (* open_paren: *) OPEN_PAREN                  (* items: *) TupleValues                  (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>TupleValues = (* item: *) TupleValue ((* separator: *) COMMA (* item: *) TupleValue)*;</pre> <pre></pre> <pre>TupleValue = (* expression: *) Expression?;</pre> <pre></pre> <pre>ArrayExpression = (* open_bracket: *) OPEN_BRACKET                  (* items: *) ArrayValues                  (* close_bracket: *) CLOSE_BRACKET;</pre> <pre></pre> <pre>ArrayValues = (* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*;</pre>"},{"location":"solidity-grammar/05-expressions/04-numbers/","title":"5.4. Numbers","text":""},{"location":"solidity-grammar/05-expressions/04-numbers/#54-numbers","title":"5.4. Numbers","text":"<pre>HexNumberExpression = (* literal: *) HEX_LITERAL                      (* unit: *) NumberUnit?; (* Deprecated in 0.5.0 *)</pre> <pre></pre> <pre>DecimalNumberExpression = (* literal: *) DECIMAL_LITERAL                          (* unit: *) NumberUnit?;</pre> <pre></pre> <pre>HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)* (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)HEX_LITERAL = \"0X\" \u00abHEX_CHARACTER\u00bb+ (\"_\" \u00abHEX_CHARACTER\u00bb+)* (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>DECIMAL_LITERAL = \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb (?!\".\") \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" (?!\u00abDECIMAL_DIGITS\u00bb) \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Deprecated in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb \".\" \u00abDECIMAL_DIGITS\u00bb \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);(* Introduced in 0.5.0 *)DECIMAL_LITERAL = \u00abDECIMAL_DIGITS\u00bb (\".\" \u00abDECIMAL_DIGITS\u00bb)? \u00abDECIMAL_EXPONENT\u00bb? (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>\u00abDECIMAL_DIGITS\u00bb = \"0\"\u2026\"9\"+ (\"_\" \"0\"\u2026\"9\"+)*;</pre> <pre></pre> <pre>\u00abDECIMAL_EXPONENT\u00bb = (\"e\" | \"E\") \"-\"? \u00abDECIMAL_DIGITS\u00bb;</pre> <pre></pre> <pre>NumberUnit = (* variant: *) WEI_KEYWORD           | (* variant: *) GWEI_KEYWORD (* Introduced in 0.6.11 *)           | (* variant: *) SZABO_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) FINNEY_KEYWORD (* Deprecated in 0.7.0 *)           | (* variant: *) ETHER_KEYWORD           | (* variant: *) SECONDS_KEYWORD           | (* variant: *) MINUTES_KEYWORD           | (* variant: *) HOURS_KEYWORD           | (* variant: *) DAYS_KEYWORD           | (* variant: *) WEEKS_KEYWORD           | (* variant: *) YEARS_KEYWORD; (* Deprecated in 0.5.0 *)</pre>"},{"location":"solidity-grammar/05-expressions/05-strings/","title":"5.5. Strings","text":""},{"location":"solidity-grammar/05-expressions/05-strings/#55-strings","title":"5.5. Strings","text":"<pre>StringExpression = (* variant: *) StringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) StringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) HexStringLiteral (* Deprecated in 0.5.14 *)                 | (* variant: *) HexStringLiterals (* Introduced in 0.5.14 *)                 | (* variant: *) UnicodeStringLiterals; (* Introduced in 0.7.0 *)</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)StringLiterals = (* item: *) StringLiteral+;</pre> <pre></pre> <pre>StringLiteral = (* variant: *) SINGLE_QUOTED_STRING_LITERAL              | (* variant: *) DOUBLE_QUOTED_STRING_LITERAL;</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";(* Introduced in 0.4.25 and deprecated in 0.7.0. *)SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";SINGLE_QUOTED_STRING_LITERAL = \"'\" (\u00abESCAPE_SEQUENCE\u00bb | \" \"\u2026\"&amp;\" | \"(\"\u2026\"[\" | \"]\"\u2026\"~\")* \"'\";</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';(* Introduced in 0.4.25 and deprecated in 0.7.0. *)DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';DOUBLE_QUOTED_STRING_LITERAL = '\"' (\u00abESCAPE_SEQUENCE\u00bb | \" \"\u2026\"!\" | \"#\"\u2026\"[\" | \"]\"\u2026\"~\")* '\"';</pre> <pre></pre> <pre>(* Introduced in 0.5.14 *)HexStringLiterals = (* item: *) HexStringLiteral+;</pre> <pre></pre> <pre>HexStringLiteral = (* variant: *) SINGLE_QUOTED_HEX_STRING_LITERAL                 | (* variant: *) DOUBLE_QUOTED_HEX_STRING_LITERAL;</pre> <pre></pre> <pre>SINGLE_QUOTED_HEX_STRING_LITERAL = \"hex'\" \u00abHEX_STRING_CONTENTS\u00bb? \"'\";</pre> <pre></pre> <pre>DOUBLE_QUOTED_HEX_STRING_LITERAL = 'hex\"' \u00abHEX_STRING_CONTENTS\u00bb? '\"';</pre> <pre></pre> <pre>\u00abHEX_STRING_CONTENTS\u00bb = \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb (\"_\"? \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb)*;</pre> <pre></pre> <pre>\u00abHEX_CHARACTER\u00bb = \"0\"\u2026\"9\" | \"a\"\u2026\"f\" | \"A\"\u2026\"F\";</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiterals = (* item: *) UnicodeStringLiteral+;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)UnicodeStringLiteral = (* variant: *) SINGLE_QUOTED_UNICODE_STRING_LITERAL                     | (* variant: *) DOUBLE_QUOTED_UNICODE_STRING_LITERAL;</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)SINGLE_QUOTED_UNICODE_STRING_LITERAL = \"unicode'\" (\u00abESCAPE_SEQUENCE\u00bb | !(\"'\" | \"\\\\\" | \"\\r\" | \"\\n\"))* \"'\";</pre> <pre></pre> <pre>(* Introduced in 0.7.0 *)DOUBLE_QUOTED_UNICODE_STRING_LITERAL = 'unicode\"' (\u00abESCAPE_SEQUENCE\u00bb | !('\"' | \"\\\\\" | \"\\r\" | \"\\n\"))* '\"';</pre> <pre></pre> <pre>\u00abESCAPE_SEQUENCE\u00bb = \"\\\\\" (\u00abASCII_ESCAPE\u00bb | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>(* Deprecated in 0.4.25 *)\u00abESCAPE_SEQUENCE_ARBITRARY\u00bb = \"\\\\\" (!(\"x\" | \"u\") | \u00abHEX_BYTE_ESCAPE\u00bb | \u00abUNICODE_ESCAPE\u00bb);</pre> <pre></pre> <pre>\u00abASCII_ESCAPE\u00bb = \"n\" | \"r\" | \"t\" | \"'\" | '\"' | \"\\\\\" | \"\\r\\n\" | \"\\r\" | \"\\n\";</pre> <pre></pre> <pre>\u00abHEX_BYTE_ESCAPE\u00bb = \"x\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre> <pre></pre> <pre>\u00abUNICODE_ESCAPE\u00bb = \"u\" \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb \u00abHEX_CHARACTER\u00bb;</pre>"},{"location":"solidity-grammar/05-expressions/06-identifiers/","title":"5.6. Identifiers","text":""},{"location":"solidity-grammar/05-expressions/06-identifiers/#56-identifiers","title":"5.6. Identifiers","text":"<pre>IdentifierPath = (* item: *) IDENTIFIER ((* separator: *) PERIOD (* item: *) IDENTIFIER)*;</pre> <pre></pre> <pre>IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>\u00abIDENTIFIER_START\u00bb = \"_\" | \"$\" | \"a\"\u2026\"z\" | \"A\"\u2026\"Z\";</pre> <pre></pre> <pre>\u00abIDENTIFIER_PART\u00bb = \u00abIDENTIFIER_START\u00bb | \"0\"\u2026\"9\";</pre>"},{"location":"solidity-grammar/06-yul/","title":"6. Yul","text":""},{"location":"solidity-grammar/06-yul/#6-yul","title":"6. Yul","text":"<ul> <li>6.1. Yul Statements</li> <li>6.2. Yul Expressions</li> <li>6.3. Yul Keywords</li> </ul>"},{"location":"solidity-grammar/06-yul/01-yul-statements/","title":"6.1. Yul Statements","text":""},{"location":"solidity-grammar/06-yul/01-yul-statements/#61-yul-statements","title":"6.1. Yul Statements","text":"<pre>YulBlock = (* open_brace: *) OPEN_BRACE           (* statements: *) YulStatements           (* close_brace: *) CLOSE_BRACE;</pre> <pre></pre> <pre>YulStatements = (* item: *) YulStatement*;</pre> <pre></pre> <pre>YulStatement = (* variant: *) YulBlock             | (* variant: *) YulFunctionDefinition             | (* variant: *) YulStackAssignmentStatement (* Deprecated in 0.5.0 *)             | (* variant: *) YulIfStatement             | (* variant: *) YulForStatement             | (* variant: *) YulSwitchStatement             | (* variant: *) YulLeaveStatement (* Introduced in 0.6.0 *)             | (* variant: *) YulBreakStatement             | (* variant: *) YulContinueStatement             | (* variant: *) YulVariableAssignmentStatement             | (* variant: *) YulLabel (* Deprecated in 0.5.0 *)             | (* variant: *) YulVariableDeclarationStatement             | (* variant: *) YulExpression;</pre> <pre></pre> <pre>YulFunctionDefinition = (* function_keyword: *) YUL_FUNCTION_KEYWORD                        (* name: *) YUL_IDENTIFIER                        (* parameters: *) YulParametersDeclaration                        (* returns: *) YulReturnsDeclaration?                        (* body: *) YulBlock;</pre> <pre></pre> <pre>YulParametersDeclaration = (* open_paren: *) OPEN_PAREN                           (* parameters: *) YulParameters                           (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulParameters = ((* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*)?;</pre> <pre></pre> <pre>YulReturnsDeclaration = (* minus_greater_than: *) MINUS_GREATER_THAN                        (* variables: *) YulVariableNames;</pre> <pre></pre> <pre>YulVariableNames = (* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*;</pre> <pre></pre> <pre>YulVariableDeclarationStatement = (* let_keyword: *) YUL_LET_KEYWORD                                  (* variables: *) YulVariableNames                                  (* value: *) YulVariableDeclarationValue?;</pre> <pre></pre> <pre>YulVariableDeclarationValue = (* assignment: *) YulAssignmentOperator                              (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulVariableAssignmentStatement = (* variables: *) YulPaths                                 (* assignment: *) YulAssignmentOperator                                 (* expression: *) YulExpression;</pre> <pre></pre> <pre>YulAssignmentOperator = (* variant: *) COLON_EQUAL                      | (* variant: *) YulColonAndEqual; (* Deprecated in 0.5.5 *)</pre> <pre></pre> <pre>(* Deprecated in 0.5.5 *)YulColonAndEqual = (* colon: *) COLON                   (* equal: *) EQUAL;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentStatement = (* assignment: *) YulStackAssignmentOperator                              (* variable: *) YUL_IDENTIFIER;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulStackAssignmentOperator = (* variant: *) EQUAL_COLON                           | (* variant: *) YulEqualAndColon;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulEqualAndColon = (* equal: *) EQUAL                   (* colon: *) COLON;</pre> <pre></pre> <pre>YulIfStatement = (* if_keyword: *) YUL_IF_KEYWORD                 (* condition: *) YulExpression                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulForStatement = (* for_keyword: *) YUL_FOR_KEYWORD                  (* initialization: *) YulBlock                  (* condition: *) YulExpression                  (* iterator: *) YulBlock                  (* body: *) YulBlock;</pre> <pre></pre> <pre>YulSwitchStatement = (* switch_keyword: *) YUL_SWITCH_KEYWORD                     (* expression: *) YulExpression                     (* cases: *) YulSwitchCases;</pre> <pre></pre> <pre>YulSwitchCases = (* item: *) YulSwitchCase+;</pre> <pre></pre> <pre>YulSwitchCase = (* variant: *) YulDefaultCase              | (* variant: *) YulValueCase;</pre> <pre></pre> <pre>YulDefaultCase = (* default_keyword: *) YUL_DEFAULT_KEYWORD                 (* body: *) YulBlock;</pre> <pre></pre> <pre>YulValueCase = (* case_keyword: *) YUL_CASE_KEYWORD               (* value: *) YulLiteral               (* body: *) YulBlock;</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)YulLeaveStatement = (* leave_keyword: *) YUL_LEAVE_KEYWORD;</pre> <pre></pre> <pre>YulBreakStatement = (* break_keyword: *) YUL_BREAK_KEYWORD;</pre> <pre></pre> <pre>YulContinueStatement = (* continue_keyword: *) YUL_CONTINUE_KEYWORD;</pre> <pre></pre> <pre>(* Deprecated in 0.5.0 *)YulLabel = (* label: *) YUL_IDENTIFIER           (* colon: *) COLON;</pre>"},{"location":"solidity-grammar/06-yul/02-yul-expressions/","title":"6.2. Yul Expressions","text":""},{"location":"solidity-grammar/06-yul/02-yul-expressions/#62-yul-expressions","title":"6.2. Yul Expressions","text":"<pre>YulExpression = (* variant: *) YulFunctionCallExpression              | (* variant: *) YulLiteral              | (* variant: *) YulPath;</pre> <pre></pre> <pre>(* Postfix unary operator *)YulFunctionCallExpression = (* operand: *) YulExpression                            (* open_paren: *) OPEN_PAREN                            (* arguments: *) YulArguments                            (* close_paren: *) CLOSE_PAREN;</pre> <pre></pre> <pre>YulArguments = ((* item: *) YulExpression ((* separator: *) COMMA (* item: *) YulExpression)*)?;</pre> <pre></pre> <pre>YulPaths = (* item: *) YulPath ((* separator: *) COMMA (* item: *) YulPath)*;</pre> <pre></pre> <pre>YulPath = (* item: *) YUL_IDENTIFIER ((* separator: *) PERIOD (* item: *) YUL_IDENTIFIER)*;</pre> <pre></pre> <pre>(* Introduced in 0.5.8 and deprecated in 0.7.0. *)YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb (\u00abIDENTIFIER_PART\u00bb | \".\")*;YUL_IDENTIFIER = \u00abIDENTIFIER_START\u00bb \u00abIDENTIFIER_PART\u00bb*;</pre> <pre></pre> <pre>YulLiteral = (* variant: *) YUL_TRUE_KEYWORD (* Introduced in 0.6.2 *)           | (* variant: *) YUL_FALSE_KEYWORD (* Introduced in 0.6.2 *)           | (* variant: *) YUL_DECIMAL_LITERAL           | (* variant: *) YUL_HEX_LITERAL           | (* variant: *) HexStringLiteral           | (* variant: *) StringLiteral;</pre> <pre></pre> <pre>YUL_DECIMAL_LITERAL = (\"0\" | (\"1\"\u2026\"9\" \"0\"\u2026\"9\"*)) (?!\u00abIDENTIFIER_START\u00bb);</pre> <pre></pre> <pre>YUL_HEX_LITERAL = \"0x\" \u00abHEX_CHARACTER\u00bb+ (?!\u00abIDENTIFIER_START\u00bb);</pre>"},{"location":"solidity-grammar/06-yul/03-yul-keywords/","title":"6.3. Yul Keywords","text":""},{"location":"solidity-grammar/06-yul/03-yul-keywords/#63-yul-keywords","title":"6.3. Yul Keywords","text":"<pre>(* Reserved until 0.7.1 *)YUL_ABSTRACT_KEYWORD = \"abstract\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AFTER_KEYWORD = \"after\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_ALIAS_KEYWORD = \"alias\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ANONYMOUS_KEYWORD = \"anonymous\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_APPLY_KEYWORD = \"apply\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_AS_KEYWORD = \"as\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ASSEMBLY_KEYWORD = \"assembly\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_AUTO_KEYWORD = \"auto\";</pre> <pre></pre> <pre>(* Reserved until 0.5.10 *)YUL_BOOL_KEYWORD = \"bool\";</pre> <pre></pre> <pre>YUL_BREAK_KEYWORD = \"break\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_BYTES_KEYWORD = \"bytes\" (\"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"32\")?;</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CALL_DATA_KEYWORD = \"calldata\";</pre> <pre></pre> <pre>YUL_CASE_KEYWORD = \"case\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CATCH_KEYWORD = \"catch\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONSTANT_KEYWORD = \"constant\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_CONSTRUCTOR_KEYWORD = \"constructor\";</pre> <pre></pre> <pre>YUL_CONTINUE_KEYWORD = \"continue\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_CONTRACT_KEYWORD = \"contract\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_COPY_OF_KEYWORD = \"copyof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DAYS_KEYWORD = \"days\";</pre> <pre></pre> <pre>YUL_DEFAULT_KEYWORD = \"default\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_DEFINE_KEYWORD = \"define\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DELETE_KEYWORD = \"delete\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_DO_KEYWORD = \"do\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ELSE_KEYWORD = \"else\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_EMIT_KEYWORD = \"emit\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ENUM_KEYWORD = \"enum\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_ETHER_KEYWORD = \"ether\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EVENT_KEYWORD = \"event\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_EXTERNAL_KEYWORD = \"external\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_FALLBACK_KEYWORD = \"fallback\";</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)YUL_FALSE_KEYWORD = \"false\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FINAL_KEYWORD = \"final\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_FINNEY_KEYWORD = \"finney\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\";(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_FIXED_KEYWORD = \"fixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>YUL_FOR_KEYWORD = \"for\";</pre> <pre></pre> <pre>YUL_FUNCTION_KEYWORD = \"function\";</pre> <pre></pre> <pre>(* Reserved from 0.7.0 until 0.7.1 *)YUL_GWEI_KEYWORD = \"gwei\";</pre> <pre></pre> <pre>YUL_HEX_KEYWORD = \"hex\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_HOURS_KEYWORD = \"hours\";</pre> <pre></pre> <pre>YUL_IF_KEYWORD = \"if\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMMUTABLE_KEYWORD = \"immutable\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_IMPLEMENTS_KEYWORD = \"implements\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IMPORT_KEYWORD = \"import\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INDEXED_KEYWORD = \"indexed\";</pre> <pre></pre> <pre>(* Reserved until 0.6.8 *)YUL_IN_KEYWORD = \"in\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INLINE_KEYWORD = \"inline\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERFACE_KEYWORD = \"interface\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INTERNAL_KEYWORD = \"internal\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_INT_KEYWORD = \"int\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_IS_KEYWORD = \"is\";</pre> <pre></pre> <pre>(* Introduced in 0.6.0 *)(* Reserved in 0.7.1 *)YUL_LEAVE_KEYWORD = \"leave\";</pre> <pre></pre> <pre>YUL_LET_KEYWORD = \"let\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_LIBRARY_KEYWORD = \"library\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MACRO_KEYWORD = \"macro\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MAPPING_KEYWORD = \"mapping\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MATCH_KEYWORD = \"match\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MEMORY_KEYWORD = \"memory\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MINUTES_KEYWORD = \"minutes\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_MODIFIER_KEYWORD = \"modifier\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_MUTABLE_KEYWORD = \"mutable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NEW_KEYWORD = \"new\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_NULL_KEYWORD = \"null\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_OF_KEYWORD = \"of\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_OVERRIDE_KEYWORD = \"override\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PARTIAL_KEYWORD = \"partial\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PAYABLE_KEYWORD = \"payable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRAGMA_KEYWORD = \"pragma\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PRIVATE_KEYWORD = \"private\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_PROMISE_KEYWORD = \"promise\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PUBLIC_KEYWORD = \"public\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_PURE_KEYWORD = \"pure\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_RECEIVE_KEYWORD = \"receive\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_REFERENCE_KEYWORD = \"reference\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RELOCATABLE_KEYWORD = \"relocatable\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_RETURNS_KEYWORD = \"returns\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SEALED_KEYWORD = \"sealed\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_SECONDS_KEYWORD = \"seconds\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SIZE_OF_KEYWORD = \"sizeof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STATIC_KEYWORD = \"static\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STORAGE_KEYWORD = \"storage\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRING_KEYWORD = \"string\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_STRUCT_KEYWORD = \"struct\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)YUL_SUPER_KEYWORD = \"super\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_SUPPORTS_KEYWORD = \"supports\";</pre> <pre></pre> <pre>YUL_SWITCH_KEYWORD = \"switch\";</pre> <pre></pre> <pre>(* Reserved until 0.7.0 *)YUL_SZABO_KEYWORD = \"szabo\";</pre> <pre></pre> <pre>(* Reserved in 0.8.0 *)YUL_THIS_KEYWORD = \"this\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_THROW_KEYWORD = \"throw\";</pre> <pre></pre> <pre>(* Introduced in 0.6.2 *)YUL_TRUE_KEYWORD = \"true\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TRY_KEYWORD = \"try\";</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_TYPE_DEF_KEYWORD = \"typedef\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_KEYWORD = \"type\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_TYPE_OF_KEYWORD = \"typeof\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\";(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\") \"x\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\");(* Reserved until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x8\" | \"184x16\" | \"184x24\" | \"184x32\" | \"184x40\" | \"184x48\" | \"184x56\" | \"184x64\" | \"184x72\" | \"192x8\" | \"192x16\" | \"192x24\" | \"192x32\" | \"192x40\" | \"192x48\" | \"192x56\" | \"192x64\" | \"200x8\" | \"200x16\" | \"200x24\" | \"200x32\" | \"200x40\" | \"200x48\" | \"200x56\" | \"208x8\" | \"208x16\" | \"208x24\" | \"208x32\" | \"208x40\" | \"208x48\" | \"216x8\" | \"216x16\" | \"216x24\" | \"216x32\" | \"216x40\" | \"224x8\" | \"224x16\" | \"224x24\" | \"224x32\" | \"232x8\" | \"232x16\" | \"232x24\" | \"240x8\" | \"240x16\" | \"248x8\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"184x80\" | \"192x72\" | \"192x80\" | \"200x64\" | \"200x72\" | \"200x80\" | \"208x56\" | \"208x64\" | \"208x72\" | \"208x80\" | \"216x48\" | \"216x56\" | \"216x64\" | \"216x72\" | \"216x80\" | \"224x40\" | \"224x48\" | \"224x56\" | \"224x64\" | \"224x72\" | \"224x80\" | \"232x32\" | \"232x40\" | \"232x48\" | \"232x56\" | \"232x64\" | \"232x72\" | \"232x80\" | \"240x24\" | \"240x32\" | \"240x40\" | \"240x48\" | \"240x56\" | \"240x64\" | \"240x72\" | \"240x80\" | \"248x16\" | \"248x24\" | \"248x32\" | \"248x40\" | \"248x48\" | \"248x56\" | \"248x64\" | \"248x72\" | \"248x80\" | \"256x8\" | \"256x16\" | \"256x24\" | \"256x32\" | \"256x40\" | \"256x48\" | \"256x56\" | \"256x64\" | \"256x72\" | \"256x80\");(* Reserved from 0.4.14 until 0.7.1 *)YUL_UFIXED_KEYWORD = \"ufixed\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\") \"x\" (\"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"9\" | \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"23\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\");</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_UINT_KEYWORD = \"uint\" (\"8\" | \"16\" | \"24\" | \"32\" | \"40\" | \"48\" | \"56\" | \"64\" | \"72\" | \"80\" | \"88\" | \"96\" | \"104\" | \"112\" | \"120\" | \"128\" | \"136\" | \"144\" | \"152\" | \"160\" | \"168\" | \"176\" | \"184\" | \"192\" | \"200\" | \"208\" | \"216\" | \"224\" | \"232\" | \"240\" | \"248\" | \"256\")?;</pre> <pre></pre> <pre>(* Reserved from 0.5.0 until 0.7.1 *)YUL_UNCHECKED_KEYWORD = \"unchecked\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_USING_KEYWORD = \"using\";</pre> <pre></pre> <pre>(* Reserved until 0.6.5 *)YUL_VAR_KEYWORD = \"var\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_VIEW_KEYWORD = \"view\";</pre> <pre></pre> <pre>(* Reserved from 0.6.0 until 0.7.1 *)YUL_VIRTUAL_KEYWORD = \"virtual\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEEKS_KEYWORD = \"weeks\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WEI_KEYWORD = \"wei\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_WHILE_KEYWORD = \"while\";</pre> <pre></pre> <pre>(* Reserved until 0.7.1 *)YUL_YEARS_KEYWORD = \"years\";</pre>"},{"location":"user-guide/","title":"User Guide","text":"<ul> <li>1. Introduction</li> <li>2. Powered By Slang</li> <li>3. Concepts</li> <li>4. Getting Started</li> <li>5. Syntax Trees</li> <li>6. Query Language</li> <li>7. Semantic Analysis</li> <li>8. Examples</li> <li>9. Appendix</li> </ul>"},{"location":"user-guide/01-introduction/","title":"1. Introduction","text":"<p>Welcome to the Slang user guide! This aims to be an introduction to Slang itself, its concepts and also contains a collection of guides how you can achieve basic tasks with it.</p>"},{"location":"user-guide/01-introduction/#what-is-slang","title":"What is Slang?","text":"<p>Slang is intended to be a modular Solidity compiler, specifically targeting code analysis and developer tooling. This means servicing tools with domain-specific APIs and, in general, facilitating working with and analyzing the Solidity source code. If you're in the editor writing Solidity or performing linting or additional validation, there's a chance that you are, or could be, running Slang!</p> <p>To get a good grasp on the concepts used in Slang, see the Concepts page.</p>"},{"location":"user-guide/01-introduction/#what-slang-is-not","title":"What Slang is not?","text":"<p>First and foremost, it is not a replacement for <code>solc</code>, the standard Solidity compiler. We do not plan at the moment to support emitting optimized EVM bytecode for use in production. Secondly, it does not perform formal verification of contracts or Solidity logic in general. However, other tools that serve this purpose are intended to be built on top of it.</p>"},{"location":"user-guide/01-introduction/#supporting-multiple-versions","title":"Supporting multiple versions","text":"<p>The Solidity programming language has evolved quite a bit since its inception. Some features were introduced, some changed, while some eventually became obsolete and were removed altogether.</p> <p>While it's good for a programming language to evolve and better serve the needs of its users, not being able to easily upgrade or re-deploy existing contracts poses a unique challenge. Developer tooling must be able to understand and consume older contracts that are still being used on the blockchain, written in older versions of Solidity.</p> <p>Because of that, Slang must be able to reason about different versions of Solidity; how the language grammar, name capture rules, and semantics have changed across different versions. One of our goals is to document differences as part of our Solidity Grammar.</p> <p>This is why, instead of having to download separate versions of the tool for each Solidity version, you can access the Slang language APIs by simply specifying the Solidity version that you want to work with.</p>"},{"location":"user-guide/01-introduction/#error-tolerance-as-a-feature","title":"Error Tolerance as a feature","text":"<p>A core feature of Slang is that it is designed to be tolerant of errors. All of its APIs don't expect the input to be correct or complete.</p> <p>For example, when users are actively editing code in an IDE, the code will often have syntax errors or incomplete constructs. In that case, the parser will detect syntax errors, and instead of just stopping at the first error, it will mark the erroneous part as either unrecognized or missing, creating an error node, and continue to parse the rest of the file (example).</p> <p>Another example is the binding graph, which will work even when there are missing source files. The graph will mark any missing definitions as <code>undefined</code>, and still resolve all other symbols in files that do exist. This is critical for tools that need to work with Solidity code in any environment, even when dependencies are missing or not yet installed locally (example).</p>"},{"location":"user-guide/01-introduction/#distributions","title":"Distributions","text":"<p>Slang itself is written in Rust, compiled as a WASM component, and distributed as an npm package with a TypeScript interface. In the future, we are also looking into publishing it as a Rust crate, a Python library, and possibly more.</p>"},{"location":"user-guide/02-powered-by-slang/","title":"2. Powered By Slang","text":"<p>If you are interested in using Slang in your project, we would love to hear from you! Please reach out to us on our Telegram group, or via GitHub issues.</p> <p>Slang is already being used by a number of Solidity developer tools today, to name a few:</p>"},{"location":"user-guide/02-powered-by-slang/#solidity-vscode","title":"Solidity VSCode","text":"<p>Nomic Foundation\u2019s own Solidity VSCode extension, with over 300k downloads, is using it to provide advanced language features like Semantic Highlighting and Document Symbols. Other features are being migrated to Slang soon.</p> <ul> <li>VSCode Marketplace Page</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#prettier-solidity","title":"Prettier Solidity","text":"<p>The upcoming v2 release of the popular Prettier plugin for Solidity, enhancing code formatting speed and correctness for tens of thousands of Solidity projects across the ecosystem.</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#openzeppelin-upgrades","title":"OpenZeppelin Upgrades","text":"<p>OpenZeppelin Upgrades uses Slang to analyze the NatSpec comments to implement namespaced storage layout (ERC-7201).</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#sspec","title":"SSpec","text":"<p>SSpec is a Solidity specification generator for Foundry projects. Using test names it produces human readable descriptions for smart contracts, their functions, and facilitates navigation across tests providing links to functions in test files.</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#lintspec","title":"LintSpec","text":"<p>LintSpec is a tool for finding common errors in Solidity documentation. It is a port of natspec-smells to Rust, based on Slang, that is reported to be 214x faster.</p> <ul> <li>Rust Crate</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/02-powered-by-slang/#slippy","title":"Slippy","text":"<p>Slippy is a simple and powerful linter for Solidity. Slippy leverages Slang to provide accurate and flexible linting capabilities for Solidity projects.</p> <ul> <li>NPM Package</li> <li>GitHub Repository</li> </ul>"},{"location":"user-guide/03-concepts/","title":"3. Concepts","text":"<p>At its core, Slang is a collection of APIs that are meant to analyze the source code, starting with the source code itself and ending with a rich structure that can be reasoned about. This is a departure from the classic approach of \"black-box\" compilers, which are handed the input and only their output can be observed.</p>"},{"location":"user-guide/03-concepts/#language-grammar","title":"Language Grammar","text":"<p>The entire Solidity grammar (across all supported versions) is defined in the Solidity Grammar section. You can use this as a guide when developing your own tools using Slang. The grammar is also included as documentation on top of the corresponding APIs (like <code>TerminalKind</code>, <code>NonterminalKind</code>, and <code>EdgeLabel</code> variants). It explains the structure of each node, and the relationships between each parent and its children.</p>"},{"location":"user-guide/03-concepts/#parser","title":"Parser","text":"<p>The <code>Parser</code> API is used to produce a Concrete Syntax Tree (CST) from Solidity source code. Each <code>Parser</code> object is initialized with a specific Solidity version.</p> <p>With a <code>Parser</code> object, you can analyze any source text according to the grammar of that specific version. Providing an accurate language version is important, as it affects the shape of the syntax tree, and possible errors produced. Check the Solidity Grammar for a list of supported versions.</p> <p>Each parse operation will produce a <code>ParseOutput</code> object, which contains the root of the CST corresponding to the input source code, and any syntax errors found during parsing.</p>"},{"location":"user-guide/03-concepts/#concrete-syntax-trees-cst","title":"Concrete Syntax Trees (CST)","text":"<p>Slang is capable of parsing the source code into a Concrete Syntax Tree (CST), which is a tree structure representing the entire source code. It includes the contracts, functions, statements, and expressions within. It also includes things like comments, whitespace, and punctuation. This is sometimes called a \"full-fidelity\" CST, and it can be used to reconstruct the original source code when needed.</p> <p>The tree nodes are represented by the <code>Node</code> structure, which can be one of two kinds:</p> <ul> <li><code>NonterminalNode</code> represents parent nodes, possibly containing children (sub-trees).</li> <li><code>TerminalNode</code> represents leaves (i.e. an identifier, keyword, or punctuation) in the tree.</li> </ul> <p>Nodes are connected through <code>Edge</code> objects, which contain a single child <code>Node</code>, and an <code>EdgeLabel</code> that describes the relationship between the parent and child.</p> <p>You can find a complete list of all grammar nodes and edges in the Solidity Grammar section.</p>"},{"location":"user-guide/03-concepts/#cursors","title":"Cursors","text":"<p>For many code analysis tasks, it is useful to traverse the parse tree and visit each node. The <code>Cursor</code> object allows callers to traverse the parse tree in an efficient pre-order manner.</p> <p>It provides several <code>goTo*()</code> navigation functions, each returning <code>true</code> if the cursor was successfully moved, and <code>false</code> otherwise. There are three main ways to do it:</p> <ul> <li>According to the order they appear in the tree, i.e. <code>goToNext()</code> and <code>goToPrevious()</code>,</li> <li>According to the relationship between the current node and the next node, i.e. <code>goToParent()</code>, <code>goToFirstChild()</code>, <code>goToNextNonDescendant()</code></li> <li>According to the kind of the next node, i.e. <code>goToNextTerminalWithKind(kind)</code>, <code>goToNextNonterminalWithKind(kind)</code></li> </ul> <p>As such, the cursor is stateful and keeps track of the path it has taken through the CST. It starts at the root it was created at and is completed when it reaches its root when navigating forward.</p> <p>Cursors can also be cloned, to allow for multiple traversals of the same tree, or spawned, to allow for traversing the subtree of the current node.</p>"},{"location":"user-guide/03-concepts/#queries","title":"Queries","text":"<p>The <code>Cursor</code> API is a low-level API that allows you to traverse the CST in a procedural manner. However, it is often more convenient to use the declarative <code>Query</code> API. Queries allow you to express your intent more concisely, and also allows you to reuse the same query in multiple places. Queries can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The tree query language is based on pattern matching, and the execution semantics are closer to unification than to regular expression matching i.e. a query returns all possible matches, not just the longest/shortest/first/last match. There is no concept of a 'greedy' operator for example.</p> <p>Query execution is based on cursors, and the resulting matches and unification captures are returned as cursors as well. This allows you to mix and match manual traversal, cursors, and queries.</p> <p>Multiple queries can be executed in a batch, and efficiently traverse the tree looking for matches. This mode of operation can replace all visitor patterns.</p>"},{"location":"user-guide/03-concepts/#abstract-syntax-trees-ast","title":"Abstract Syntax Trees (AST)","text":"<p>AST types are a set of abstractions that provide a typed view of the untyped CST nodes. You can convert any untyped CST node to its corresponding AST type using their constructors.</p> <p>There is a corresponding type for each <code>NonterminalKind</code> in the language. AST types are immutable. Additionally, their fields are constructed lazily as they are accessed for the first time.</p> <p>AST nodes maintain a reference to the CST node they were constructed from, and can be used to navigate to the corresponding CST node.</p>"},{"location":"user-guide/03-concepts/#compilation-unit","title":"Compilation Unit","text":"<p>A <code>CompilationUnit</code> is a collection of all source files that should be compiled together. This includes your main contract, and any imported files or dependencies that are used there.</p> <p>A <code>CompilationBuilder</code> is used to build a <code>CompilationUnit</code>. It is provided with a Solidity version, then the list of source files are incrementally added to it in any order. With each source file added, the builder will analyze all import statements within, and ask the user to resolve them to the imported source files, and continue loading/analyzing them, until it is complete.</p>"},{"location":"user-guide/03-concepts/#binding-graph","title":"Binding Graph","text":"<p>The <code>BindingGraph</code> is a graph structure that represents the relationships between identifiers across source files in a <code>CompilationUnit</code>. For each identifier, it will analyze if it is acting as a <code>Definition</code> or a <code>Reference</code> (aliases for example), and provide an API for users to resolve them.</p> <p>It can also be used to query the relationships between them; finding all references to a specific definition, or all definitions that are bound by a specific reference.</p>"},{"location":"user-guide/04-getting-started/","title":"4. Getting Started","text":"<ul> <li>4.1. Installation</li> <li>4.2. Choosing a Solidity Version</li> </ul>"},{"location":"user-guide/04-getting-started/01-installation/","title":"4.1. Installation","text":""},{"location":"user-guide/04-getting-started/01-installation/#adding-the-npm-package","title":"Adding the NPM package","text":"<p>You can install Slang NPM package simply by running the following <code>npm</code> command:</p> bash<pre><code>npm install \"@nomicfoundation/slang\"\n</code></pre> <p>Or if you are using <code>yarn</code> for package management:</p> bash<pre><code>yarn add \"@nomicfoundation/slang\"\n</code></pre>"},{"location":"user-guide/04-getting-started/01-installation/#esm-vs-commonjs","title":"ESM vs CommonJS","text":"<p>Slang is implemented in Rust, and compiled as a WASM component, which is exposed to TypeScript/JavaScript, and loaded asynchronously. If you are working with a modern ESM project, this will just work out of the box, with no additional configuration needed.</p> use-from-esm.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"top-level ESM import\", () =&gt; {\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  assert(parser);\n});\n</code></pre> <p>But if you are working with a legacy CommonJS project, asynchronous imports are not supported. In that case, you can use the <code>await import()</code> syntax to load Slang:</p> use-from-commonjs.mts<pre><code>import assert from \"node:assert\";\n\ntest(\"CommonJS await import\", async () =&gt; {\n  const { Parser } = await import(\"@nomicfoundation/slang/parser\");\n  const { LanguageFacts } = await import(\"@nomicfoundation/slang/utils\");\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  assert(parser);\n});\n</code></pre>"},{"location":"user-guide/04-getting-started/02-choosing-a-solidity-version/","title":"4.2. Choosing a Solidity Version","text":""},{"location":"user-guide/04-getting-started/02-choosing-a-solidity-version/#supported-versions","title":"Supported Versions","text":"<p>Slang aims to support all Solidity language versions, starting with <code>0.4.11</code>, and adding support for all future versions as they are released.</p> <p>In order to use many of the Slang APIs, you will need to specify the Solidity version that you want to work with. You can see a list of all supported Solidity versions here.</p> <p>You can also access this list programmatically, by using the <code>LanguageFacts</code> API:</p> supported-versions.mts<pre><code>import assert from \"node:assert\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"supported versions\", () =&gt; {\n  assert.strictEqual(LanguageFacts.allVersions().length, 85);\n\n  assert.strictEqual(LanguageFacts.earliestVersion(), \"0.4.11\");\n\n  assert.strictEqual(LanguageFacts.latestVersion(), \"0.8.30\");\n});\n</code></pre>"},{"location":"user-guide/04-getting-started/02-choosing-a-solidity-version/#inferring-compatible-solidity-versions","title":"Inferring Compatible Solidity Versions","text":"<p>For cases where you don't know in advance which version of Solidity to use, the <code>LanguageFacts</code> API provides a utility to generate a list of compatible versions. It uses the version pragmas defined in your Solidity source file to filter the list of versions supported by Slang, returning only the compatible ones.</p> <p>The list is sorted in ascending order. The first item in the list will typically be the version that the code author used during development and testing, and the last item will be the latest version allowed by the code author and supported by Slang. If the source file does not contain any version pragmas, all versions supported by Slang will be returned.</p> infer-versions.mts<pre><code>import assert from \"node:assert\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\nconst src = `\n  pragma solidity ^0.8.0;\n\n  contract Test {}\n`;\n\ntest(\"infer versions\", () =&gt; {\n  const versions = LanguageFacts.inferLanguageVersions(src);\n\n  assert(versions.includes(\"0.8.0\"));\n  assert(versions.includes(\"0.8.3\"));\n  assert(!versions.includes(\"0.7.8\"));\n  assert(!versions.includes(\"1.0.0\"));\n\n  const latest = versions.at(-1);\n  assert(latest == \"0.8.30\");\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/","title":"5. Syntax Trees","text":"<ul> <li>5.1. Parsing Source Code</li> <li>5.2. Handling Syntax Errors</li> <li>5.3. Navigating with Cursors</li> <li>5.4. Using AST Types</li> </ul>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/","title":"5.1. Using the Parser","text":"<p>The Parser API provides us with fine-grained control over the parsing process. It allows us to parse not just the input as a top-level source unit, but also individual constructs like contracts, various definitions, and even expressions.</p>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#parsing-source-files","title":"Parsing Source Files","text":"<p>Let's start with this simple source file, that contains a single contract, and parse it into a concrete syntax tree. The parser will produce a <code>ParseOutput</code> object, which contains a <code>SourceUnit</code> root node:</p> parsing-source-files.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { assertNonterminalNode, NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"parsing source files\", () =&gt; {\n  const source = `\n    contract Foo {}\n  `;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  const parseOutput = parser.parseFileContents(source);\n\n  assert(parseOutput.isValid());\n  assertNonterminalNode(parseOutput.tree, NonterminalKind.SourceUnit, source);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#parsing-nonterminals","title":"Parsing Nonterminals","text":"<p>The parser API also allows you to parse specific nonterminal nodes, like statements or expressions. This is useful when you want to parse a snippet, and not an entire source file, like the <code>AdditiveExpression</code> node below:</p> parsing-nonterminals.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertNonterminalNode,\n  assertTerminalNode,\n  EdgeLabel,\n  NonterminalKind,\n  TerminalKind,\n} from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"parsing nonterminals\", () =&gt; {\n  const source = `x+y`;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  const parseOutput = parser.parseNonterminal(NonterminalKind.AdditiveExpression, source);\n\n  assert(parseOutput.isValid());\n  assertNonterminalNode(parseOutput.tree, NonterminalKind.AdditiveExpression, source);\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assert.strictEqual(children[0].label, EdgeLabel.LeftOperand);\n  assertNonterminalNode(children[0].node, NonterminalKind.Expression, \"x\");\n\n  assert.strictEqual(children[1].label, EdgeLabel.Operator);\n  assertTerminalNode(children[1].node, TerminalKind.Plus, \"+\");\n\n  assert.strictEqual(children[2].label, EdgeLabel.RightOperand);\n  assertNonterminalNode(children[2].node, NonterminalKind.Expression, \"y\");\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/01-parsing-source-code/#handling-trivia-nodes","title":"Handling Trivia Nodes","text":"<p>Trivia nodes represent comments, whitespace, newlines, and other non-essential terminals that can appear anywhere in the source code, and they are categorized by the parser into two groups:</p> <ul> <li>Leading Trivia: terminals that appear before a significant terminal, and can span multiple lines (for example, documentation comments).</li> <li>Trailing Trivia: terminals that appear after a significant terminal on the same line, leading to, and including, the following newline terminal.</li> </ul> <p>You can use the <code>TerminalKindExtensions.isTrivia()</code> API to check if a terminal is a trivia terminal.</p> handling-trivia.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertTerminalNode,\n  EdgeLabel,\n  NonterminalKind,\n  TerminalKind,\n  TerminalKindExtensions,\n} from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"handling trivia\", () =&gt; {\n  const source = `  true\\n`;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  const parseOutput = parser.parseNonterminal(NonterminalKind.Expression, source);\n  assert(parseOutput.isValid());\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assert.strictEqual(children[0].label, EdgeLabel.LeadingTrivia);\n  assertTerminalNode(children[0].node, TerminalKind.Whitespace, \"  \");\n  assert(TerminalKindExtensions.isTrivia(children[0].node.kind));\n\n  assert.strictEqual(children[1].label, EdgeLabel.Variant);\n  assertTerminalNode(children[1].node, TerminalKind.TrueKeyword, \"true\");\n  assert(!TerminalKindExtensions.isTrivia(children[1].node.kind));\n\n  assert.strictEqual(children[2].label, EdgeLabel.TrailingTrivia);\n  assertTerminalNode(children[2].node, TerminalKind.EndOfLine, \"\\n\");\n  assert(TerminalKindExtensions.isTrivia(children[2].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/","title":"5.2. Handling Syntax Errors","text":"<p>If there are syntax errors with the input, the <code>ParseOutput</code> object will contain the list of errors found. Each error will have a message, and a <code>TextRange</code> that indicates the location of the error in the input.</p> <p>Additionally, the parsed tree will contain an error node for each error encountered, which can be one of two kinds, missing or unrecognized, depending on the error.</p> <p>You can use the <code>TerminalKindExtensions.isValid()</code> API to check if a terminal is valid or is an error node.</p>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/#missing-nodes","title":"Missing Nodes","text":"<p>These occur when the parser expects a certain node to be present, but it is not. It will create a missing node in its place, and continue parsing as if it was present.</p> missing-error-nodes.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { assertTerminalNode, NonterminalKind, TerminalKind, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"missing error nodes\", () =&gt; {\n  const source = `contract`;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  const parseOutput = parser.parseNonterminal(NonterminalKind.ContractDefinition, source);\n  assert(!parseOutput.isValid());\n\n  const errors = parseOutput.errors();\n  assert.strictEqual(errors.length, 1);\n\n  assert.strictEqual(errors[0].message, \"Expected Identifier.\");\n  assert.deepStrictEqual(errors[0].textRange, {\n    start: { line: 0, column: 8, utf8: 8, utf16: 8 },\n    end: { line: 0, column: 8, utf8: 8, utf16: 8 },\n  });\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 2);\n\n  assertTerminalNode(children[0].node, TerminalKind.ContractKeyword, \"contract\");\n\n  assertTerminalNode(children[1].node, TerminalKind.Missing, \"\");\n  assert(!TerminalKindExtensions.isValid(children[1].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/02-handling-syntax-errors/#unrecognized-nodes","title":"Unrecognized Nodes","text":"<p>These occur when the parser encounters a token that it does not recognize, and it cannot parse. It will create an unrecognized node in its place, and continue parsing as if it doesn't exist.</p> unrecognized-error-nodes.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport {\n  assertNonterminalNode,\n  assertTerminalNode,\n  NonterminalKind,\n  TerminalKind,\n  TerminalKindExtensions,\n} from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"unrecognized error nodes\", () =&gt; {\n  const source = `\n    foo();\n    %`;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n  const parseOutput = parser.parseNonterminal(NonterminalKind.Statements, source);\n  assert(!parseOutput.isValid());\n\n  const errors = parseOutput.errors();\n  assert.strictEqual(errors.length, 1);\n\n  assert.match(errors[0].message, /^Expected AddressKeyword or/);\n  assert.deepStrictEqual(errors[0].textRange, {\n    start: { line: 2, column: 4, utf8: 16, utf16: 16 },\n    end: { line: 2, column: 5, utf8: 17, utf16: 17 },\n  });\n\n  const children = parseOutput.tree.children();\n  assert.strictEqual(children.length, 3);\n\n  assertNonterminalNode(children[0].node, NonterminalKind.Statement);\n\n  assertTerminalNode(children[1].node, TerminalKind.Whitespace, \"    \");\n  assert(TerminalKindExtensions.isValid(children[1].node.kind));\n\n  assertTerminalNode(children[2].node, TerminalKind.Unrecognized, \"%\");\n  assert(!TerminalKindExtensions.isValid(children[2].node.kind));\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/","title":"5.3. Using Cursors","text":"<p>This guide will walk you through the basics of using a CST cursor in your project. Let's start with this source file, that contains three contracts:</p> common.mts<pre><code>import assert from \"node:assert\";\nimport { ParseOutput, Parser } from \"@nomicfoundation/slang/parser\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\nexport function createTree(): ParseOutput {\n  const source = `\n    contract Foo {\n      function foo_func() {}\n    }\n    contract Bar {\n      function bar_func() {}\n    }\n    contract Baz {\n      function baz_func() {}\n    }\n  `;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n\n  const parseOutput = parser.parseFileContents(source.trim());\n  assert(parseOutput.isValid());\n\n  return parseOutput;\n}\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#listing-contract-names","title":"Listing Contract Names","text":"<p>The below example uses a cursor to list the names of all contracts in a source file:</p> listing-contract-names.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"listing contract names\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const contracts = [];\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n    assert(cursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n    contracts.push(cursor.node.unparse());\n  }\n\n  assert.deepStrictEqual(contracts, [\"Foo\", \"Bar\", \"Baz\"]);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#visiting-only-a-sub-tree","title":"Visiting Only a Sub-tree","text":"<p>Next, we will try to get the names of all contract functions, grouped by the contract name. In this case, it is not enough to just visit all instances of <code>FunctionDefinition</code> nodes, since we want to exclude the ones that are not part of a contract.</p> <p>We need first to find all <code>ContractDefinition</code> nodes, and then for each contract, look for all <code>FunctionDefinition</code> nodes, limiting the search to just the contract's subtree. To do that, we need to use the <code>cursor.spawn()</code> API, which cheaply creates a new cursor that starts at the given node, without copying the ancestry information, so it will only be able to see the sub-tree of the current node.</p> visiting-subtrees.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind, TerminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"visiting subtrees\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const results: { [contractName: string]: string[] } = {};\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.ContractDefinition)) {\n    const childCursor = cursor.spawn();\n    assert(childCursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n\n    const contractName = childCursor.node.unparse();\n    results[contractName] = [];\n\n    while (childCursor.goToNextNonterminalWithKind(NonterminalKind.FunctionDefinition)) {\n      assert(childCursor.goToNextTerminalWithKind(TerminalKind.Identifier));\n      results[contractName].push(childCursor.node.unparse());\n    }\n  }\n\n  assert.deepStrictEqual(results, {\n    Foo: [\"foo_func\"],\n    Bar: [\"bar_func\"],\n    Baz: [\"baz_func\"],\n  });\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/03-navigating-with-cursors/#accessing-node-positions","title":"Accessing Node Positions","text":"<p>The <code>Cursor</code> API also tracks the position and range of the current node it is visiting. Here is an example that records the line number of each function, along with its text:</p> accessing-node-positions.mts<pre><code>import assert from \"node:assert\";\nimport { createTree } from \"./common.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\n\ntest(\"accessing node positions\", () =&gt; {\n  const tree = createTree();\n  const cursor = tree.createTreeCursor();\n\n  const functions = [];\n\n  while (cursor.goToNextNonterminalWithKind(NonterminalKind.FunctionDefinition)) {\n    const line = cursor.textRange.start.line;\n    const text = cursor.node.unparse().trim();\n\n    functions.push({ line, text });\n  }\n\n  assert.deepStrictEqual(functions, [\n    { line: 1, text: \"function foo_func() {}\" },\n    { line: 4, text: \"function bar_func() {}\" },\n    { line: 7, text: \"function baz_func() {}\" },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/05-syntax-trees/04-using-ast-types/","title":"5.4. Using AST Types","text":"<p>So far we've been using the CST of a Solidity file or fragment. However, the CST is too verbose, and not always convenient to use for extracting information of the program. In the following example, we are going to show how to obtain the parameters and attributes of a function using the AST, an abstract representation of the program tree.</p> <p>We start as usual by parsing the input, and then we can use the <code>ParseOutput</code> root to create the CST type. Since it is a node of kind <code>FunctionDefinition</code>, we are using the AST type of the same name to analyze it.</p> <p>The <code>FunctionDefinition</code> type has named fields to access all its children. For example, we can check the name of the function, list its parameters, or attributes:</p> using-ast-types.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { FunctionDefinition } from \"@nomicfoundation/slang/ast\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"using the ast\", async () =&gt; {\n  const source = `\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\n      return a + b;\n    }\n  `;\n\n  const parser = Parser.create(LanguageFacts.latestVersion());\n\n  const parseOutput = parser.parseNonterminal(NonterminalKind.FunctionDefinition, source);\n  assert(parseOutput.isValid());\n\n  const func = new FunctionDefinition(parseOutput.tree);\n  assert.strictEqual(func.name.variant.unparse(), \"add\");\n\n  const parameters = func.parameters.parameters.items.map((parameter) =&gt; parameter.cst.unparse().trim());\n  assert.deepEqual(parameters, [\"uint256 a\", \"uint256 b\"]);\n\n  const attributes = func.attributes.items.map((attribute) =&gt; attribute.cst.unparse().trim());\n  assert.deepEqual(attributes, [\"public\", \"pure\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/","title":"6. Query Language","text":"<ul> <li>6.1. Query Syntax</li> <li>6.2. Executing Queries</li> </ul>"},{"location":"user-guide/06-query-language/01-query-syntax/","title":"6.1. Query Syntax","text":"<p>It's often more convenient to use the declarative <code>Query</code> API to traverse the CST, as they allow you to express your intent more concisely and can largely replace the need for both internal (cursor), and external (visitor) iterator patterns.</p> <p>The query engine performs pattern matching, and the execution semantics are closer to unification than to regular expression matching. A query returns all possible matches, not just the longest/shortest/first/last match.</p>"},{"location":"user-guide/06-query-language/01-query-syntax/#matching","title":"Matching","text":"<p>A query is a pattern that matches a certain set of nodes in a tree. The expression to match a given node consists of a pair of brackets (<code>[]</code>) containing two things: the node's kind, and optionally, a series of other patterns that match the node's children. For example, this pattern would match any <code>MultiplicativeExpression</code> node that has two children <code>Expression</code> nodes, with an <code>Asterisk</code> node in between:</p> <pre><code>[MultiplicativeExpression\n  [Expression]\n  [Asterisk]\n  [Expression]\n]\n</code></pre> <p>The children of a node can optionally be labeled. The label is a property of the edge from the node to the child, and is not a property of the child. For example, this pattern will match a <code>MultiplicativeExpression</code> node with the two <code>Expression</code> children labeled <code>left_operand</code> and <code>right_operand</code>:</p> <pre><code>[MultiplicativeExpression\n  left_operand: [Expression]\n  [Asterisk]\n  right_operand: [Expression]\n]\n</code></pre> <p>You can also match a node's textual content using a string literal. For example, this pattern would match a <code>MultiplicativeExpression</code> with a <code>*</code> operator (for clarity):</p> <pre><code>[MultiplicativeExpression\n  left_operand: [_]\n  operator: [\"*\"]\n  right_operand: [_]\n]\n</code></pre> <p>If you don't care about the kind of a node, you can use an underscore <code>_</code>, which matches any kind. For example, this pattern will match a <code>MultiplicativeExpression</code> node with any two children with any kind, as long as one of them is labeled <code>left_operand</code>:</p> <pre><code>[MultiplicativeExpression\n  left_operand: [_]\n  [_]\n]\n</code></pre> <p>Children can be elided. For example, this would produce multiple matches for a <code>MultiplicativeExpression</code> where at least one of the children is an expression of a <code>StringExpression</code> variant, where each match is associated with each of the <code>StringExpression</code> children:</p> <pre><code>[MultiplicativeExpression\n  [Expression\n    [StringExpression]\n  ]\n]\n</code></pre> <p>Trivia nodes (whitespace, comments, etc.) will be skipped over when running a query. Furthermore, trivia nodes cannot be explicitly (or implicitly with <code>_</code>) matched by queries.</p>"},{"location":"user-guide/06-query-language/01-query-syntax/#capturing","title":"Capturing","text":"<p>When matching patterns, you may want to process specific nodes within the pattern. Captures allow you to associate names with specific nodes in a pattern, so that you can later refer to those nodes by those names. Capture names are written before the nodes that they refer to, and start with an <code>@</code> character.</p> <p>For example, this pattern would match any struct definition and it would associate the name <code>struct_name</code> with the identifier:</p> <pre><code>[StructDefinition\n  @struct_name name: [Identifier]\n]\n</code></pre> <p>And this pattern would match all event definitions for a contract, associating the name <code>event_name</code> with the event name, <code>contract_name</code> with the containing contract name:</p> <pre><code>[ContractDefinition\n  @contract_name name: [Identifier]\n  members: [ContractMembers\n    [ContractMember\n      [EventDefinition\n        @event_name name: [Identifier]\n      ]\n    ]\n  ]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#quantification","title":"Quantification","text":"<p>You can surround a sequence of patterns in parenthesis (<code>()</code>), followed by a <code>?</code>, <code>*</code> or <code>+</code> operator. The <code>?</code> operator matches zero or one repetitions of a pattern, the <code>*</code> operator matches zero or more, and the <code>+</code> operator matches one or more.</p> <p>For example, this pattern would match a sequence of one or more import directives at the top of the file:</p> <pre><code>[SourceUnit\n  members: [\n    _\n    ([_ @import [ImportDirective]])+\n  ]\n]\n</code></pre> <p>This pattern would match a structure definition with one or more members, capturing their names:</p> <pre><code>[StructDefinition\n  @name name: [_]\n  members: [\n    _\n    ([_ @member [Identifier]])+\n  ]\n]\n</code></pre> <p>This pattern would match all function calls, capturing a string argument if one was present:</p> <pre><code>[FunctionCallExpression\n  arguments: [ArgumentsDeclaration\n    variant: [PositionalArgumentsDeclaration\n      arguments: [PositionalArguments\n        (@arg [Expression variant: [StringExpression]])?\n      ]\n    ]\n  ]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#alternation","title":"Alternation","text":"<p>An alternation is written as a sequence of patterns separated by <code>|</code> and surrounded by parentheses.</p> <p>For example, this pattern would match a call to either a variable or an object property. In the case of a variable, capture it as <code>@function</code>, and in the case of a property, capture it as <code>@method</code>:</p> <pre><code>[FunctionCallExpression\n  operand: [Expression\n    (\n        @function variant: [Identifier]\n      | @method variant: [MemberAccessExpression]\n    )\n  ]\n]\n</code></pre> <p>This pattern would match a set of possible keyword terminals, capturing them as <code>@keyword</code>:</p> <pre><code>@keyword (\n    [\"break\"]\n  | [\"delete\"]\n  | [\"else\"]\n  | [\"for\"]\n  | [\"function\"]\n  | [\"if\"]\n  | [\"return\"]\n  | [\"try\"]\n  | [\"while\"]\n)\n</code></pre>"},{"location":"user-guide/06-query-language/01-query-syntax/#adjacency","title":"Adjacency","text":"<p>By using the adjacency operator <code>.</code> you can constrain a pattern to only match the first or the last child nodes.</p> <p>For example, the following pattern would match only the first parameter declaration in a function definition:</p> <pre><code>[FunctionDefinition\n  [ParametersDeclaration\n    [Parameters\n      .\n      @first_param [Parameter]\n    ]\n  ]\n]\n</code></pre> <p>And conversely the following will match only the last parameter:</p> <pre><code>[FunctionDefinition\n  [ParametersDeclaration\n    [Parameters\n      @last_param [Parameter]\n      .\n    ]\n  ]\n]\n</code></pre> <p>If the adjacency operator is used in between two patterns it constrains matches on both patterns to occur consecutively, ie. without any other sibling node in between. For example, this pattern matches pairs of consecutive statements:</p> <pre><code>[Statements\n  @stmt1 [Statement]\n  .\n  @stmt2 [Statement]\n]\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/","title":"6.2. Executing Queries","text":"<p>Queries are executed starting from any cursor that you can create with the Parser and Cursor APIs. Usually you'll run a query from either the root of the parse result <code>parseOutput.createTreeCursor()</code> or from a cursor created with <code>cursor.spawn()</code> to restrict the search to a given sub-tree.</p>"},{"location":"user-guide/06-query-language/02-executing-queries/#creating-and-executing-queries","title":"Creating and executing queries","text":"<p>You can create a <code>Query</code> object using <code>Query.create()</code>, which accepts a string value. These can be then used by <code>cursor.query()</code> to execute it.</p> <p>You can pass multiple queries to a cursor to efficiently traverse the tree looking for matches. They will be executed simultaneously, returning matches in the order they appear in the input.</p> common.mts<pre><code>import assert from \"node:assert\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { Query, QueryMatchIterator } from \"@nomicfoundation/slang/cst\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\nexport function executeQueries(soliditySource: string, queries: Query[]): QueryMatchIterator {\n  const parser = Parser.create(LanguageFacts.latestVersion());\n\n  const parseOutput = parser.parseFileContents(soliditySource);\n  assert(parseOutput.isValid());\n\n  return parseOutput.createTreeCursor().query(queries);\n}\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#iterating-over-node-patterns","title":"Iterating over node patterns","text":"<p>Queries allow you to iterate over all node patterns that match the query, which can replace your need for manual iteration via cursors or visitors. Each match has a cursor that points to the node matched by the outermost pattern in the query. This is called the match root.</p> <p>Let's use this to list all the contract definitions in a source file:</p> match-roots.mts<pre><code>import assert from \"node:assert\";\nimport { executeQueries } from \"./common.mjs\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\n\ntest(\"match roots\", () =&gt; {\n  const matches = executeQueries(\n    `\n      contract Foo {}\n      contract Bar {}\n      contract Baz {}\n    `,\n    [\n      Query.create(`\n        [ContractDefinition]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    found.push(match.root.node.unparse().trim());\n  }\n\n  assert.deepStrictEqual(found, [\"contract Foo {}\", \"contract Bar {}\", \"contract Baz {}\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#capturing-nodes-by-name","title":"Capturing nodes by name","text":"<p>You can also capture specific nodes in the query by name, and get a cursor to each of them:</p> <p>Let's use this to list all the contract names:</p> match-captures.mts<pre><code>import assert from \"node:assert\";\nimport { executeQueries } from \"./common.mjs\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\n\ntest(\"match captures\", () =&gt; {\n  const matches = executeQueries(\n    `\n      contract Foo {}\n      contract Bar {}\n      contract Baz {}\n    `,\n    [\n      Query.create(`\n        [ContractDefinition\n          @name name: [Identifier]\n        ]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    const names = match.captures[\"name\"];\n    assert.strictEqual(names.length, 1);\n\n    found.push(names[0].node.unparse());\n  }\n\n  assert.deepStrictEqual(found, [\"Foo\", \"Bar\", \"Baz\"]);\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#detecting-query-errors","title":"Detecting Query errors","text":"<p>If there is a mistake in your query, for example, if you use an invalid node kind, you will get a <code>QueryError</code> exception. The error will contain a message to indicate what went wrong, and the text range in the query where the error occurred.</p> query-errors.mts<pre><code>import assert from \"node:assert\";\nimport { Query, QueryError } from \"@nomicfoundation/slang/cst\";\n\ntest(\"query errors\", () =&gt; {\n  try {\n    Query.create(`\n      [NonExistingNode]\n    `);\n  } catch (error) {\n    const queryError = error as QueryError;\n\n    assert.strictEqual(\n      queryError.message.trim(),\n      `Parse error:\\n'NonExistingNode' is not a valid node kind at: NonExistingNode]`,\n    );\n\n    assert.deepStrictEqual(queryError.textRange, {\n      start: { line: 1, column: 7, utf8: 8, utf16: 8 },\n      end: { line: 2, column: 4, utf8: 29, utf16: 29 },\n    });\n  }\n});\n</code></pre>"},{"location":"user-guide/06-query-language/02-executing-queries/#multiple-queries-simultaneously","title":"Multiple queries simultaneously","text":"<p>We can also execute multiple queries simultaneously, which will return all the matches as they are found in the tree. This can be useful when you want to match multiple types of nodes in a single pass. Results will be reported in order, and each will have an index that can be used to identify which query is matched.</p> multiple-queries.mts<pre><code>import assert from \"node:assert\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\nimport { executeQueries } from \"./common.mjs\";\n\ntest(\"multiple queries\", () =&gt; {\n  const matches = executeQueries(\n    `\n      struct Foo { uint a; }\n      enum Bar { A, B }\n      struct Baz { uint b; uint c; }\n      enum Qux { C, D }\n    `,\n    [\n      Query.create(`\n        [StructDefinition\n          @name [Identifier]\n        ]\n      `),\n      Query.create(`\n        [EnumDefinition\n          @name [Identifier]\n        ]\n      `),\n    ],\n  );\n\n  const found = [];\n\n  for (const match of matches) {\n    const names = match.captures[\"name\"];\n    assert.strictEqual(names.length, 1);\n\n    found.push({\n      queryIndex: match.queryIndex,\n      name: names[0].node.unparse(),\n    });\n  }\n\n  assert.deepStrictEqual(found, [\n    { queryIndex: 0, name: \"Foo\" },\n    { queryIndex: 1, name: \"Bar\" },\n    { queryIndex: 0, name: \"Baz\" },\n    { queryIndex: 1, name: \"Qux\" },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/","title":"7. Semantic Analysis","text":"<ul> <li>7.1. Compilation Units</li> <li>7.2. Binding Graph</li> <li>7.3. Solidity Builtins</li> </ul>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/","title":"7.1. Compilation Units","text":"<p>In order for Slang to perform semantic analysis on a program, it first needs to compile a list of all source files into a single <code>CompilationUnit</code>.</p> <p>We offer a <code>CompilationBuilder</code> API that allows you easily do that. It will parse the provided source files, analyze the import statements within, and then transitively resolve all dependencies, until all source files have been loaded.</p> <p>It is important to note that Slang is designed to be modular, and work in any environment (CLI, browser, etc..). This means it cannot access the file system directly, or make any assumptions about where your contracts are, and where their dependencies are installed.</p> <p>Instead, it expects the user to provide it with a couple of callbacks to handle these tasks:</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#reading-files","title":"Reading Files","text":"<p>The first callback is a function that will read the contents of a source file. That typically means using an API like NodeJS's <code>fs.readFile()</code> for local files, or browser's <code>fetch()</code> for remote ones.</p> <p>Note that this API is also error-tolerant. If the file is not found, or cannot be read, your callback can simply return <code>undefined</code> to indicate that the file is not available.</p> <p>For simplicity, let's assume that we have the source files defined in code:</p> read-file.mts<pre><code>const VIRTUAL_FS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\n      import { Log } from \"events.sol\";\n\n      contract MyContract {\n        function test() public {\n          emit Log(msg.sender, \"Hello World!\");\n        }\n      }\n    `,\n  ],\n  [\n    \"events.sol\",\n    `\n      event Log(address indexed sender, string message);\n    `,\n  ],\n]);\n\nexport async function readFile(fileId: string) {\n  return VIRTUAL_FS.get(fileId);\n}\n</code></pre> <p>The exact semantics of the <code>fileId</code> used throughout the Compilation API will depend on your implementation of the <code>readFile</code> callback. They could be paths, URLs, or opaque IDs.</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#resolving-imports","title":"Resolving Imports","text":"<p>The second callback is a function that will resolve an import statement to the imported source file. In a real-world scenario, dependencies can be imported from relative paths on disk, a remote provider like IPFS, or even NPM packages.</p> <p>For example, a package manager like <code>npm</code> would install the dependencies into sub-directory of <code>node_modules</code>, and users can then resolve their locations via NodeJS <code>path.resolve()</code> or browsers <code>import.meta.resolve()</code> APIs.</p> <p>Note that likewise, this API is also error-tolerant. If the import cannot be resolved, your callback can also return <code>undefined</code> to indicate that the import is not available, and the builder will skip it.</p> <p>For simplicity, let's just assume that dependencies will always be imported by their bare file name:</p> resolve-import.mts<pre><code>import { Cursor } from \"@nomicfoundation/slang/cst\";\n\nexport async function resolveImport(_sourceFileId: string, importPath: Cursor) {\n  // cursor points to the import string literal:\n  const importLiteral = importPath.node.unparse();\n\n  // remove surrounding quotes:\n  const importString = importLiteral.replace(/^[\"']/, \"\").replace(/[\"']$/, \"\");\n\n  return importString;\n}\n</code></pre> <p>The import resolution callback should return a <code>fileId</code>, and should be meaningful to the <code>readFile</code> callback. We use filenames here, but URLs or opaque unique IDs would work as well.</p>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#running-the-compilation-builder","title":"Running the compilation builder","text":"<p>With these callbacks defined, we can now create a <code>CompilationBuilder</code> and add our source files to it. Note that in the example below, we don't need to add dependencies, as they will be resolved and loaded automatically.</p> compilation-builder.mts<pre><code>import { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\nimport { readFile } from \"./read-file.mjs\";\nimport { resolveImport } from \"./resolve-import.mjs\";\n\nexport async function buildCompilationUnit(): Promise&lt;CompilationUnit&gt; {\n  const builder = CompilationBuilder.create({\n    languageVersion: LanguageFacts.latestVersion(),\n    readFile,\n    resolveImport,\n  });\n\n  await builder.addFile(\"contract.sol\");\n\n  return builder.build();\n}\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/01-compilation-units/#inspecting-the-compilation-unit","title":"Inspecting the compilation unit","text":"<p>The built <code>CompilationUnit</code> will then contain all the source files, along with their syntax trees.</p> compilation-unit.mts<pre><code>import assert from \"node:assert\";\nimport { assertNonterminalNode, NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\n\ntest(\"compilation unit\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n\n  const files = unit.files();\n  assert.equal(files.length, 2);\n\n  assert.equal(files[0].id, \"contract.sol\");\n  assertNonterminalNode(files[0].tree, NonterminalKind.SourceUnit);\n\n  assert.equal(files[1].id, \"events.sol\");\n  assertNonterminalNode(files[1].tree, NonterminalKind.SourceUnit);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/","title":"7.2. Binding Graph","text":"<p>The binding graph is a graph structure that represents the relationships between identifiers across source files in a <code>CompilationUnit</code>. It stores cursors to all definitions and references, and can resolve the edges between them.</p> <p>Building this graph can be an expensive operation. So, it is constructed lazily on the first access, and cached thereafter. You can use cursors to query the graph for definitions or references.</p> <p>Any identifier in the tree can be resolved to a definition or a reference. Note that there are multiple kinds of identifiers. For example, Solidity has <code>Identifier</code>, and Yul has <code>YulIdentifier</code>. To find/filter terminals that are identifiers, you can use the <code>TerminalKindExtensions.isIdentifier()</code> API to test for that.</p>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#resolving-definitions","title":"Resolving Definitions","text":"<p>To resolve definitions we need to provide the binding graph with a cursor pointing to the identifier. Some identifiers in the code may not be acting as definitions. In those cases, <code>definitionAt()</code> will return <code>undefined</code>.</p> <p><code>Definition</code> objects will contain two binding locations:</p> <ul> <li><code>nameLocation</code> referring to the identifier that resolved to the definition</li> <li><code>definiensLocation</code> referring to the CST node that is being defined (a contract, function, struct, etc)</li> </ul> <p>Because binding graphs span multiple files, these locations are not simple <code>Cursor</code> objects. Instead they are <code>BindingLocation</code> objects, which can refer to locations in user files or built-ins:</p> <ul> <li><code>UserFileLocation</code> in turn contains the <code>fileId</code> and the <code>cursor</code> in the CST tree of the file.</li> <li><code>BuiltInLocation</code> refers to a location in system defined built-in. You may get a definition on such a location when finding which definitions a <code>Reference</code> binds to (see section below), but never when resolving to a definition from a cursor.</li> </ul> find-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation, Definition } from \"@nomicfoundation/slang/bindings\";\n\nexport function findDefinitionsInFile(unit: CompilationUnit, fileId: string): Definition[] {\n  const file = unit.file(fileId);\n  assert(file);\n\n  const definitions = [];\n\n  // traverse the file's CST tree looking for identifiers\n  const cursor = file.createTreeCursor();\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n      continue;\n    }\n\n    // attempt to resolve a definition\n    const definition = unit.bindingGraph.definitionAt(cursor);\n\n    if (definition) {\n      // name should be located in the file we queried\n      assertUserFileLocation(definition.nameLocation);\n      assert.strictEqual(definition.nameLocation.fileId, fileId);\n\n      // definiens should too be located in the file we queried\n      assertUserFileLocation(definition.definiensLocation);\n      assert.strictEqual(definition.definiensLocation.fileId, fileId);\n\n      definitions.push(definition);\n    }\n  }\n\n  return definitions;\n}\n</code></pre> <p>User file binding locations will also contain a <code>cursor</code> to the underlying identifier or CST node of the entity defined. Using the same contract from last section, we can look for definitions in the <code>contract.sol</code> file:</p> resolving-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findDefinitionsInFile } from \"./find-definitions.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"find definitions in file\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const definitions = findDefinitionsInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const definition of definitions) {\n    assertUserFileLocation(definition.nameLocation);\n    const name = definition.nameLocation.cursor.node.unparse();\n\n    assertUserFileLocation(definition.definiensLocation);\n    const kind = definition.definiensLocation.cursor.node.kind;\n\n    found.push({ name, kind });\n  }\n\n  assert.strictEqual(found.length, 3);\n  assert.deepEqual(found, [\n    { name: \"Log\", kind: NonterminalKind.ImportDeconstructionSymbol },\n    { name: \"MyContract\", kind: NonterminalKind.ContractDefinition },\n    { name: \"test\", kind: NonterminalKind.FunctionDefinition },\n  ]);\n});\n</code></pre> <p>We find 3 definitions:</p> <ul> <li>The <code>Log</code> imported symbol.</li> <li>The <code>MyContract</code> contract.</li> <li>The <code>test</code> method.</li> </ul> <p>The <code>Log</code> import symbol is a special case and also acts as a reference to the actual event type defined in <code>events.sol</code>. Let's find all references in the file next.</p>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#resolving-references","title":"Resolving References","text":"<p>In the same way to resolving definitions, we can also attempt to resolve a cursor to an identifier to a reference. If the resolution is successful, the returned <code>Reference</code> will have a <code>location</code> pointing to the identifier. As before, we can expect this location to be in the user file whose CST tree we are querying.</p> find-references.mts<pre><code>import assert from \"node:assert\";\nimport { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation, Reference } from \"@nomicfoundation/slang/bindings\";\n\nexport function findReferencesInFile(unit: CompilationUnit, fileId: string): Reference[] {\n  const file = unit.file(fileId);\n  assert(file);\n\n  const references = [];\n\n  // traverse the file's CST tree looking for identifiers\n  const cursor = file.createTreeCursor();\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n      continue;\n    }\n\n    // attempt to resolve a reference\n    const reference = unit.bindingGraph.referenceAt(cursor);\n\n    if (reference) {\n      // should be located in the file we queried\n      assertUserFileLocation(reference.location);\n      assert.strictEqual(reference.location.fileId, fileId);\n\n      references.push(reference);\n    }\n  }\n\n  return references;\n}\n</code></pre> <p>We can now find all the references in the same <code>contract.sol</code> file:</p> resolving-references.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findReferencesInFile } from \"./find-references.mjs\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"find references in file\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const references = findReferencesInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    const name = reference.location.cursor.node.unparse();\n    const line = reference.location.cursor.textRange.start.line;\n\n    found.push({ name, line });\n  }\n\n  assert.strictEqual(found.length, 4);\n  assert.deepEqual(found, [\n    { name: \"Log\", line: 1 },\n    { name: \"Log\", line: 5 },\n    { name: \"msg\", line: 5 },\n    { name: \"sender\", line: 5 },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/02-binding-graph/#navigating-between-definitions-and-references","title":"Navigating between definitions and references","text":"<p>Iterating over the references found in the last section, we can find where are the definitions they refer to by using the <code>definitions()</code> method of <code>Reference</code>:</p> references-to-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findReferencesInFile } from \"./find-references.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"navigate from references to definitions\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const references = findReferencesInFile(unit, \"contract.sol\");\n\n  const found = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    const name = reference.location.cursor.node.unparse();\n    const line = reference.location.cursor.textRange.start.line;\n\n    // find definitions this reference binds to\n    const definitions = [];\n    for (const definition of reference.definitions()) {\n      if (definition.nameLocation.isUserFileLocation() &amp;&amp; definition.definiensLocation.isUserFileLocation()) {\n        // it's a user provided definition\n        definitions.push({\n          file: definition.nameLocation.fileId,\n          kind: definition.definiensLocation.cursor.node.kind,\n        });\n      } else {\n        // it's a built-in\n        definitions.push({ file: \"BUILT-IN\" });\n      }\n    }\n\n    found.push({ name, line, definitions });\n  }\n\n  assert.strictEqual(found.length, 4);\n  assert.deepEqual(found, [\n    { name: \"Log\", line: 1, definitions: [{ file: \"events.sol\", kind: NonterminalKind.EventDefinition }] },\n    {\n      name: \"Log\",\n      line: 5,\n      definitions: [\n        { file: \"contract.sol\", kind: NonterminalKind.ImportDeconstructionSymbol },\n        { file: \"events.sol\", kind: NonterminalKind.EventDefinition },\n      ],\n    },\n    { name: \"msg\", line: 5, definitions: [{ file: \"BUILT-IN\" }] },\n    { name: \"sender\", line: 5, definitions: [{ file: \"BUILT-IN\" }] },\n  ]);\n});\n</code></pre> <p>There are two interesting observations here:</p> <ul> <li>Slang recognizes the Solidity built-in global variable <code>msg</code> and its member <code>sender</code>. See next section for more details and an example use case.</li> <li>There may be multiple definitions bound to our reference: the <code>Log</code> identifier in the <code>emit</code> statement refers to the imported symbol, and also to the event type which is declared in a different file.</li> </ul> <p>There are other cases where Slang may return multiple definitions for a reference. Function overloads and virtual method calls are typical examples.</p> <p>Starting from a definition, we can also query the binding graph for all places where it's being referred to with the method <code>references()</code> of <code>Definition</code> objects. In this example, we navigate from the <code>Log</code> event definition in <code>events.sol</code> back to the two references in <code>contract.sol</code>:</p> definitions-to-references.mts<pre><code>import assert from \"node:assert\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { findDefinitionsInFile } from \"./find-definitions.mjs\";\nimport { NonterminalKind } from \"@nomicfoundation/slang/cst\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\n\ntest(\"navigate from definitions to references\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n  const definitions = findDefinitionsInFile(unit, \"events.sol\");\n\n  // there are three definitions in the file: the event and its two parameters\n  assert.strictEqual(definitions.length, 3);\n\n  // we only care about the event type definition for this example\n  const logEvent = definitions[0];\n  assertUserFileLocation(logEvent.definiensLocation);\n  assert.strictEqual(logEvent.definiensLocation.cursor.node.kind, NonterminalKind.EventDefinition);\n\n  // find references bound to its definition\n  const references = logEvent.references();\n  assert.strictEqual(references.length, 2);\n\n  // first should be the import statement\n  assertUserFileLocation(references[0].location);\n  assert.strictEqual(references[0].location.fileId, \"contract.sol\");\n  assert.strictEqual(references[0].location.cursor.textRange.start.line, 1);\n\n  // second should be the emit statement\n  assertUserFileLocation(references[1].location);\n  assert.strictEqual(references[1].location.fileId, \"contract.sol\");\n  assert.strictEqual(references[1].location.cursor.textRange.start.line, 5);\n});\n</code></pre>"},{"location":"user-guide/07-semantic-analysis/03-solidity-builtins/","title":"7.3. Solidity Builtins","text":"<p>When resolving references, Slang can differentiate between user provided definitions and Solidity built-ins. This makes it possible to perform deeper semantic analysis which is not possible with only the results of parsing.</p> <p>For example, we can easily detect incorrect usages of the deprecated <code>tx.origin</code> (as recommended here) but distinguish it from valid user code that syntactically looks exactly the same:</p> solidity-builtins.mts<pre><code>import assert from \"node:assert\";\nimport { Cursor, NonterminalKind, Query } from \"@nomicfoundation/slang/cst\";\nimport { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\ntest(\"solidity builtins\", async () =&gt; {\n  const unit = await buildCompilationUnit();\n\n  const query = Query.create(`\n    [MemberAccessExpression\n      [Expression @start [\"tx\"]]\n      [\"origin\"]\n    ]\n  `);\n\n  const cursor = unit.file(\"contract.sol\")!.createTreeCursor();\n  const matches = cursor.query([query]);\n  for (const match of matches) {\n    const txIdentifier = match.captures[\"start\"][0];\n    const reference = unit.bindingGraph.referenceAt(txIdentifier)!;\n    const definitions = reference.definitions();\n\n    if (definitions[0].nameLocation.isBuiltInLocation()) {\n      // incorrect use of `tx.origin` detected!\n      assert.strictEqual(txIdentifier.textRange.start.line, 13);\n    } else {\n      // this is ok: the `tx` builtin is shadowed by a parameter\n      const definitionLocation = definitions[0].definiensLocation.asUserFileLocation()!;\n      assert.strictEqual(definitionLocation.fileId, \"contract.sol\");\n      assert.strictEqual(definitionLocation.cursor.node.kind, NonterminalKind.Parameter);\n    }\n  }\n});\n\nasync function buildCompilationUnit(): Promise&lt;CompilationUnit&gt; {\n  // we don't need to resolve imports for this example\n  const resolveImport = async (_sourceId: string, _importPath: Cursor) =&gt; undefined;\n  const readFile = async (fileId: string) =&gt; {\n    assert(fileId == \"contract.sol\");\n    return `\n// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract TxUserWallet {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferTo(address payable dest, uint amount) public {\n        // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n\n    struct UserTx {\n        address origin;\n    }\n\n    function checkOwner(UserTx memory tx) public pure returns (bool) {\n        // This use of tx.origin is fine\n        return tx.origin == owner;\n    }\n}\n    `;\n  };\n\n  const builder = CompilationBuilder.create({\n    languageVersion: LanguageFacts.latestVersion(),\n    readFile,\n    resolveImport,\n  });\n\n  await builder.addFile(\"contract.sol\");\n\n  return builder.build();\n}\n</code></pre>"},{"location":"user-guide/08-examples/","title":"8. Examples","text":"<ul> <li>8.1. List functions in a contract</li> <li>8.2. Find usages</li> <li>8.3. Jump to definition</li> <li>8.4. Find unused definitions</li> <li>8.5. Remove unused definitions</li> <li>8.6. Inject logging</li> </ul> <p>We need some setup code to create a <code>CompilationUnit</code> with the contents of one or more Solidity files. This will be common to all examples above:</p> compilation-builder.mts<pre><code>import { Cursor } from \"@nomicfoundation/slang/cst\";\nimport { CompilationBuilder, CompilationUnit } from \"@nomicfoundation/slang/compilation\";\n\nfunction buildReadFile(virtualFs: Map&lt;string, string&gt;): (fileId: string) =&gt; Promise&lt;string&gt; {\n  return async (fileId: string) =&gt; {\n    const contents = virtualFs.get(fileId);\n    if (!contents) {\n      throw new Error(`${fileId} not found`);\n    }\n    return contents;\n  };\n}\n\nasync function resolveImport(_sourceFileId: string, importPath: Cursor) {\n  const importLiteral = importPath.node.unparse();\n  const importString = importLiteral.replace(/^[\"']/, \"\").replace(/[\"']$/, \"\");\n  return importString;\n}\n\nexport async function buildCompilationUnit(\n  virtualFs: Map&lt;string, string&gt;,\n  version: string,\n  mainFileId: string,\n): Promise&lt;CompilationUnit&gt; {\n  const builder = CompilationBuilder.create({\n    languageVersion: version,\n    readFile: buildReadFile(virtualFs),\n    resolveImport,\n  });\n\n  await builder.addFile(mainFileId);\n\n  return builder.build();\n}\n</code></pre> <p>Unless specified otherwise, throughout the examples in this section we will use this simple contract for demonstration:</p> sample-contract.mts<pre><code>import { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { buildCompilationUnit } from \"./compilation-builder.mjs\";\n\nconst CONTRACT_VFS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\ncontract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n    `,\n  ],\n]);\n\nexport default function (): Promise&lt;CompilationUnit&gt; {\n  return buildCompilationUnit(CONTRACT_VFS, \"0.8.0\", \"contract.sol\");\n}\n</code></pre> <p>We also need an easy way to obtain a <code>Cursor</code> pointing to a terminal node in a specific line and column in a file for a couple of examples. This can be achieved using the Cursor Navigation API:</p> find-terminal-node-at.mts<pre><code>import assert from \"node:assert\";\nimport { Cursor } from \"@nomicfoundation/slang/cst\";\n\nexport function findTerminalNodeAt(cursor: Cursor, line: number, column: number): Cursor | undefined {\n  const range = cursor.textRange;\n  if (\n    line &lt; range.start.line ||\n    (line == range.start.line &amp;&amp; column &lt; range.start.column) ||\n    line &gt; range.end.line ||\n    (line == range.end.line &amp;&amp; column &gt; range.end.column)\n  ) {\n    // initial cursor is outside of the range of the CST tree\n    return undefined;\n  }\n\n  outer: while (cursor.node.isNonterminalNode()) {\n    assert(cursor.goToFirstChild());\n    do {\n      const childRange = cursor.textRange;\n      if (line &lt; childRange.end.line || (line == childRange.end.line &amp;&amp; column &lt;= childRange.end.column)) {\n        continue outer;\n      }\n    } while (cursor.goToNextSibling());\n\n    // we should have found a child to recurse into (or the target terminal node)\n    throw new Error(\"should not be reached\");\n  }\n  assert(cursor.node.isTerminalNode());\n  return cursor;\n}\n</code></pre>"},{"location":"user-guide/08-examples/01-list-functions-in-contract/","title":"8.1. List functions in a contract","text":"<p>This function finds a contract in the compilation unit with the given name and returns a list of <code>FunctionDefinition</code> within it. We use a combination of the Query API and the AST types:</p> list-functions-in-contract.mts<pre><code>import { assertNonterminalNode, Query } from \"@nomicfoundation/slang/cst\";\nimport { ContractDefinition, FunctionDefinition } from \"@nomicfoundation/slang/ast\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\n\nexport function listFunctionsInContract(unit: CompilationUnit, contractName: string): FunctionDefinition[] {\n  for (const file of unit.files()) {\n    const cursor = file.createTreeCursor();\n    const query = Query.create(`\n      [ContractDefinition\n        @name name: [Identifier]\n      ]\n    `);\n    const matches = cursor.query([query]);\n\n    for (const match of matches) {\n      const contractNode = match.root.node;\n      assertNonterminalNode(contractNode);\n      const name = match.captures[\"name\"][0].node.unparse();\n      if (name == contractName) {\n        // found the contract\n        const contract = new ContractDefinition(contractNode);\n        const functions = contract.members.items\n          .map((member) =&gt; member.variant)\n          .filter((member) =&gt; member instanceof FunctionDefinition);\n        return functions;\n      }\n    }\n  }\n\n  throw new Error(`Could not find contract named ${contractName}`);\n}\n</code></pre> <p>From the list of <code>FunctionDefinition</code> nodes, it's easy to obtain the names of the functions:</p> test-list-functions.mts<pre><code>import assert from \"node:assert\";\nimport { listFunctionsInContract } from \"./list-functions-in-contract.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"list functions by contract name\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  const functions = listFunctionsInContract(unit, \"Counter\");\n  const functionNames = functions.map((fun) =&gt; fun.name.cst.unparse().trim());\n  assert.deepEqual(functionNames, [\"count\", \"increment\"]);\n});\n</code></pre>"},{"location":"user-guide/08-examples/02-find-usages/","title":"8.2. Find usages","text":"<p>A typical use case for an IDE is finding where some variable, function, or type is used in the code base. In Slang this can be easily accomplished by using the Binding Graph API:</p> find-usages.mts<pre><code>import { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\nimport { findTerminalNodeAt } from \"../../common/find-terminal-node-at.mjs\";\n\ntype Usage = {\n  file: string;\n  line: number;\n  column: number;\n};\n\nexport function findUsages(unit: CompilationUnit, fileId: string, line: number, column: number): Usage[] {\n  const file = unit.file(fileId);\n  if (!file) {\n    throw new Error(`${fileId} not found in compilation unit`);\n  }\n\n  const cursor = findTerminalNodeAt(file.createTreeCursor(), line, column);\n  if (!cursor) {\n    throw new Error(`${fileId}:${line}:${column} is not a valid text location`);\n  }\n\n  assertTerminalNode(cursor.node);\n  if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n    // location is not a valid identifier\n    throw new Error(`Could not find a valid identifier at ${fileId}:${line}:${column}`);\n  }\n\n  const definition = unit.bindingGraph.definitionAt(cursor);\n  if (!definition) {\n    throw new Error(`Identifier ${cursor.node.unparse()} is not a definition at ${fileId}:${line}:${column}`);\n  }\n\n  const references = definition.references();\n  const usages = [];\n  for (const reference of references) {\n    assertUserFileLocation(reference.location);\n    usages.push({\n      file: reference.location.fileId,\n      line: reference.location.cursor.textOffset.line,\n      column: reference.location.cursor.textOffset.column,\n    });\n  }\n  return usages;\n}\n</code></pre> <p>For example, we can look for usages of the <code>_count</code> state variable defined in line 2 of the sample contract:</p> <pre><code>contract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n</code></pre> test-find-usages.mts<pre><code>import assert from \"node:assert\";\nimport { findUsages } from \"./find-usages.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"find usages\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  // the _count state variable definition\n  const usages = findUsages(unit, \"contract.sol\", 2, 10);\n\n  assert.deepEqual(usages, [\n    { file: \"contract.sol\", line: 4, column: 4 },\n    { file: \"contract.sol\", line: 7, column: 11 },\n    { file: \"contract.sol\", line: 11, column: 4 },\n    { file: \"contract.sol\", line: 12, column: 11 },\n  ]);\n});\n</code></pre>"},{"location":"user-guide/08-examples/03-jump-to-definition/","title":"8.3. Jump to definition","text":"<p>Another often used feature of an IDE is the ability to jump to the definition of a given identifier. Again, we can use the Binding Graph API to do it:</p> jump-to-definition.mts<pre><code>import { assertTerminalNode, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { findTerminalNodeAt } from \"../../common/find-terminal-node-at.mjs\";\n\ntype Target = {\n  file: string;\n  line: number;\n  column: number;\n};\n\nexport function jumpToDefinition(unit: CompilationUnit, fileId: string, line: number, column: number): Target {\n  const file = unit.file(fileId);\n  if (!file) {\n    throw new Error(`${fileId} not found in compilation unit`);\n  }\n\n  const cursor = findTerminalNodeAt(file.createTreeCursor(), line, column);\n  if (!cursor) {\n    throw new Error(`${fileId}:${line}:${column} is not a valid text location`);\n  }\n\n  assertTerminalNode(cursor.node);\n  if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) {\n    // location is not a valid identifier\n    throw new Error(`Could not find a valid identifier at ${fileId}:${line}:${column}`);\n  }\n\n  const reference = unit.bindingGraph.referenceAt(cursor);\n  if (!reference) {\n    throw new Error(`Identifier ${cursor.node.unparse()} is not a reference at ${fileId}:${line}:${column}`);\n  }\n\n  const definitions = reference.definitions();\n  if (definitions.length == 0) {\n    throw new Error(`${cursor.node.unparse()} is not defined`);\n  }\n\n  // we take the first definition arbitrarily\n  const location = definitions[0].nameLocation;\n  if (!location.isUserFileLocation()) {\n    throw new Error(`${cursor.node.unparse()} is a built-in`);\n  }\n\n  return {\n    file: location.fileId,\n    line: location.cursor.textOffset.line,\n    column: location.cursor.textOffset.column,\n  };\n}\n</code></pre> <p>The following example shows jumping to the definition of the parameter <code>delta</code> in line 11:</p> <pre><code>contract Counter {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta) public returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n</code></pre> test-jump-to-definition.mts<pre><code>import assert from \"node:assert\";\nimport { jumpToDefinition } from \"./jump-to-definition.mjs\";\nimport buildSampleCompilationUnit from \"../../common/sample-contract.mjs\";\n\ntest(\"jump to definition\", async () =&gt; {\n  const unit = await buildSampleCompilationUnit();\n\n  // the reference to `delta` in the assignment addition\n  const definition = jumpToDefinition(unit, \"contract.sol\", 11, 16);\n\n  assert.deepEqual(definition, { file: \"contract.sol\", line: 9, column: 26 });\n});\n</code></pre>"},{"location":"user-guide/08-examples/04-find-unused-definitions/","title":"8.4. Find unused definitions","text":"<p>Let's now explore a more complex example. We want to find all definitions in a compilation unit that are not referenced from a main contract. The general idea of the algorithm to implement is as follows: starting from the given contract, mark all constructors and public functions, as well as any inherited contracts or implemented interfaces. After that, recursively process (visit) each marked definition following references we find inside them.</p> <p>As a result, we'll get a list of definitions that are reachable from our main contract. We get the unused definitions by subtracting this set from all the definitions available in the compilation unit. An important thing to note is that this will include nested definitions. For example, variables and parameters in an unused function, or fields in an unused struct. To clean this up, we make a final pass to remove definitions nested inside other unused definitions.</p> <p>Disclaimer: This is only an example and to keep it relatively short, we won't cover all possible corner cases. The resulting algorithm may produce both false positives and false negatives.</p> find-unused-definitions.mts<pre><code>import { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { assertUserFileLocation, Definition } from \"@nomicfoundation/slang/bindings\";\nimport { findContractByName } from \"./find-contract-by-name.mjs\";\nimport { collectDefinitions, collectAllDefinitions } from \"./collect-definitions.mjs\";\nimport { visitDefinition } from \"./visit-definition.mjs\";\n\nexport function findUnusedDefinitions(unit: CompilationUnit, startingContractName: string): Definition[] {\n  const allDefinitions = collectAllDefinitions(unit);\n  const unusedDefinitions = new Map(allDefinitions.map((definition) =&gt; [definition.id, definition]));\n\n  const visitQueue = [findContractByName(unit, startingContractName)];\n  while (visitQueue.length &gt; 0) {\n    const toVisit = visitQueue.shift()!;\n    if (!unusedDefinitions.has(toVisit.id)) continue;\n    unusedDefinitions.delete(toVisit.id);\n\n    const definiensLocation = toVisit.definiensLocation;\n    assertUserFileLocation(definiensLocation);\n\n    const followed = visitDefinition(unit, definiensLocation.cursor.spawn());\n    visitQueue.push(...followed);\n  }\n\n  // for remaining unused definitions, remove any nested definitions inside them\n  // to prevent reporting eg. a function and all its parameters\n  visitQueue.push(...unusedDefinitions.values());\n  while (visitQueue.length &gt; 0) {\n    const toVisit = visitQueue.shift()!;\n    if (!unusedDefinitions.has(toVisit.id)) continue;\n\n    const definiensLocation = toVisit.definiensLocation;\n    assertUserFileLocation(definiensLocation);\n\n    const innerDefinitions = collectDefinitions(unit, definiensLocation.cursor);\n    for (const inner of innerDefinitions) {\n      if (inner.id == toVisit.id) continue;\n      unusedDefinitions.delete(inner.id);\n    }\n  }\n\n  return Array.from(unusedDefinitions.values());\n}\n</code></pre> <p>To implement the above we use several auxiliary functions. First and foremost, we need a way to collect definitions, both in the whole compilation unit, as well as under a specific cursor. We can accomplish this using the Cursor API and the Binding Graph API:</p> collect-definitions.mts<pre><code>import { assertTerminalNode, Cursor, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { Definition } from \"@nomicfoundation/slang/bindings\";\n\nexport function collectAllDefinitions(unit: CompilationUnit): Definition[] {\n  const allDefinitions = [];\n  for (const file of unit.files()) {\n    const cursor = file.createTreeCursor();\n    allDefinitions.push(...collectDefinitions(unit, cursor));\n  }\n  return allDefinitions;\n}\n\nexport function collectDefinitions(unit: CompilationUnit, root: Cursor): Definition[] {\n  const cursor = root.spawn();\n  const definitions = [];\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) continue;\n\n    const definition = unit.bindingGraph.definitionAt(cursor);\n    if (!definition) continue;\n\n    definitions.push(definition);\n  }\n  return definitions;\n}\n</code></pre> <p>The other important piece of the puzzle is the <code>visitDefinition</code> function. This is where we decide what is reachable from a definition, and what we do here depends on the kind we're visiting, aka. the <code>kind</code> of the definiens node of the definition. For <code>FunctionDefinition</code> and <code>ModifierDefinition</code>, we want to follow all references enclosed in them to visit the definitions they bind to. For libraries, structs and enums, we want to do no further processing. Their fields and members should be explicitly referenced to be considered used.</p> <p>As we said earlier, for a <code>ContractDefinition</code>, public state variables and functions should be marked and queued for visiting later. Constructors and other special functions do not have an identifier that names them and therefore will not create definitions in the binding graph. So, we want to visit their declarations explicitly to find references in them. All this behavior is complex enough to warrant its own, separate function <code>visitContract</code>. We use queries to find the different components of the contract.</p> visit-definition.mts<pre><code>import assert from \"node:assert\";\nimport { assertNonterminalNode, Cursor, NonterminalKind, Query } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { Definition } from \"@nomicfoundation/slang/bindings\";\nimport { collectDefinitions } from \"./collect-definitions.mjs\";\nimport { followAllReferences } from \"./follow-all-references.mjs\";\n\nexport function visitDefinition(unit: CompilationUnit, definiens: Cursor): Definition[] {\n  assertNonterminalNode(definiens.node);\n  const kind = definiens.node.kind;\n\n  if (kind == NonterminalKind.ContractDefinition) {\n    // special case contracts; see below\n    return visitContract(unit, definiens);\n  } else if (\n    kind == NonterminalKind.LibraryDefinition ||\n    kind == NonterminalKind.StructDefinition ||\n    kind == NonterminalKind.EnumDefinition\n  ) {\n    // members must be explicitly referenced\n    return [];\n  } else if (kind == NonterminalKind.FunctionDefinition || kind == NonterminalKind.ModifierDefinition) {\n    // follow any references inside, but don't automatically reference any new\n    // definitions (eg. a parameter)\n    return followAllReferences(unit, definiens);\n  } else {\n    // anything else (events, errors, interfaces) should be considered fully\n    // referenced (including inner definitions) and we need to follow any\n    // references inside them\n    const otherDefinitions = collectDefinitions(unit, definiens);\n    return followAllReferences(unit, definiens).concat(otherDefinitions);\n  }\n}\n\nfunction visitContract(unit: CompilationUnit, cursor: Cursor): Definition[] {\n  // for a contract, we need to explicitly follow inheritance specifiers and constructors,\n  // and visit state variables and public functions\n  const visitedDefinitions = [];\n\n  const inheritance = Query.create(`\n    [InheritanceSpecifier]\n  `);\n  const unnamedFunctions = Query.create(`\n    (\n      [ConstructorDefinition]\n    | [ReceiveFunctionDefinition]\n    | [FallbackFunctionDefinition]\n    | [UnnamedFunctionDefinition]\n    | [FunctionDefinition [FunctionName [FallbackKeyword]]]\n    | [FunctionDefinition [FunctionName [ReceiveKeyword]]]\n    )\n  `);\n  const publicFunctions = Query.create(`\n    [FunctionDefinition\n      name: [FunctionName @name [Identifier]]\n      attributes: [_ [FunctionAttribute [PublicKeyword]]]\n    ]\n  `);\n  const publicStateVars = Query.create(`\n    [StateVariableDefinition\n      attributes: [_ [StateVariableAttribute [PublicKeyword]]]\n      @name name: [Identifier]\n    ]\n  `);\n  const matches = cursor.query([inheritance, unnamedFunctions, publicFunctions, publicStateVars]);\n  for (const match of matches) {\n    switch (match.queryIndex) {\n      case 0:\n      case 1:\n        visitedDefinitions.push(...followAllReferences(unit, match.root));\n        break;\n      case 2:\n      case 3:\n        const innerDefinition = unit.bindingGraph.definitionAt(match.captures[\"name\"][0]);\n        assert(innerDefinition);\n        visitedDefinitions.push(innerDefinition);\n        break;\n    }\n  }\n  return visitedDefinitions;\n}\n</code></pre> <p>When analyzing functions bodies, expressions and blocks of statements, we need to follow all references to their bound definitions to mark them as used. This again is simple to implement with the Cursor and Binding Graph APIs:</p> follow-all-references.mts<pre><code>import { assertTerminalNode, Cursor, TerminalKindExtensions } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { Definition } from \"@nomicfoundation/slang/bindings\";\n\nexport function followAllReferences(unit: CompilationUnit, root: Cursor): Definition[] {\n  const referencedDefinitions = [];\n  const cursor = root.spawn();\n  while (cursor.goToNextTerminal()) {\n    assertTerminalNode(cursor.node);\n    if (!TerminalKindExtensions.isIdentifier(cursor.node.kind)) continue;\n\n    const reference = unit.bindingGraph.referenceAt(cursor);\n    if (!reference) continue;\n\n    for (const definition of reference.definitions()) {\n      if (definition.nameLocation.isBuiltInLocation()) continue;\n      referencedDefinitions.push(definition);\n    }\n  }\n\n  return referencedDefinitions;\n}\n</code></pre> <p>Lastly, we need a way to locate the initial contract. This is similar to what we implemented in the first example, but now we want to return a Binding Graph <code>Definition</code> object to kickstart our algorithm:</p> find-contract-by-name.mts<pre><code>import assert from \"node:assert\";\nimport { Query } from \"@nomicfoundation/slang/cst\";\nimport { CompilationUnit } from \"@nomicfoundation/slang/compilation\";\nimport { Definition } from \"@nomicfoundation/slang/bindings\";\n\nexport function findContractByName(unit: CompilationUnit, contractName: string): Definition {\n  for (const file of unit.files()) {\n    const cursor = file.createTreeCursor();\n    const query = Query.create(`\n      [ContractDefinition\n        @name name: [Identifier]\n      ]\n    `);\n    const matches = cursor.query([query]);\n\n    for (const match of matches) {\n      const nameCursor = match.captures[\"name\"][0];\n      const name = nameCursor.node.unparse();\n      if (name == contractName) {\n        const definition = unit.bindingGraph.definitionAt(nameCursor);\n        assert(definition);\n        return definition;\n      }\n    }\n  }\n\n  throw new Error(`Could not find contract named ${contractName}`);\n}\n</code></pre> <p>Finally, we can test the functionality on a slightly larger Solidity example:</p> test-find-unused-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { assertUserFileLocation } from \"@nomicfoundation/slang/bindings\";\nimport { findUnusedDefinitions } from \"./find-unused-definitions.mjs\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\n\nexport const CONTRACT_VFS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\nabstract contract Ownable {\n  address _owner;\n  constructor() {\n    _owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    require(_owner == msg.sender);\n    _;\n  }\n  function checkOwner(address addr) internal returns (bool) {\n    return _owner == addr;\n  }\n}\n\ncontract Counter is Ownable {\n  uint _count;\n  uint _unused;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta, uint multiplier) public onlyOwner returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n  function unusedDecrement() private {\n    require(checkOwner(msg.sender));\n    _count -= 1;\n  }\n}\n    `,\n  ],\n]);\n\ntest(\"find unused definitions\", async () =&gt; {\n  const unit = await buildCompilationUnit(CONTRACT_VFS, \"0.8.0\", \"contract.sol\");\n\n  const unused = findUnusedDefinitions(unit, \"Counter\");\n  const expected = unused.map((definition) =&gt; {\n    const location = definition.nameLocation;\n    assertUserFileLocation(location);\n    const name = location.cursor.node.unparse();\n    return [name, location.cursor.textOffset.line];\n  });\n  assert.deepEqual(expected, [\n    [\"checkOwner\", 10],\n    [\"_unused\", 17],\n    [\"multiplier\", 24],\n    [\"unusedDecrement\", 29],\n  ]);\n});\n</code></pre>"},{"location":"user-guide/08-examples/05-remove-unused-definitions/","title":"8.5. Remove unused definitions","text":"<p>In the previous section we've seen how to find unused definitions. Let's now proceed to remove them. For that, we are going to use <code>BaseRewriter</code>, an abstract class that allow us to replace nodes in a tree.</p> <p>The task, simply put, is to delete those nodes whose id is present in the list of unused definitions (constructed previously). For this example, we focus only in three definitions: functions, state variables, and modifiers. Expanding to other definitions is trivial.</p> <p>Our <code>RemoveUnusedDefs</code> class inherits from <code>BaseRewriter</code>, and overrides those methods of interest: <code>rewriteFunctionDefinition</code>, <code>rewriteStateVariableDefinition</code>, and <code>rewriteModifierDefinition</code>. In turn, each method forwards the execution to the helper function <code>removeUnused</code>, which is the one checking if the node id is present in the provided list of unused definitions.</p> <p>If the node corresponds to an unused definition, then the helper \u2014\u2014and therefore, the overwritten method\u2014\u2014 returns <code>undefined</code>. This is the way in which we signal the <code>BaseRewriter</code> class to remove the node.</p> <p>If the node is not in the list, it's returned as-is.</p> remove-unused-defs.mts<pre><code>import { Definition } from \"@nomicfoundation/slang/bindings\";\nimport { BaseRewriter, Node, NonterminalNode } from \"@nomicfoundation/slang/cst\";\n\nexport class RemoveUnusedDefs extends BaseRewriter {\n  constructor(private readonly unusedDefinitions: Definition[]) {\n    super();\n  }\n\n  private removeUnused(node: NonterminalNode): Node | undefined {\n    const foundUnused = this.unusedDefinitions.find((definition) =&gt; definition.id == node.id);\n    if (foundUnused) {\n      // returning `undefined` signals that the node must be deleted\n      return undefined;\n    } else {\n      return node;\n    }\n  }\n\n  public override rewriteFunctionDefinition(node: NonterminalNode): Node | undefined {\n    return this.removeUnused(node);\n  }\n\n  public override rewriteStateVariableDefinition(node: NonterminalNode): Node | undefined {\n    return this.removeUnused(node);\n  }\n\n  public override rewriteModifierDefinition(node: NonterminalNode): Node | undefined {\n    return this.removeUnused(node);\n  }\n}\n</code></pre> <p>We can test the functionality on the same Solidity example from last section, noting that functions <code>checkOwner</code> in <code>Ownable</code> and <code>unusedDecrement</code> in <code>Owner</code> are not present in the result, as well as the state variable <code>_unused</code> in the latter contract.</p> test-find-unused-definitions.mts<pre><code>import assert from \"node:assert\";\nimport { findUnusedDefinitions } from \"../../04-find-unused-definitions/examples/find-unused-definitions.mjs\";\nimport { CONTRACT_VFS } from \"../../04-find-unused-definitions/examples/test-find-unused-definitions.test.mjs\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { RemoveUnusedDefs } from \"./remove-unused-defs.mjs\";\n\nconst EXPECTED_VFS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\nabstract contract Ownable {\n  address _owner;\n  constructor() {\n    _owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    require(_owner == msg.sender);\n    _;\n  }\n}\n\ncontract Counter is Ownable {\n  uint _count;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    return _count;\n  }\n  function increment(uint delta, uint multiplier) public onlyOwner returns (uint) {\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n}\n    `,\n  ],\n]);\n\ntest(\"remove unused definitions\", async () =&gt; {\n  const unit = await buildCompilationUnit(CONTRACT_VFS, \"0.8.0\", \"contract.sol\");\n\n  const unused = findUnusedDefinitions(unit, \"Counter\");\n  const removeUnused = new RemoveUnusedDefs(unused);\n  for (const file of unit.files()) {\n    const newNode = removeUnused.rewriteNode(file.tree);\n    assert.strictEqual(newNode?.unparse(), EXPECTED_VFS.get(file.id));\n  }\n});\n</code></pre>"},{"location":"user-guide/08-examples/06-inject-logging/","title":"8.6. Inject logging","text":"<p>In this example, we use the <code>BaseRewriter</code> class to achieve something different: instead of removing nodes, we edit them to insert snippets of code. In particular, we insert in every function a call to a fictitious <code>log</code> function, using the name of the function to make it a bit more interesting.</p> <p>In essence, the <code>LoggingRewriter</code> class below works as follow:</p> <ol> <li>When traversing a function definition, we collect the name and store it in a local variable. Then, we proceed to recurse, using the <code>rewriteChildren</code> function of <code>BaseRewriter</code>. Before returning, the name is cleared off.</li> <li>When traversing the list of statements of a function, if the name of the function is set, we start by parsing the new statement to inject: the function call to the <code>log</code> function. Then, we construct the new statements of the function by prepending the injected code (note the <code>unshift</code>) into the children of the function statements.</li> <li>Since the <code>log</code> function should come from somewhere, we also import it, appending its <code>import</code> at the end of the source members of the file.</li> </ol> logging-rewriter.mts<pre><code>import { BaseRewriter, Edge, NonterminalKind, EdgeLabel, Node, NonterminalNode } from \"@nomicfoundation/slang/cst\";\nimport { Parser } from \"@nomicfoundation/slang/parser\";\nimport { LanguageFacts } from \"@nomicfoundation/slang/utils\";\n\nexport class LoggingRewriter extends BaseRewriter {\n  functionName: string | undefined;\n  injected = false;\n  parser: Parser;\n\n  constructor() {\n    super();\n    this.parser = Parser.create(LanguageFacts.latestVersion());\n  }\n\n  // collect the name of the function being traversed\n  public override rewriteFunctionDefinition(node: NonterminalNode): Node | undefined {\n    const name = node.children().find((edge) =&gt; edge.label == EdgeLabel.Name);\n    if (!name) {\n      return node;\n    }\n\n    this.functionName = name.node.unparse().trim();\n    // in the recursion is were the injection of code is actually performed\n    const recurse = this.rewriteChildren(node);\n    this.functionName = undefined;\n    return recurse;\n  }\n\n  // once in the statements of a function, inject a call to the `log` function.\n  public override rewriteStatements(node: NonterminalNode): Node | undefined {\n    if (this.functionName) {\n      this.injected = true;\n\n      // the injected code\n      const toInject = this.parser.parseNonterminal(\n        NonterminalKind.ExpressionStatement,\n        `    log(\"${this.functionName}\");\\n`,\n      ).tree;\n\n      // inject the node at the beginning of statements, and return the new node containing it\n      const children = node.children();\n      children.unshift(Edge.createWithNonterminal(EdgeLabel.Item, toInject));\n      return NonterminalNode.create(NonterminalKind.Statements, children);\n    }\n    return node;\n  }\n\n  // at the end of the file, inject the import of the `log` function.\n  public override rewriteSourceUnitMembers(node: NonterminalNode): Node | undefined {\n    const newNode = this.rewriteChildren(node);\n\n    if (!this.injected) {\n      // No function was found, return\n      return node;\n    }\n\n    const importMember = this.parser.parseNonterminal(\n      NonterminalKind.SourceUnitMember,\n      '\\nimport { log } from \"__logging.sol\";\\n',\n    ).tree;\n    const newChildren = newNode.children();\n    newChildren.push(Edge.createWithNonterminal(EdgeLabel.Item, importMember));\n    return NonterminalNode.create(NonterminalKind.SourceUnitMembers, newChildren);\n  }\n}\n</code></pre> <p>Again, we test the functionality on the ongoing Solidity example from Section 4. Note how the code was properly inserted in the relevant locations.</p> test-logging-rewriter.mts<pre><code>import assert from \"node:assert\";\nimport { CONTRACT_VFS } from \"../../04-find-unused-definitions/examples/test-find-unused-definitions.test.mjs\";\nimport { buildCompilationUnit } from \"../../common/compilation-builder.mjs\";\nimport { LoggingRewriter } from \"./logging-rewriter.mjs\";\n\nconst EXPECTED_VFS = new Map&lt;string, string&gt;([\n  [\n    \"contract.sol\",\n    `\nabstract contract Ownable {\n  address _owner;\n  constructor() {\n    _owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    require(_owner == msg.sender);\n    _;\n  }\n  function checkOwner(address addr) internal returns (bool) {\n    log(\"checkOwner\");\n    return _owner == addr;\n  }\n}\n\ncontract Counter is Ownable {\n  uint _count;\n  uint _unused;\n  constructor(uint initialCount) {\n    _count = initialCount;\n  }\n  function count() public view returns (uint) {\n    log(\"count\");\n    return _count;\n  }\n  function increment(uint delta, uint multiplier) public onlyOwner returns (uint) {\n    log(\"increment\");\n    require(delta &gt; 0, \"Delta must be positive\");\n    _count += delta;\n    return _count;\n  }\n  function unusedDecrement() private {\n    log(\"unusedDecrement\");\n    require(checkOwner(msg.sender));\n    _count -= 1;\n  }\n}\n\nimport { log } from \"__logging.sol\";\n    `,\n  ],\n]);\n\ntest(\"inject logging\", async () =&gt; {\n  const unit = await buildCompilationUnit(CONTRACT_VFS, \"0.8.0\", \"contract.sol\");\n\n  const loggingRewriter = new LoggingRewriter();\n  for (const file of unit.files()) {\n    const newNode = loggingRewriter.rewriteNode(file.tree);\n    assert.strictEqual(newNode?.unparse(), EXPECTED_VFS.get(file.id));\n  }\n});\n</code></pre>"},{"location":"user-guide/09-appendix/","title":"9. Appendix","text":"<ul> <li>9.1. Slang Versioning Policy</li> <li>9.2. Slang Memory Management</li> </ul>"},{"location":"user-guide/09-appendix/01-slang-versioning-policy/","title":"9.1. Slang Versioning Policy","text":"<p>Slang is not tied to a specific Solidity version, and can be used to analyze multiple Solidity versions with the same API. At the same time, Slang's own API needs to be consistent and stable as new versions of Solidity are released.</p> <p>The NPM package uses Semantic Versioning and CHANGELOG.md to communicate such changes in the form of <code>{MAJOR}.{MINOR}.{PATCH}</code> versions, to report breaking changes, new features, and bug fixes (respectively). But it is not really designed to report two (often orthogonal) kinds of changes: changes in Slang's APIs, and changes in the Solidity language itself.</p> <p>Therefore, it is important to define and follow a clear versioning policy for Slang, that will make this distinction clear. Each changelog entry will contain a link to the pull request that introduced the change. The pull request will contain a description of the change, its impact on our APIs, the Solidity language, and any potential impact on the users.</p>"},{"location":"user-guide/09-appendix/01-slang-versioning-policy/#major-version-updates","title":"Major Version Updates","text":"<p>These are <code>{MAJOR}.0.0</code> releases, and they are intended to represent breaking changes in Slang's APIs. For example, when an existing API is removed, or replaced with a different one, and will often require manual intervention from the user to update their code.</p> <p>These releases are only done when absolutely necessary, and are not expected to happen often. They are often accompanied by detailed announcements, explaining the motivation behind it.</p>"},{"location":"user-guide/09-appendix/01-slang-versioning-policy/#minor-version-updates","title":"Minor Version Updates","text":"<p>These are <code>X.{MINOR}.0</code> releases, and they are intended to represent one of two things:</p> <ol> <li>A new Slang API or feature that is backwards compatible with previous versions. While users should take note of it,    in case it is useful to them, the existing APIs should continue to work without any changes.</li> <li>Adoption of a new Solidity version, which can often impact the structure of the CST (adding or changing existing nodes),    or user-authored tree queries. This can possibly be a breaking change if users were using the specific node kinds    that were updated in the new version, so they should also take note of it, especially if they want to support    multiple (or latest) Solidity versions.</li> </ol> <p>Because of this, users might want to depend on the Slang version in their <code>package.json</code> using the <code>~</code> operator instead of <code>^</code>, which enforces compatibility with the minor version, but will allow for patch updates.</p> <p>Slang intends to always keep up with Solidity language updates, and promptly implement user feedback and feature requests. As such, these releases will happen semi-regularly, and we advise users to review the changelog when they happen.</p>"},{"location":"user-guide/09-appendix/01-slang-versioning-policy/#patch-version-updates","title":"Patch Version Updates","text":"<p>These are <code>X.X.{PATCH}</code> releases, and they are intended to represent bug fixes and minor improvements. While they can impact user code (if the older version had a bug, which is now fixed), they are not expected to break Slang APIs, and should be adopted as soon as possible, to make sure user code is always performing correctly.</p>"},{"location":"user-guide/09-appendix/02-slang-memory-management/","title":"9.2. Slang Memory Management","text":"<p>For typical uses of Slang, developers should not worry about memory usage. That said, this appendix may be useful if you're experiencing memory issues in your applications using Slang, or you're curious about the memory management when working with Slang objects.</p> <p>Slang's core is written in Rust, cross-compiled into Web Assembly, and then imported into JavaScript/TypeScript. Understanding how the Wasm-JavaScript link works is key to understanding the memory usage behavior of Slang objects.</p>"},{"location":"user-guide/09-appendix/02-slang-memory-management/#internal-vs-external-memory","title":"Internal vs external memory","text":"<p>JavaScript engines distinguish between the memory space that contains JavaScript objects, called internal memory or heap space, and the space used for Wasm components, called external memory. The Slang objects that you interact with reside in internal memory. However, a Slang object, such as a <code>Cursor</code>, holds a handle to a Wasm component that manages a corresponding resource in the Rust implementation. In the case of a <code>Cursor</code>, that resource contains among other things a reference to the entire parsing tree. Therefore, an instance of the <code>Cursor</code> class in JavaScript is lightweight in terms of internal memory as it only contains the handle number. But it is associated with a significant amount of external memory\u2014the actual cursor and its tree in Wasm-land.</p>"},{"location":"user-guide/09-appendix/02-slang-memory-management/#finalizers-and-cleanup-callbacks","title":"Finalizers and cleanup callbacks","text":"<p>To dispose of external resources, JavaScript provides a <code>FinalizationRegistry</code>, where a cleanup callback or object finalizer function can be registered. This cleanup callback can be used to free any external resources associated with the JavaScript object being finalized.</p> <p>Slang's JavaScript interface registers its finalizers in a <code>FinalizationRegistry</code> to dispose of the memory used in Wasm. The JavaScript engine is responsible for calling them for objects that have been garbage-collected. However, the JavaScript specification provides no warranties of when this happens:</p> <p>A conforming JavaScript implementation, even one that does garbage collection, is not required to call cleanup callbacks. When and whether it does so is entirely down to the implementation of the JavaScript engine. When a registered object is reclaimed, any cleanup callbacks for it may be called then, or some time later, or not at all.</p> <p>In practice, cleanup callbacks are run asynchronously and after the objects in internal memory have been garbage-collected. For instance in Node.js, finalizers are not run when the code is purely or mostly synchronous.</p> <p>Depending on your engine and your application, you might experience high memory usage, even leading to a crash of the application due to an out-of-memory error. If this is your case, here's what you can do to mitigate the problem:</p>"},{"location":"user-guide/09-appendix/02-slang-memory-management/#giving-the-engine-some-time-to-breathe","title":"Giving the engine some time to breathe","text":"<p>If your application runs Slang in a tight loop, it is a good idea to add an asynchronous call, such as sleeping for a few milliseconds:</p> <pre><code>await new Promise((r) =&gt; setTimeout(r, 10));\n</code></pre> <p>In our tests, adding this timeout was sufficient to give the <code>FinalizationRegistry</code> time to properly clean up the objects. The external memory usage grows at the start, but eventually stabilizes and remains steady.</p> <p>In an interactive environment, such as an IDE or a browser, it should not be necessary to add such a pause, as the engine has several opportunities to perform cleanup while waiting for user input.</p> <p>An important point to mention is that the memory used in Wasm never shrinks back after being cleaned. This is expected by design.</p> <p>\ud83d\udea7 Warning</p> <p>Garbage collection and finalizers are not deterministic by design, so tests on one machine and one JavaScript engine might differ greatly from those on a different machine or engine. In our tests, a simple timeout of 10ms was enough for the collector to collect and call the finalizers, but your experience might vary.</p>"}]}