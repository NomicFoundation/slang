// This file is generated automatically by infrastructure scripts. Please don't edit by hand.

#[repr(u8)]
#[derive(
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
    serde::Serialize,
    strum_macros::AsRefStr,
    strum_macros::Display,
    strum_macros::EnumString,
    strum_macros::IntoStaticStr,
    Clone,
    Copy,
)]
pub enum NonterminalKind {
    AbicoderPragma,
    AdditiveExpression,
    AddressType,
    AndExpression,
    ArgumentsDeclaration,
    ArrayExpression,
    ArrayTypeName,
    ArrayValues,
    AssemblyFlags,
    AssemblyFlagsDeclaration,
    AssemblyStatement,
    AssignmentExpression,
    BitwiseAndExpression,
    BitwiseOrExpression,
    BitwiseXorExpression,
    Block,
    BreakStatement,
    CallOptions,
    CallOptionsExpression,
    CatchClause,
    CatchClauseError,
    CatchClauses,
    ComparisonExpression,
    ConditionalExpression,
    ConstantDefinition,
    ConstructorAttribute,
    ConstructorAttributes,
    ConstructorDefinition,
    ContinueStatement,
    ContractDefinition,
    ContractMember,
    ContractMembers,
    DecimalNumberExpression,
    DoWhileStatement,
    ElementaryType,
    ElseBranch,
    EmitStatement,
    EnumDefinition,
    EnumMembers,
    EqualityExpression,
    ErrorDefinition,
    ErrorParameter,
    ErrorParameters,
    ErrorParametersDeclaration,
    EventDefinition,
    EventParameter,
    EventParameters,
    EventParametersDeclaration,
    ExperimentalFeature,
    ExperimentalPragma,
    ExponentiationExpression,
    Expression,
    ExpressionStatement,
    FallbackFunctionAttribute,
    FallbackFunctionAttributes,
    FallbackFunctionDefinition,
    ForStatement,
    ForStatementCondition,
    ForStatementInitialization,
    FunctionAttribute,
    FunctionAttributes,
    FunctionBody,
    FunctionCallExpression,
    FunctionDefinition,
    FunctionName,
    FunctionType,
    FunctionTypeAttribute,
    FunctionTypeAttributes,
    HexNumberExpression,
    HexStringLiteral,
    HexStringLiterals,
    IdentifierPath,
    IfStatement,
    ImportAlias,
    ImportClause,
    ImportDeconstruction,
    ImportDeconstructionSymbol,
    ImportDeconstructionSymbols,
    ImportDirective,
    IndexAccessEnd,
    IndexAccessExpression,
    InheritanceSpecifier,
    InheritanceType,
    InheritanceTypes,
    InterfaceDefinition,
    InterfaceMembers,
    LibraryDefinition,
    LibraryMembers,
    MappingKey,
    MappingKeyType,
    MappingType,
    MappingValue,
    MemberAccessExpression,
    ModifierAttribute,
    ModifierAttributes,
    ModifierDefinition,
    ModifierInvocation,
    MultiplicativeExpression,
    NamedArgument,
    NamedArgumentGroup,
    NamedArguments,
    NamedArgumentsDeclaration,
    NamedImport,
    NewExpression,
    NumberUnit,
    OrExpression,
    OverridePaths,
    OverridePathsDeclaration,
    OverrideSpecifier,
    Parameter,
    Parameters,
    ParametersDeclaration,
    PathImport,
    PositionalArguments,
    PositionalArgumentsDeclaration,
    PostfixExpression,
    Pragma,
    PragmaDirective,
    PrefixExpression,
    ReceiveFunctionAttribute,
    ReceiveFunctionAttributes,
    ReceiveFunctionDefinition,
    ReturnStatement,
    ReturnsDeclaration,
    RevertStatement,
    ShiftExpression,
    SimpleVersionLiteral,
    SourceUnit,
    SourceUnitMember,
    SourceUnitMembers,
    StateVariableAttribute,
    StateVariableAttributes,
    StateVariableDefinition,
    StateVariableDefinitionValue,
    Statement,
    Statements,
    StorageLocation,
    StringExpression,
    StringLiteral,
    StringLiterals,
    StructDefinition,
    StructMember,
    StructMembers,
    ThrowStatement,
    TryStatement,
    TupleDeconstructionElement,
    TupleDeconstructionElements,
    TupleDeconstructionStatement,
    TupleExpression,
    TupleMember,
    TupleValue,
    TupleValues,
    TypeExpression,
    TypeName,
    TypedTupleMember,
    UncheckedBlock,
    UnicodeStringLiteral,
    UnicodeStringLiterals,
    UnnamedFunctionAttribute,
    UnnamedFunctionAttributes,
    UnnamedFunctionDefinition,
    UntypedTupleMember,
    UserDefinedValueTypeDefinition,
    UsingAlias,
    UsingClause,
    UsingDeconstruction,
    UsingDeconstructionSymbol,
    UsingDeconstructionSymbols,
    UsingDirective,
    UsingOperator,
    UsingTarget,
    VariableDeclarationStatement,
    VariableDeclarationType,
    VariableDeclarationValue,
    VersionExpression,
    VersionExpressionSet,
    VersionExpressionSets,
    VersionLiteral,
    VersionOperator,
    VersionPragma,
    VersionRange,
    VersionTerm,
    WhileStatement,
    YulArguments,
    YulAssignmentOperator,
    YulBlock,
    YulBreakStatement,
    YulBuiltInFunction,
    YulColonAndEqual,
    YulContinueStatement,
    YulDefaultCase,
    YulEqualAndColon,
    YulExpression,
    YulForStatement,
    YulFunctionCallExpression,
    YulFunctionDefinition,
    YulIfStatement,
    YulLabel,
    YulLeaveStatement,
    YulLiteral,
    YulParameters,
    YulParametersDeclaration,
    YulPath,
    YulPathComponent,
    YulPaths,
    YulReturnsDeclaration,
    YulStackAssignmentOperator,
    YulStackAssignmentStatement,
    YulStatement,
    YulStatements,
    YulSwitchCase,
    YulSwitchCases,
    YulSwitchStatement,
    YulValueCase,
    YulVariableAssignmentStatement,
    YulVariableDeclarationStatement,
    YulVariableDeclarationValue,
    YulVariableNames,
}

impl crate::cst::NonterminalKindExtensions for NonterminalKind {}
