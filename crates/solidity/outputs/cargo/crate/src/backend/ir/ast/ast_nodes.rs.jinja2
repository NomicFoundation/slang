{%- set target = model.ir_languages['ir2_flat_contracts'].target -%}
{%- set custom_types = ["EnumMembers", "Identifier", "IdentifierPath", "YulIdentifier", "YulParameters", "YulPath", "YulVariableNames"] -%}

//
// Sequences:
//

{% for parent_type, sequence in target.sequences %}
  pub type {{ parent_type }} = Rc<{{ parent_type }}Struct>;

  pub struct {{ parent_type }}Struct {
    pub(crate) ir_node: input_ir::{{ parent_type }},
    semantic: Rc<SemanticAnalysis>,
  }

  impl {{ parent_type }}Struct {
    pub(crate) fn create(
      ir_node: &input_ir::{{ parent_type }},
      semantic: &Rc<SemanticAnalysis>,
    ) -> Self {
      Self {
        ir_node: Rc::clone(ir_node),
        semantic: Rc::clone(semantic),
      }
    }

    {% for field in sequence.fields -%}
      {% if field.is_optional %}
        {% if custom_types is containing(field.type.name) %}
          pub fn {{ field.label }}(&self) -> Option<{{ field.type.name }}> {
            self.ir_node.{{ field.label }}.as_ref().map(|ir_node| {
              Rc::new({{ field.type.name }}Struct::create(ir_node, &self.semantic))
            })
          }
        {% elif field.type.kind == "UniqueTerminal" %}
          pub fn {{ field.label }}(&self) -> bool {
            self.ir_node.{{ field.label }}
          }
        {% elif field.type.is_terminal %}
          pub fn {{ field.label }}(&self) -> Option<Rc<TerminalNode>> {
            self.ir_node.{{ field.label }}.as_ref().map(Rc::clone)
          }
        {% elif target.sequences is containing(field.type.name) or
                target.choices is containing(field.type.name) %}
          pub fn {{ field.label }}(&self) -> Option<{{ field.type.name }}> {
            self.ir_node.{{ field.label }}.as_ref().map(|ir_node| {
              Rc::new({{ field.type.name }}Struct::create(ir_node, &self.semantic))
            })
          }
        {% elif target.collections is containing(field.type.name) %}
          {% set item_type = target.collections[field.type.name].item_type %}
          {%- if item_type.is_terminal and custom_types is not containing(item_type.name) %}
            pub fn {{ field.label }}(&self) -> Option<Vec<Rc<TerminalNode>>> {
              self.ir_node.{{ field.label }}.as_ref().map(|items| items.clone())
            }
          {% else %}
            pub fn {{ field.label }}(&self) -> Option<{{ field.type.name }}> {
              self.ir_node.{{ field.label }}.as_ref().map(|ir_node| {
                Rc::new({{ field.type.name }}Struct::create(ir_node, &self.semantic))
              })
            }
          {% endif -%}
        {% endif %}
      {% else %}
        {% if custom_types is containing(field.type.name) %}
          pub fn {{ field.label }}(&self) -> {{ field.type.name }} {
            Rc::new({{ field.type.name }}Struct::create(&self.ir_node.{{ field.label }}, &self.semantic))
          }
        {% elif field.type.is_terminal %}
          pub fn {{ field.label }}(&self) -> Rc<TerminalNode> {
            Rc::clone(&self.ir_node.{{ field.label }})
          }
        {% elif target.sequences is containing(field.type.name)
             or target.choices is containing(field.type.name) %}
          pub fn {{ field.label }}(&self) -> {{ field.type.name }} {
            Rc::new({{ field.type.name }}Struct::create(&self.ir_node.{{ field.label }}, &self.semantic))
          }
        {% elif target.collections is containing(field.type.name) %}
          {% set item_type = target.collections[field.type.name].item_type %}
          {% if custom_types is containing(item_type.name)
               or not item_type.is_terminal %}
            pub fn {{ field.label }}(&self) -> {{ field.type.name }} {
              Rc::new({{ field.type.name }}Struct::create(&self.ir_node.{{ field.label }}, &self.semantic))
            }
          {% elif item_type.is_terminal %}
            pub fn {{ field.label }}(&self) -> Vec<Rc<TerminalNode>> {
              self.ir_node.{{ field.label }}.clone()
            }
          {% endif %}
        {% endif %}
      {% endif %}
    {% endfor %}
  }

{% endfor %}

//
// Choices:
//

{% for parent_type, choice in target.choices %}
  pub type {{ parent_type }} = Rc<{{ parent_type }}Struct>;

  pub struct {{ parent_type }}Struct {
    pub(crate) ir_node: input_ir::{{ parent_type }},
    semantic: Rc<SemanticAnalysis>,
  }

  impl {{ parent_type }}Struct {
    pub(crate) fn create(ir_node: &input_ir::{{ parent_type }}, semantic: &Rc<SemanticAnalysis>) -> Self {
      Self {
        ir_node: ir_node.clone(),
        semantic: Rc::clone(semantic),
      }
    }

    {% for variant in choice.variants %}
      pub fn is_{{ variant.name | snake_case }}(&self) -> bool {
        matches!(self.ir_node, input_ir::{{ parent_type }}::{{ variant.name }}
          {%- if variant.kind != "UniqueTerminal" -%}
            (_)
          {%- endif -%}
        )
      }
      {% if custom_types is containing(variant.name) %}
        pub fn as_{{ variant.name | snake_case }}(&self) -> Option<{{ variant.name }}> {
          if let input_ir::{{ parent_type }}::{{ variant.name }}(variant) = &self.ir_node {
            Some(Rc::new({{ variant.name }}Struct::create(variant, &self.semantic)))
          } else {
            None
          }
        }

      {% elif variant.kind == "Nonterminal" %}
        {% if target.collections is containing(variant.name) %}
          {% set item_type = target.collections[variant.name].item_type %}
          {% if item_type.is_terminal %}
            pub fn as_{{ variant.name | snake_case }}(&self) -> Option<Vec<Rc<TerminalNode>>> {
              if let input_ir::{{ parent_type }}::{{ variant.name }}(variant) = &self.ir_node {
                Some(variant.clone())
              } else {
                None
              }
            }
          {% elif target.sequences is containing(item_type.name)
               or target.choices is containing(item_type.name) %}
            pub fn as_{{ variant.name | snake_case }}(&self) -> Option<{{ variant.name }}> {
              if let input_ir::{{ parent_type }}::{{ variant.name }}(variant) = &self.ir_node {
                Some(Rc::new({{ variant.name }}Struct::create(variant, &self.semantic)))
              } else {
                None
              }
            }
          {% endif %}
        {% else %}
          pub fn as_{{ variant.name | snake_case }}(&self) -> Option<{{ variant.name }}> {
            if let input_ir::{{ parent_type }}::{{ variant.name }}(variant) = &self.ir_node {
              Some(Rc::new({{ variant.name }}Struct::create(variant, &self.semantic)))
            } else {
              None
            }
          }
        {% endif %}
      {% endif %}
    {% endfor %}
  }

{% endfor %}

//
// Repeated & Separated
//

{%- for parent_type, collection in target.collections %}
  {%- if custom_types is not containing(parent_type) and not collection.item_type.is_terminal %}
    pub type {{ parent_type }} = Rc<{{ parent_type }}Struct>;

    pub struct {{ parent_type }}Struct {
      pub(crate) ir_nodes: Vec<input_ir::{{ collection.item_type.name }}>,
      semantic: Rc<SemanticAnalysis>,
    }

    impl {{ parent_type }}Struct {
      fn create(nodes: &[input_ir::{{ collection.item_type.name }}], semantic: &Rc<SemanticAnalysis>) -> Self {
        Self {
          ir_nodes: nodes.to_vec(),
          semantic: Rc::clone(semantic),
        }
      }

      pub fn iter(&self) -> impl Iterator<Item = {{ collection.item_type.name }}> + use<'_> {
          self.ir_nodes
              .iter()
              .map(|ir_node| Rc::new({{ collection.item_type.name }}Struct::create(ir_node, &self.semantic)))
      }
    }
  {% endif %}
{% endfor -%}
