{% macro render_builder(language) -%}
  {%- set builder = model.ir_languages[language].builder -%}
  #![allow(clippy::too_many_lines)]

  use std::rc::Rc;

  #[allow(clippy::wildcard_imports)]
  use super::nodes::*;
  use crate::cst::{
    EdgeLabel, NodeKind, NonterminalKind, SyntaxNode, TerminalKind,
  };

  //
  // Sequences:
  //

  {% for parent_type, sequence in builder.sequences %}
    {% if not sequence.has_added_fields %}
      pub fn build_{{ parent_type | snake_case }}(node: Rc<SyntaxNode>) -> Option<{{ parent_type }}>
      {
        assert_nonterminal_kind(&node, NonterminalKind::{{ parent_type }});
        let mut helper = ChildrenHelper::new(&node);
        {% for field in sequence.fields %}
          {%- if field.is_removed -%}
            helper.skip_label(EdgeLabel::{{ field.label | pascal_case }})?;
          {%- elif field.is_optional -%}
            let {{ field.label }} =
              {%- if field.type.kind == "Terminal" -%}
                helper.accept_label(EdgeLabel::{{ field.label | pascal_case }}).map(terminal_node_cloned)
              {%- elif field.type.kind == "UniqueTerminal" -%}
                helper.accept_label(EdgeLabel::{{ field.label | pascal_case }}).is_some()
              {%- else -%}
                helper.accept_label(EdgeLabel::{{ field.label | pascal_case }}).and_then(
                  build_{{ field.type.name | snake_case }}
                )
              {%- endif -%}
            ;
          {%- else -%}
            let {{ field.label }} =
            {%- if field.type.is_terminal -%}
              terminal_node_cloned(helper.accept_label(EdgeLabel::{{ field.label | pascal_case }})?);
            {%- else -%}
              build_{{ field.type.name | snake_case }}(
                helper.accept_label(EdgeLabel::{{ field.label | pascal_case }})?,
              )?;
            {%- endif -%}
          {%- endif -%}
        {%- endfor %}
        if !helper.finalize() {
          return None;
        }

        Some(Rc::new({{ parent_type }}Struct {
          node,
          {%- for field in sequence.fields -%}
            {%- if not field.is_removed -%}
              {{ field.label }},
            {%- endif -%}
          {%- endfor %}
        }))
      }
    {% endif %}
  {% endfor %}

  //
  // Choices:
  //

  {% for parent_type, choice in builder.choices %}
    #[allow(clippy::needless_pass_by_value)]
    pub fn build_{{ parent_type | snake_case }}(node: Rc<SyntaxNode>) -> Option<{{ parent_type }}> {
      assert_nonterminal_kind(&node, NonterminalKind::{{ parent_type }});
      let mut helper = ChildrenHelper::new(&node);
      let variant = helper.accept_label(EdgeLabel::Variant)?;
      let item = match variant.kind() {
        {% for type in choice.variants | filter(attribute="kind", value="Nonterminal") -%}
          NodeKind::Nonterminal(NonterminalKind::{{ type.name }}) => {{ parent_type }}::{{ type.name }}(build_{{ type.name | snake_case }}(variant)?),
        {%- endfor -%}

        {% for type in choice.variants | filter(attribute="kind", value="Terminal") -%}
          NodeKind::Terminal(TerminalKind::{{ type.name }}) => {
            {{ parent_type }}::{{ type.name }}(terminal_node_cloned(variant))
          },
        {%- endfor -%}

        {% for type in choice.variants | filter(attribute="kind", value="UniqueTerminal") -%}
          NodeKind::Terminal(TerminalKind::{{ type.name }}) => {
            {{ parent_type }}::{{ type.name }}
          },
        {%- endfor -%}

        NodeKind::Nonterminal(_) | NodeKind::Terminal(_) => {
          unreachable!("unexpected variant node of kind {kind}", kind = variant.kind());
        }
      };
      if !helper.finalize() {
        return None;
      }
      Some(item)
    }

  {% endfor %}

  //
  // Repeated & Separated
  //

  {% for parent_type, collection in builder.collections %}
    #[allow(clippy::needless_pass_by_value)]
    pub fn build_{{ parent_type | snake_case }}(node: Rc<SyntaxNode>) -> Option<{{ parent_type }}> {
      assert_nonterminal_kind(&node, NonterminalKind::{{ parent_type }});
      let mut items = {{ parent_type }}::new();
      let mut helper = ChildrenHelper::new(&node);
      while let Some(child) = helper.accept_label(EdgeLabel::Item) {
        {%- if collection.item_type.is_terminal -%}
          items.push(terminal_node_cloned(child));
        {%- else -%}
          if let Some(item) = build_{{ collection.item_type.name | snake_case }}(child) {
            items.push(item);
          }
        {%- endif -%}
        helper.skip_label(EdgeLabel::Separator);
      }
      if !helper.finalize() {
        return None;
      }
      Some(items)
    }
  {% endfor %}

  //
  // Common:
  //

  #[allow(dead_code)]
  #[inline]
  fn assert_nonterminal_kind(node: &Rc<SyntaxNode>, kind: NonterminalKind) {
    assert_eq!(node.kind(), NodeKind::Nonterminal(kind), "expected non-terminal of kind {kind}, got {node:?}");
  }

  #[allow(dead_code)]
  #[inline]
  fn terminal_node_cloned(node: Rc<SyntaxNode>) -> Rc<SyntaxNode> {
    assert!(node.is_terminal(), "expected terminal node");
    node
  }

  struct ChildrenHelper<'a> {
    children: &'a Rc<SyntaxNode>,
    index: usize,
  }

  impl<'a> ChildrenHelper<'a> {
    fn new(children: &'a Rc<SyntaxNode>) -> Self {
      let mut index = 0;
      while index < children.children_count() {
        if children.child_is_valid_and_not_trivia(index) {
          break;
        }
        index += 1;
      }
      Self { children, index }
    }

    fn skip_label(&mut self, label: EdgeLabel) -> Option<usize> {
      if self.index >= self.children.children_count() || self.children.child_label(self.index) != label {
        return None;
      }

      let result = self.index;
      loop {
        self.index += 1;
        if self.index >= self.children.children_count() ||
          self.children.child_is_valid_and_not_trivia(self.index) {
          break;
        }
      }
      Some(result)
    }

    fn accept_label(&mut self, label: EdgeLabel) -> Option<Rc<SyntaxNode>> {
      let index = self.skip_label(label)?;
      Some(self.children.nth_child(index))
    }

    fn finalize(mut self) -> bool {
      // skip over trailing trivia and unrecognized nodes
      while self.index < self.children.children_count() {
        if self.children.child_is_valid_and_not_trivia(self.index) {
          return false;
        }
        self.index += 1;
      }
      true
    }
  }

{% endmacro render_builder %}
