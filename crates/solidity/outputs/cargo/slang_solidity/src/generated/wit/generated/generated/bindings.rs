// This file is generated automatically by infrastructure scripts. Please don't edit by hand.

// Generated by `wit-bindgen` 0.26.0. DO NOT EDIT!
// Options used:
//   * default-bindings-module: "$crate::wit::slang"
//   * pub-export-macro
#[allow(dead_code)]
pub mod exports {
    #[allow(dead_code)]
    pub mod nomic_foundation {
        #[allow(dead_code)]
        pub mod slang {
            #[allow(dead_code, clippy::all)]
            pub mod kinds {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum NonterminalKind {
                    AbicoderPragma,
                    AdditiveExpression,
                    AddressType,
                    AndExpression,
                    ArgumentsDeclaration,
                    ArrayExpression,
                    ArrayTypeName,
                    ArrayValues,
                    AssemblyFlags,
                    AssemblyFlagsDeclaration,
                    AssemblyStatement,
                    AssignmentExpression,
                    BitwiseAndExpression,
                    BitwiseOrExpression,
                    BitwiseXorExpression,
                    Block,
                    BreakStatement,
                    CallOptions,
                    CallOptionsExpression,
                    CatchClause,
                    CatchClauseError,
                    CatchClauses,
                    ComparisonExpression,
                    ConditionalExpression,
                    ConstantDefinition,
                    ConstructorAttribute,
                    ConstructorAttributes,
                    ConstructorDefinition,
                    ContinueStatement,
                    ContractDefinition,
                    ContractMember,
                    ContractMembers,
                    DecimalNumberExpression,
                    DoWhileStatement,
                    ElementaryType,
                    ElseBranch,
                    EmitStatement,
                    EnumDefinition,
                    EnumMembers,
                    EqualityExpression,
                    ErrorDefinition,
                    ErrorParameter,
                    ErrorParameters,
                    ErrorParametersDeclaration,
                    EventDefinition,
                    EventParameter,
                    EventParameters,
                    EventParametersDeclaration,
                    ExperimentalFeature,
                    ExperimentalPragma,
                    ExponentiationExpression,
                    Expression,
                    ExpressionStatement,
                    FallbackFunctionAttribute,
                    FallbackFunctionAttributes,
                    FallbackFunctionDefinition,
                    ForStatement,
                    ForStatementCondition,
                    ForStatementInitialization,
                    FunctionAttribute,
                    FunctionAttributes,
                    FunctionBody,
                    FunctionCallExpression,
                    FunctionDefinition,
                    FunctionName,
                    FunctionType,
                    FunctionTypeAttribute,
                    FunctionTypeAttributes,
                    HexNumberExpression,
                    HexStringLiteral,
                    HexStringLiterals,
                    IdentifierPath,
                    IfStatement,
                    ImportAlias,
                    ImportClause,
                    ImportDeconstruction,
                    ImportDeconstructionSymbol,
                    ImportDeconstructionSymbols,
                    ImportDirective,
                    IndexAccessEnd,
                    IndexAccessExpression,
                    InheritanceSpecifier,
                    InheritanceType,
                    InheritanceTypes,
                    InterfaceDefinition,
                    InterfaceMembers,
                    LibraryDefinition,
                    LibraryMembers,
                    MappingKey,
                    MappingKeyType,
                    MappingType,
                    MappingValue,
                    MemberAccessExpression,
                    ModifierAttribute,
                    ModifierAttributes,
                    ModifierDefinition,
                    ModifierInvocation,
                    MultiplicativeExpression,
                    NamedArgument,
                    NamedArgumentGroup,
                    NamedArguments,
                    NamedArgumentsDeclaration,
                    NamedImport,
                    NewExpression,
                    NumberUnit,
                    OrExpression,
                    OverridePaths,
                    OverridePathsDeclaration,
                    OverrideSpecifier,
                    Parameter,
                    Parameters,
                    ParametersDeclaration,
                    PathImport,
                    PositionalArguments,
                    PositionalArgumentsDeclaration,
                    PostfixExpression,
                    Pragma,
                    PragmaDirective,
                    PrefixExpression,
                    ReceiveFunctionAttribute,
                    ReceiveFunctionAttributes,
                    ReceiveFunctionDefinition,
                    ReturnStatement,
                    ReturnsDeclaration,
                    RevertStatement,
                    ShiftExpression,
                    SourceUnit,
                    SourceUnitMember,
                    SourceUnitMembers,
                    StateVariableAttribute,
                    StateVariableAttributes,
                    StateVariableDefinition,
                    StateVariableDefinitionValue,
                    Statement,
                    Statements,
                    StorageLocation,
                    StringExpression,
                    StringLiteral,
                    StringLiterals,
                    StructDefinition,
                    StructMember,
                    StructMembers,
                    ThrowStatement,
                    TryStatement,
                    TupleDeconstructionElement,
                    TupleDeconstructionElements,
                    TupleDeconstructionStatement,
                    TupleExpression,
                    TupleMember,
                    TupleValue,
                    TupleValues,
                    TypeExpression,
                    TypeName,
                    TypedTupleMember,
                    UncheckedBlock,
                    UnicodeStringLiteral,
                    UnicodeStringLiterals,
                    UnnamedFunctionAttribute,
                    UnnamedFunctionAttributes,
                    UnnamedFunctionDefinition,
                    UntypedTupleMember,
                    UserDefinedValueTypeDefinition,
                    UsingAlias,
                    UsingClause,
                    UsingDeconstruction,
                    UsingDeconstructionSymbol,
                    UsingDeconstructionSymbols,
                    UsingDirective,
                    UsingOperator,
                    UsingTarget,
                    VariableDeclarationStatement,
                    VariableDeclarationType,
                    VariableDeclarationValue,
                    VersionComparator,
                    VersionExpression,
                    VersionExpressionSet,
                    VersionExpressionSets,
                    VersionPragma,
                    VersionRange,
                    VersionSpecifiers,
                    WhileStatement,
                    YulArguments,
                    YulAssignmentOperator,
                    YulBlock,
                    YulBreakStatement,
                    YulBuiltInFunction,
                    YulColonAndEqual,
                    YulContinueStatement,
                    YulDefaultCase,
                    YulEqualAndColon,
                    YulExpression,
                    YulForStatement,
                    YulFunctionCallExpression,
                    YulFunctionDefinition,
                    YulIfStatement,
                    YulLabel,
                    YulLeaveStatement,
                    YulLiteral,
                    YulParameters,
                    YulParametersDeclaration,
                    YulPath,
                    YulPathComponent,
                    YulPaths,
                    YulReturnsDeclaration,
                    YulStackAssignmentOperator,
                    YulStackAssignmentStatement,
                    YulStatement,
                    YulStatements,
                    YulSwitchCase,
                    YulSwitchCases,
                    YulSwitchStatement,
                    YulValueCase,
                    YulVariableAssignmentStatement,
                    YulVariableDeclarationStatement,
                    YulVariableDeclarationValue,
                    YulVariableNames,
                }
                impl ::core::fmt::Debug for NonterminalKind {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            NonterminalKind::AbicoderPragma => {
                                f.debug_tuple("NonterminalKind::AbicoderPragma").finish()
                            }
                            NonterminalKind::AdditiveExpression => f
                                .debug_tuple("NonterminalKind::AdditiveExpression")
                                .finish(),
                            NonterminalKind::AddressType => {
                                f.debug_tuple("NonterminalKind::AddressType").finish()
                            }
                            NonterminalKind::AndExpression => {
                                f.debug_tuple("NonterminalKind::AndExpression").finish()
                            }
                            NonterminalKind::ArgumentsDeclaration => f
                                .debug_tuple("NonterminalKind::ArgumentsDeclaration")
                                .finish(),
                            NonterminalKind::ArrayExpression => {
                                f.debug_tuple("NonterminalKind::ArrayExpression").finish()
                            }
                            NonterminalKind::ArrayTypeName => {
                                f.debug_tuple("NonterminalKind::ArrayTypeName").finish()
                            }
                            NonterminalKind::ArrayValues => {
                                f.debug_tuple("NonterminalKind::ArrayValues").finish()
                            }
                            NonterminalKind::AssemblyFlags => {
                                f.debug_tuple("NonterminalKind::AssemblyFlags").finish()
                            }
                            NonterminalKind::AssemblyFlagsDeclaration => f
                                .debug_tuple("NonterminalKind::AssemblyFlagsDeclaration")
                                .finish(),
                            NonterminalKind::AssemblyStatement => {
                                f.debug_tuple("NonterminalKind::AssemblyStatement").finish()
                            }
                            NonterminalKind::AssignmentExpression => f
                                .debug_tuple("NonterminalKind::AssignmentExpression")
                                .finish(),
                            NonterminalKind::BitwiseAndExpression => f
                                .debug_tuple("NonterminalKind::BitwiseAndExpression")
                                .finish(),
                            NonterminalKind::BitwiseOrExpression => f
                                .debug_tuple("NonterminalKind::BitwiseOrExpression")
                                .finish(),
                            NonterminalKind::BitwiseXorExpression => f
                                .debug_tuple("NonterminalKind::BitwiseXorExpression")
                                .finish(),
                            NonterminalKind::Block => {
                                f.debug_tuple("NonterminalKind::Block").finish()
                            }
                            NonterminalKind::BreakStatement => {
                                f.debug_tuple("NonterminalKind::BreakStatement").finish()
                            }
                            NonterminalKind::CallOptions => {
                                f.debug_tuple("NonterminalKind::CallOptions").finish()
                            }
                            NonterminalKind::CallOptionsExpression => f
                                .debug_tuple("NonterminalKind::CallOptionsExpression")
                                .finish(),
                            NonterminalKind::CatchClause => {
                                f.debug_tuple("NonterminalKind::CatchClause").finish()
                            }
                            NonterminalKind::CatchClauseError => {
                                f.debug_tuple("NonterminalKind::CatchClauseError").finish()
                            }
                            NonterminalKind::CatchClauses => {
                                f.debug_tuple("NonterminalKind::CatchClauses").finish()
                            }
                            NonterminalKind::ComparisonExpression => f
                                .debug_tuple("NonterminalKind::ComparisonExpression")
                                .finish(),
                            NonterminalKind::ConditionalExpression => f
                                .debug_tuple("NonterminalKind::ConditionalExpression")
                                .finish(),
                            NonterminalKind::ConstantDefinition => f
                                .debug_tuple("NonterminalKind::ConstantDefinition")
                                .finish(),
                            NonterminalKind::ConstructorAttribute => f
                                .debug_tuple("NonterminalKind::ConstructorAttribute")
                                .finish(),
                            NonterminalKind::ConstructorAttributes => f
                                .debug_tuple("NonterminalKind::ConstructorAttributes")
                                .finish(),
                            NonterminalKind::ConstructorDefinition => f
                                .debug_tuple("NonterminalKind::ConstructorDefinition")
                                .finish(),
                            NonterminalKind::ContinueStatement => {
                                f.debug_tuple("NonterminalKind::ContinueStatement").finish()
                            }
                            NonterminalKind::ContractDefinition => f
                                .debug_tuple("NonterminalKind::ContractDefinition")
                                .finish(),
                            NonterminalKind::ContractMember => {
                                f.debug_tuple("NonterminalKind::ContractMember").finish()
                            }
                            NonterminalKind::ContractMembers => {
                                f.debug_tuple("NonterminalKind::ContractMembers").finish()
                            }
                            NonterminalKind::DecimalNumberExpression => f
                                .debug_tuple("NonterminalKind::DecimalNumberExpression")
                                .finish(),
                            NonterminalKind::DoWhileStatement => {
                                f.debug_tuple("NonterminalKind::DoWhileStatement").finish()
                            }
                            NonterminalKind::ElementaryType => {
                                f.debug_tuple("NonterminalKind::ElementaryType").finish()
                            }
                            NonterminalKind::ElseBranch => {
                                f.debug_tuple("NonterminalKind::ElseBranch").finish()
                            }
                            NonterminalKind::EmitStatement => {
                                f.debug_tuple("NonterminalKind::EmitStatement").finish()
                            }
                            NonterminalKind::EnumDefinition => {
                                f.debug_tuple("NonterminalKind::EnumDefinition").finish()
                            }
                            NonterminalKind::EnumMembers => {
                                f.debug_tuple("NonterminalKind::EnumMembers").finish()
                            }
                            NonterminalKind::EqualityExpression => f
                                .debug_tuple("NonterminalKind::EqualityExpression")
                                .finish(),
                            NonterminalKind::ErrorDefinition => {
                                f.debug_tuple("NonterminalKind::ErrorDefinition").finish()
                            }
                            NonterminalKind::ErrorParameter => {
                                f.debug_tuple("NonterminalKind::ErrorParameter").finish()
                            }
                            NonterminalKind::ErrorParameters => {
                                f.debug_tuple("NonterminalKind::ErrorParameters").finish()
                            }
                            NonterminalKind::ErrorParametersDeclaration => f
                                .debug_tuple("NonterminalKind::ErrorParametersDeclaration")
                                .finish(),
                            NonterminalKind::EventDefinition => {
                                f.debug_tuple("NonterminalKind::EventDefinition").finish()
                            }
                            NonterminalKind::EventParameter => {
                                f.debug_tuple("NonterminalKind::EventParameter").finish()
                            }
                            NonterminalKind::EventParameters => {
                                f.debug_tuple("NonterminalKind::EventParameters").finish()
                            }
                            NonterminalKind::EventParametersDeclaration => f
                                .debug_tuple("NonterminalKind::EventParametersDeclaration")
                                .finish(),
                            NonterminalKind::ExperimentalFeature => f
                                .debug_tuple("NonterminalKind::ExperimentalFeature")
                                .finish(),
                            NonterminalKind::ExperimentalPragma => f
                                .debug_tuple("NonterminalKind::ExperimentalPragma")
                                .finish(),
                            NonterminalKind::ExponentiationExpression => f
                                .debug_tuple("NonterminalKind::ExponentiationExpression")
                                .finish(),
                            NonterminalKind::Expression => {
                                f.debug_tuple("NonterminalKind::Expression").finish()
                            }
                            NonterminalKind::ExpressionStatement => f
                                .debug_tuple("NonterminalKind::ExpressionStatement")
                                .finish(),
                            NonterminalKind::FallbackFunctionAttribute => f
                                .debug_tuple("NonterminalKind::FallbackFunctionAttribute")
                                .finish(),
                            NonterminalKind::FallbackFunctionAttributes => f
                                .debug_tuple("NonterminalKind::FallbackFunctionAttributes")
                                .finish(),
                            NonterminalKind::FallbackFunctionDefinition => f
                                .debug_tuple("NonterminalKind::FallbackFunctionDefinition")
                                .finish(),
                            NonterminalKind::ForStatement => {
                                f.debug_tuple("NonterminalKind::ForStatement").finish()
                            }
                            NonterminalKind::ForStatementCondition => f
                                .debug_tuple("NonterminalKind::ForStatementCondition")
                                .finish(),
                            NonterminalKind::ForStatementInitialization => f
                                .debug_tuple("NonterminalKind::ForStatementInitialization")
                                .finish(),
                            NonterminalKind::FunctionAttribute => {
                                f.debug_tuple("NonterminalKind::FunctionAttribute").finish()
                            }
                            NonterminalKind::FunctionAttributes => f
                                .debug_tuple("NonterminalKind::FunctionAttributes")
                                .finish(),
                            NonterminalKind::FunctionBody => {
                                f.debug_tuple("NonterminalKind::FunctionBody").finish()
                            }
                            NonterminalKind::FunctionCallExpression => f
                                .debug_tuple("NonterminalKind::FunctionCallExpression")
                                .finish(),
                            NonterminalKind::FunctionDefinition => f
                                .debug_tuple("NonterminalKind::FunctionDefinition")
                                .finish(),
                            NonterminalKind::FunctionName => {
                                f.debug_tuple("NonterminalKind::FunctionName").finish()
                            }
                            NonterminalKind::FunctionType => {
                                f.debug_tuple("NonterminalKind::FunctionType").finish()
                            }
                            NonterminalKind::FunctionTypeAttribute => f
                                .debug_tuple("NonterminalKind::FunctionTypeAttribute")
                                .finish(),
                            NonterminalKind::FunctionTypeAttributes => f
                                .debug_tuple("NonterminalKind::FunctionTypeAttributes")
                                .finish(),
                            NonterminalKind::HexNumberExpression => f
                                .debug_tuple("NonterminalKind::HexNumberExpression")
                                .finish(),
                            NonterminalKind::HexStringLiteral => {
                                f.debug_tuple("NonterminalKind::HexStringLiteral").finish()
                            }
                            NonterminalKind::HexStringLiterals => {
                                f.debug_tuple("NonterminalKind::HexStringLiterals").finish()
                            }
                            NonterminalKind::IdentifierPath => {
                                f.debug_tuple("NonterminalKind::IdentifierPath").finish()
                            }
                            NonterminalKind::IfStatement => {
                                f.debug_tuple("NonterminalKind::IfStatement").finish()
                            }
                            NonterminalKind::ImportAlias => {
                                f.debug_tuple("NonterminalKind::ImportAlias").finish()
                            }
                            NonterminalKind::ImportClause => {
                                f.debug_tuple("NonterminalKind::ImportClause").finish()
                            }
                            NonterminalKind::ImportDeconstruction => f
                                .debug_tuple("NonterminalKind::ImportDeconstruction")
                                .finish(),
                            NonterminalKind::ImportDeconstructionSymbol => f
                                .debug_tuple("NonterminalKind::ImportDeconstructionSymbol")
                                .finish(),
                            NonterminalKind::ImportDeconstructionSymbols => f
                                .debug_tuple("NonterminalKind::ImportDeconstructionSymbols")
                                .finish(),
                            NonterminalKind::ImportDirective => {
                                f.debug_tuple("NonterminalKind::ImportDirective").finish()
                            }
                            NonterminalKind::IndexAccessEnd => {
                                f.debug_tuple("NonterminalKind::IndexAccessEnd").finish()
                            }
                            NonterminalKind::IndexAccessExpression => f
                                .debug_tuple("NonterminalKind::IndexAccessExpression")
                                .finish(),
                            NonterminalKind::InheritanceSpecifier => f
                                .debug_tuple("NonterminalKind::InheritanceSpecifier")
                                .finish(),
                            NonterminalKind::InheritanceType => {
                                f.debug_tuple("NonterminalKind::InheritanceType").finish()
                            }
                            NonterminalKind::InheritanceTypes => {
                                f.debug_tuple("NonterminalKind::InheritanceTypes").finish()
                            }
                            NonterminalKind::InterfaceDefinition => f
                                .debug_tuple("NonterminalKind::InterfaceDefinition")
                                .finish(),
                            NonterminalKind::InterfaceMembers => {
                                f.debug_tuple("NonterminalKind::InterfaceMembers").finish()
                            }
                            NonterminalKind::LibraryDefinition => {
                                f.debug_tuple("NonterminalKind::LibraryDefinition").finish()
                            }
                            NonterminalKind::LibraryMembers => {
                                f.debug_tuple("NonterminalKind::LibraryMembers").finish()
                            }
                            NonterminalKind::MappingKey => {
                                f.debug_tuple("NonterminalKind::MappingKey").finish()
                            }
                            NonterminalKind::MappingKeyType => {
                                f.debug_tuple("NonterminalKind::MappingKeyType").finish()
                            }
                            NonterminalKind::MappingType => {
                                f.debug_tuple("NonterminalKind::MappingType").finish()
                            }
                            NonterminalKind::MappingValue => {
                                f.debug_tuple("NonterminalKind::MappingValue").finish()
                            }
                            NonterminalKind::MemberAccessExpression => f
                                .debug_tuple("NonterminalKind::MemberAccessExpression")
                                .finish(),
                            NonterminalKind::ModifierAttribute => {
                                f.debug_tuple("NonterminalKind::ModifierAttribute").finish()
                            }
                            NonterminalKind::ModifierAttributes => f
                                .debug_tuple("NonterminalKind::ModifierAttributes")
                                .finish(),
                            NonterminalKind::ModifierDefinition => f
                                .debug_tuple("NonterminalKind::ModifierDefinition")
                                .finish(),
                            NonterminalKind::ModifierInvocation => f
                                .debug_tuple("NonterminalKind::ModifierInvocation")
                                .finish(),
                            NonterminalKind::MultiplicativeExpression => f
                                .debug_tuple("NonterminalKind::MultiplicativeExpression")
                                .finish(),
                            NonterminalKind::NamedArgument => {
                                f.debug_tuple("NonterminalKind::NamedArgument").finish()
                            }
                            NonterminalKind::NamedArgumentGroup => f
                                .debug_tuple("NonterminalKind::NamedArgumentGroup")
                                .finish(),
                            NonterminalKind::NamedArguments => {
                                f.debug_tuple("NonterminalKind::NamedArguments").finish()
                            }
                            NonterminalKind::NamedArgumentsDeclaration => f
                                .debug_tuple("NonterminalKind::NamedArgumentsDeclaration")
                                .finish(),
                            NonterminalKind::NamedImport => {
                                f.debug_tuple("NonterminalKind::NamedImport").finish()
                            }
                            NonterminalKind::NewExpression => {
                                f.debug_tuple("NonterminalKind::NewExpression").finish()
                            }
                            NonterminalKind::NumberUnit => {
                                f.debug_tuple("NonterminalKind::NumberUnit").finish()
                            }
                            NonterminalKind::OrExpression => {
                                f.debug_tuple("NonterminalKind::OrExpression").finish()
                            }
                            NonterminalKind::OverridePaths => {
                                f.debug_tuple("NonterminalKind::OverridePaths").finish()
                            }
                            NonterminalKind::OverridePathsDeclaration => f
                                .debug_tuple("NonterminalKind::OverridePathsDeclaration")
                                .finish(),
                            NonterminalKind::OverrideSpecifier => {
                                f.debug_tuple("NonterminalKind::OverrideSpecifier").finish()
                            }
                            NonterminalKind::Parameter => {
                                f.debug_tuple("NonterminalKind::Parameter").finish()
                            }
                            NonterminalKind::Parameters => {
                                f.debug_tuple("NonterminalKind::Parameters").finish()
                            }
                            NonterminalKind::ParametersDeclaration => f
                                .debug_tuple("NonterminalKind::ParametersDeclaration")
                                .finish(),
                            NonterminalKind::PathImport => {
                                f.debug_tuple("NonterminalKind::PathImport").finish()
                            }
                            NonterminalKind::PositionalArguments => f
                                .debug_tuple("NonterminalKind::PositionalArguments")
                                .finish(),
                            NonterminalKind::PositionalArgumentsDeclaration => f
                                .debug_tuple("NonterminalKind::PositionalArgumentsDeclaration")
                                .finish(),
                            NonterminalKind::PostfixExpression => {
                                f.debug_tuple("NonterminalKind::PostfixExpression").finish()
                            }
                            NonterminalKind::Pragma => {
                                f.debug_tuple("NonterminalKind::Pragma").finish()
                            }
                            NonterminalKind::PragmaDirective => {
                                f.debug_tuple("NonterminalKind::PragmaDirective").finish()
                            }
                            NonterminalKind::PrefixExpression => {
                                f.debug_tuple("NonterminalKind::PrefixExpression").finish()
                            }
                            NonterminalKind::ReceiveFunctionAttribute => f
                                .debug_tuple("NonterminalKind::ReceiveFunctionAttribute")
                                .finish(),
                            NonterminalKind::ReceiveFunctionAttributes => f
                                .debug_tuple("NonterminalKind::ReceiveFunctionAttributes")
                                .finish(),
                            NonterminalKind::ReceiveFunctionDefinition => f
                                .debug_tuple("NonterminalKind::ReceiveFunctionDefinition")
                                .finish(),
                            NonterminalKind::ReturnStatement => {
                                f.debug_tuple("NonterminalKind::ReturnStatement").finish()
                            }
                            NonterminalKind::ReturnsDeclaration => f
                                .debug_tuple("NonterminalKind::ReturnsDeclaration")
                                .finish(),
                            NonterminalKind::RevertStatement => {
                                f.debug_tuple("NonterminalKind::RevertStatement").finish()
                            }
                            NonterminalKind::ShiftExpression => {
                                f.debug_tuple("NonterminalKind::ShiftExpression").finish()
                            }
                            NonterminalKind::SourceUnit => {
                                f.debug_tuple("NonterminalKind::SourceUnit").finish()
                            }
                            NonterminalKind::SourceUnitMember => {
                                f.debug_tuple("NonterminalKind::SourceUnitMember").finish()
                            }
                            NonterminalKind::SourceUnitMembers => {
                                f.debug_tuple("NonterminalKind::SourceUnitMembers").finish()
                            }
                            NonterminalKind::StateVariableAttribute => f
                                .debug_tuple("NonterminalKind::StateVariableAttribute")
                                .finish(),
                            NonterminalKind::StateVariableAttributes => f
                                .debug_tuple("NonterminalKind::StateVariableAttributes")
                                .finish(),
                            NonterminalKind::StateVariableDefinition => f
                                .debug_tuple("NonterminalKind::StateVariableDefinition")
                                .finish(),
                            NonterminalKind::StateVariableDefinitionValue => f
                                .debug_tuple("NonterminalKind::StateVariableDefinitionValue")
                                .finish(),
                            NonterminalKind::Statement => {
                                f.debug_tuple("NonterminalKind::Statement").finish()
                            }
                            NonterminalKind::Statements => {
                                f.debug_tuple("NonterminalKind::Statements").finish()
                            }
                            NonterminalKind::StorageLocation => {
                                f.debug_tuple("NonterminalKind::StorageLocation").finish()
                            }
                            NonterminalKind::StringExpression => {
                                f.debug_tuple("NonterminalKind::StringExpression").finish()
                            }
                            NonterminalKind::StringLiteral => {
                                f.debug_tuple("NonterminalKind::StringLiteral").finish()
                            }
                            NonterminalKind::StringLiterals => {
                                f.debug_tuple("NonterminalKind::StringLiterals").finish()
                            }
                            NonterminalKind::StructDefinition => {
                                f.debug_tuple("NonterminalKind::StructDefinition").finish()
                            }
                            NonterminalKind::StructMember => {
                                f.debug_tuple("NonterminalKind::StructMember").finish()
                            }
                            NonterminalKind::StructMembers => {
                                f.debug_tuple("NonterminalKind::StructMembers").finish()
                            }
                            NonterminalKind::ThrowStatement => {
                                f.debug_tuple("NonterminalKind::ThrowStatement").finish()
                            }
                            NonterminalKind::TryStatement => {
                                f.debug_tuple("NonterminalKind::TryStatement").finish()
                            }
                            NonterminalKind::TupleDeconstructionElement => f
                                .debug_tuple("NonterminalKind::TupleDeconstructionElement")
                                .finish(),
                            NonterminalKind::TupleDeconstructionElements => f
                                .debug_tuple("NonterminalKind::TupleDeconstructionElements")
                                .finish(),
                            NonterminalKind::TupleDeconstructionStatement => f
                                .debug_tuple("NonterminalKind::TupleDeconstructionStatement")
                                .finish(),
                            NonterminalKind::TupleExpression => {
                                f.debug_tuple("NonterminalKind::TupleExpression").finish()
                            }
                            NonterminalKind::TupleMember => {
                                f.debug_tuple("NonterminalKind::TupleMember").finish()
                            }
                            NonterminalKind::TupleValue => {
                                f.debug_tuple("NonterminalKind::TupleValue").finish()
                            }
                            NonterminalKind::TupleValues => {
                                f.debug_tuple("NonterminalKind::TupleValues").finish()
                            }
                            NonterminalKind::TypeExpression => {
                                f.debug_tuple("NonterminalKind::TypeExpression").finish()
                            }
                            NonterminalKind::TypeName => {
                                f.debug_tuple("NonterminalKind::TypeName").finish()
                            }
                            NonterminalKind::TypedTupleMember => {
                                f.debug_tuple("NonterminalKind::TypedTupleMember").finish()
                            }
                            NonterminalKind::UncheckedBlock => {
                                f.debug_tuple("NonterminalKind::UncheckedBlock").finish()
                            }
                            NonterminalKind::UnicodeStringLiteral => f
                                .debug_tuple("NonterminalKind::UnicodeStringLiteral")
                                .finish(),
                            NonterminalKind::UnicodeStringLiterals => f
                                .debug_tuple("NonterminalKind::UnicodeStringLiterals")
                                .finish(),
                            NonterminalKind::UnnamedFunctionAttribute => f
                                .debug_tuple("NonterminalKind::UnnamedFunctionAttribute")
                                .finish(),
                            NonterminalKind::UnnamedFunctionAttributes => f
                                .debug_tuple("NonterminalKind::UnnamedFunctionAttributes")
                                .finish(),
                            NonterminalKind::UnnamedFunctionDefinition => f
                                .debug_tuple("NonterminalKind::UnnamedFunctionDefinition")
                                .finish(),
                            NonterminalKind::UntypedTupleMember => f
                                .debug_tuple("NonterminalKind::UntypedTupleMember")
                                .finish(),
                            NonterminalKind::UserDefinedValueTypeDefinition => f
                                .debug_tuple("NonterminalKind::UserDefinedValueTypeDefinition")
                                .finish(),
                            NonterminalKind::UsingAlias => {
                                f.debug_tuple("NonterminalKind::UsingAlias").finish()
                            }
                            NonterminalKind::UsingClause => {
                                f.debug_tuple("NonterminalKind::UsingClause").finish()
                            }
                            NonterminalKind::UsingDeconstruction => f
                                .debug_tuple("NonterminalKind::UsingDeconstruction")
                                .finish(),
                            NonterminalKind::UsingDeconstructionSymbol => f
                                .debug_tuple("NonterminalKind::UsingDeconstructionSymbol")
                                .finish(),
                            NonterminalKind::UsingDeconstructionSymbols => f
                                .debug_tuple("NonterminalKind::UsingDeconstructionSymbols")
                                .finish(),
                            NonterminalKind::UsingDirective => {
                                f.debug_tuple("NonterminalKind::UsingDirective").finish()
                            }
                            NonterminalKind::UsingOperator => {
                                f.debug_tuple("NonterminalKind::UsingOperator").finish()
                            }
                            NonterminalKind::UsingTarget => {
                                f.debug_tuple("NonterminalKind::UsingTarget").finish()
                            }
                            NonterminalKind::VariableDeclarationStatement => f
                                .debug_tuple("NonterminalKind::VariableDeclarationStatement")
                                .finish(),
                            NonterminalKind::VariableDeclarationType => f
                                .debug_tuple("NonterminalKind::VariableDeclarationType")
                                .finish(),
                            NonterminalKind::VariableDeclarationValue => f
                                .debug_tuple("NonterminalKind::VariableDeclarationValue")
                                .finish(),
                            NonterminalKind::VersionComparator => {
                                f.debug_tuple("NonterminalKind::VersionComparator").finish()
                            }
                            NonterminalKind::VersionExpression => {
                                f.debug_tuple("NonterminalKind::VersionExpression").finish()
                            }
                            NonterminalKind::VersionExpressionSet => f
                                .debug_tuple("NonterminalKind::VersionExpressionSet")
                                .finish(),
                            NonterminalKind::VersionExpressionSets => f
                                .debug_tuple("NonterminalKind::VersionExpressionSets")
                                .finish(),
                            NonterminalKind::VersionPragma => {
                                f.debug_tuple("NonterminalKind::VersionPragma").finish()
                            }
                            NonterminalKind::VersionRange => {
                                f.debug_tuple("NonterminalKind::VersionRange").finish()
                            }
                            NonterminalKind::VersionSpecifiers => {
                                f.debug_tuple("NonterminalKind::VersionSpecifiers").finish()
                            }
                            NonterminalKind::WhileStatement => {
                                f.debug_tuple("NonterminalKind::WhileStatement").finish()
                            }
                            NonterminalKind::YulArguments => {
                                f.debug_tuple("NonterminalKind::YulArguments").finish()
                            }
                            NonterminalKind::YulAssignmentOperator => f
                                .debug_tuple("NonterminalKind::YulAssignmentOperator")
                                .finish(),
                            NonterminalKind::YulBlock => {
                                f.debug_tuple("NonterminalKind::YulBlock").finish()
                            }
                            NonterminalKind::YulBreakStatement => {
                                f.debug_tuple("NonterminalKind::YulBreakStatement").finish()
                            }
                            NonterminalKind::YulBuiltInFunction => f
                                .debug_tuple("NonterminalKind::YulBuiltInFunction")
                                .finish(),
                            NonterminalKind::YulColonAndEqual => {
                                f.debug_tuple("NonterminalKind::YulColonAndEqual").finish()
                            }
                            NonterminalKind::YulContinueStatement => f
                                .debug_tuple("NonterminalKind::YulContinueStatement")
                                .finish(),
                            NonterminalKind::YulDefaultCase => {
                                f.debug_tuple("NonterminalKind::YulDefaultCase").finish()
                            }
                            NonterminalKind::YulEqualAndColon => {
                                f.debug_tuple("NonterminalKind::YulEqualAndColon").finish()
                            }
                            NonterminalKind::YulExpression => {
                                f.debug_tuple("NonterminalKind::YulExpression").finish()
                            }
                            NonterminalKind::YulForStatement => {
                                f.debug_tuple("NonterminalKind::YulForStatement").finish()
                            }
                            NonterminalKind::YulFunctionCallExpression => f
                                .debug_tuple("NonterminalKind::YulFunctionCallExpression")
                                .finish(),
                            NonterminalKind::YulFunctionDefinition => f
                                .debug_tuple("NonterminalKind::YulFunctionDefinition")
                                .finish(),
                            NonterminalKind::YulIfStatement => {
                                f.debug_tuple("NonterminalKind::YulIfStatement").finish()
                            }
                            NonterminalKind::YulLabel => {
                                f.debug_tuple("NonterminalKind::YulLabel").finish()
                            }
                            NonterminalKind::YulLeaveStatement => {
                                f.debug_tuple("NonterminalKind::YulLeaveStatement").finish()
                            }
                            NonterminalKind::YulLiteral => {
                                f.debug_tuple("NonterminalKind::YulLiteral").finish()
                            }
                            NonterminalKind::YulParameters => {
                                f.debug_tuple("NonterminalKind::YulParameters").finish()
                            }
                            NonterminalKind::YulParametersDeclaration => f
                                .debug_tuple("NonterminalKind::YulParametersDeclaration")
                                .finish(),
                            NonterminalKind::YulPath => {
                                f.debug_tuple("NonterminalKind::YulPath").finish()
                            }
                            NonterminalKind::YulPathComponent => {
                                f.debug_tuple("NonterminalKind::YulPathComponent").finish()
                            }
                            NonterminalKind::YulPaths => {
                                f.debug_tuple("NonterminalKind::YulPaths").finish()
                            }
                            NonterminalKind::YulReturnsDeclaration => f
                                .debug_tuple("NonterminalKind::YulReturnsDeclaration")
                                .finish(),
                            NonterminalKind::YulStackAssignmentOperator => f
                                .debug_tuple("NonterminalKind::YulStackAssignmentOperator")
                                .finish(),
                            NonterminalKind::YulStackAssignmentStatement => f
                                .debug_tuple("NonterminalKind::YulStackAssignmentStatement")
                                .finish(),
                            NonterminalKind::YulStatement => {
                                f.debug_tuple("NonterminalKind::YulStatement").finish()
                            }
                            NonterminalKind::YulStatements => {
                                f.debug_tuple("NonterminalKind::YulStatements").finish()
                            }
                            NonterminalKind::YulSwitchCase => {
                                f.debug_tuple("NonterminalKind::YulSwitchCase").finish()
                            }
                            NonterminalKind::YulSwitchCases => {
                                f.debug_tuple("NonterminalKind::YulSwitchCases").finish()
                            }
                            NonterminalKind::YulSwitchStatement => f
                                .debug_tuple("NonterminalKind::YulSwitchStatement")
                                .finish(),
                            NonterminalKind::YulValueCase => {
                                f.debug_tuple("NonterminalKind::YulValueCase").finish()
                            }
                            NonterminalKind::YulVariableAssignmentStatement => f
                                .debug_tuple("NonterminalKind::YulVariableAssignmentStatement")
                                .finish(),
                            NonterminalKind::YulVariableDeclarationStatement => f
                                .debug_tuple("NonterminalKind::YulVariableDeclarationStatement")
                                .finish(),
                            NonterminalKind::YulVariableDeclarationValue => f
                                .debug_tuple("NonterminalKind::YulVariableDeclarationValue")
                                .finish(),
                            NonterminalKind::YulVariableNames => {
                                f.debug_tuple("NonterminalKind::YulVariableNames").finish()
                            }
                        }
                    }
                }

                impl NonterminalKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> NonterminalKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => NonterminalKind::AbicoderPragma,
                            1 => NonterminalKind::AdditiveExpression,
                            2 => NonterminalKind::AddressType,
                            3 => NonterminalKind::AndExpression,
                            4 => NonterminalKind::ArgumentsDeclaration,
                            5 => NonterminalKind::ArrayExpression,
                            6 => NonterminalKind::ArrayTypeName,
                            7 => NonterminalKind::ArrayValues,
                            8 => NonterminalKind::AssemblyFlags,
                            9 => NonterminalKind::AssemblyFlagsDeclaration,
                            10 => NonterminalKind::AssemblyStatement,
                            11 => NonterminalKind::AssignmentExpression,
                            12 => NonterminalKind::BitwiseAndExpression,
                            13 => NonterminalKind::BitwiseOrExpression,
                            14 => NonterminalKind::BitwiseXorExpression,
                            15 => NonterminalKind::Block,
                            16 => NonterminalKind::BreakStatement,
                            17 => NonterminalKind::CallOptions,
                            18 => NonterminalKind::CallOptionsExpression,
                            19 => NonterminalKind::CatchClause,
                            20 => NonterminalKind::CatchClauseError,
                            21 => NonterminalKind::CatchClauses,
                            22 => NonterminalKind::ComparisonExpression,
                            23 => NonterminalKind::ConditionalExpression,
                            24 => NonterminalKind::ConstantDefinition,
                            25 => NonterminalKind::ConstructorAttribute,
                            26 => NonterminalKind::ConstructorAttributes,
                            27 => NonterminalKind::ConstructorDefinition,
                            28 => NonterminalKind::ContinueStatement,
                            29 => NonterminalKind::ContractDefinition,
                            30 => NonterminalKind::ContractMember,
                            31 => NonterminalKind::ContractMembers,
                            32 => NonterminalKind::DecimalNumberExpression,
                            33 => NonterminalKind::DoWhileStatement,
                            34 => NonterminalKind::ElementaryType,
                            35 => NonterminalKind::ElseBranch,
                            36 => NonterminalKind::EmitStatement,
                            37 => NonterminalKind::EnumDefinition,
                            38 => NonterminalKind::EnumMembers,
                            39 => NonterminalKind::EqualityExpression,
                            40 => NonterminalKind::ErrorDefinition,
                            41 => NonterminalKind::ErrorParameter,
                            42 => NonterminalKind::ErrorParameters,
                            43 => NonterminalKind::ErrorParametersDeclaration,
                            44 => NonterminalKind::EventDefinition,
                            45 => NonterminalKind::EventParameter,
                            46 => NonterminalKind::EventParameters,
                            47 => NonterminalKind::EventParametersDeclaration,
                            48 => NonterminalKind::ExperimentalFeature,
                            49 => NonterminalKind::ExperimentalPragma,
                            50 => NonterminalKind::ExponentiationExpression,
                            51 => NonterminalKind::Expression,
                            52 => NonterminalKind::ExpressionStatement,
                            53 => NonterminalKind::FallbackFunctionAttribute,
                            54 => NonterminalKind::FallbackFunctionAttributes,
                            55 => NonterminalKind::FallbackFunctionDefinition,
                            56 => NonterminalKind::ForStatement,
                            57 => NonterminalKind::ForStatementCondition,
                            58 => NonterminalKind::ForStatementInitialization,
                            59 => NonterminalKind::FunctionAttribute,
                            60 => NonterminalKind::FunctionAttributes,
                            61 => NonterminalKind::FunctionBody,
                            62 => NonterminalKind::FunctionCallExpression,
                            63 => NonterminalKind::FunctionDefinition,
                            64 => NonterminalKind::FunctionName,
                            65 => NonterminalKind::FunctionType,
                            66 => NonterminalKind::FunctionTypeAttribute,
                            67 => NonterminalKind::FunctionTypeAttributes,
                            68 => NonterminalKind::HexNumberExpression,
                            69 => NonterminalKind::HexStringLiteral,
                            70 => NonterminalKind::HexStringLiterals,
                            71 => NonterminalKind::IdentifierPath,
                            72 => NonterminalKind::IfStatement,
                            73 => NonterminalKind::ImportAlias,
                            74 => NonterminalKind::ImportClause,
                            75 => NonterminalKind::ImportDeconstruction,
                            76 => NonterminalKind::ImportDeconstructionSymbol,
                            77 => NonterminalKind::ImportDeconstructionSymbols,
                            78 => NonterminalKind::ImportDirective,
                            79 => NonterminalKind::IndexAccessEnd,
                            80 => NonterminalKind::IndexAccessExpression,
                            81 => NonterminalKind::InheritanceSpecifier,
                            82 => NonterminalKind::InheritanceType,
                            83 => NonterminalKind::InheritanceTypes,
                            84 => NonterminalKind::InterfaceDefinition,
                            85 => NonterminalKind::InterfaceMembers,
                            86 => NonterminalKind::LibraryDefinition,
                            87 => NonterminalKind::LibraryMembers,
                            88 => NonterminalKind::MappingKey,
                            89 => NonterminalKind::MappingKeyType,
                            90 => NonterminalKind::MappingType,
                            91 => NonterminalKind::MappingValue,
                            92 => NonterminalKind::MemberAccessExpression,
                            93 => NonterminalKind::ModifierAttribute,
                            94 => NonterminalKind::ModifierAttributes,
                            95 => NonterminalKind::ModifierDefinition,
                            96 => NonterminalKind::ModifierInvocation,
                            97 => NonterminalKind::MultiplicativeExpression,
                            98 => NonterminalKind::NamedArgument,
                            99 => NonterminalKind::NamedArgumentGroup,
                            100 => NonterminalKind::NamedArguments,
                            101 => NonterminalKind::NamedArgumentsDeclaration,
                            102 => NonterminalKind::NamedImport,
                            103 => NonterminalKind::NewExpression,
                            104 => NonterminalKind::NumberUnit,
                            105 => NonterminalKind::OrExpression,
                            106 => NonterminalKind::OverridePaths,
                            107 => NonterminalKind::OverridePathsDeclaration,
                            108 => NonterminalKind::OverrideSpecifier,
                            109 => NonterminalKind::Parameter,
                            110 => NonterminalKind::Parameters,
                            111 => NonterminalKind::ParametersDeclaration,
                            112 => NonterminalKind::PathImport,
                            113 => NonterminalKind::PositionalArguments,
                            114 => NonterminalKind::PositionalArgumentsDeclaration,
                            115 => NonterminalKind::PostfixExpression,
                            116 => NonterminalKind::Pragma,
                            117 => NonterminalKind::PragmaDirective,
                            118 => NonterminalKind::PrefixExpression,
                            119 => NonterminalKind::ReceiveFunctionAttribute,
                            120 => NonterminalKind::ReceiveFunctionAttributes,
                            121 => NonterminalKind::ReceiveFunctionDefinition,
                            122 => NonterminalKind::ReturnStatement,
                            123 => NonterminalKind::ReturnsDeclaration,
                            124 => NonterminalKind::RevertStatement,
                            125 => NonterminalKind::ShiftExpression,
                            126 => NonterminalKind::SourceUnit,
                            127 => NonterminalKind::SourceUnitMember,
                            128 => NonterminalKind::SourceUnitMembers,
                            129 => NonterminalKind::StateVariableAttribute,
                            130 => NonterminalKind::StateVariableAttributes,
                            131 => NonterminalKind::StateVariableDefinition,
                            132 => NonterminalKind::StateVariableDefinitionValue,
                            133 => NonterminalKind::Statement,
                            134 => NonterminalKind::Statements,
                            135 => NonterminalKind::StorageLocation,
                            136 => NonterminalKind::StringExpression,
                            137 => NonterminalKind::StringLiteral,
                            138 => NonterminalKind::StringLiterals,
                            139 => NonterminalKind::StructDefinition,
                            140 => NonterminalKind::StructMember,
                            141 => NonterminalKind::StructMembers,
                            142 => NonterminalKind::ThrowStatement,
                            143 => NonterminalKind::TryStatement,
                            144 => NonterminalKind::TupleDeconstructionElement,
                            145 => NonterminalKind::TupleDeconstructionElements,
                            146 => NonterminalKind::TupleDeconstructionStatement,
                            147 => NonterminalKind::TupleExpression,
                            148 => NonterminalKind::TupleMember,
                            149 => NonterminalKind::TupleValue,
                            150 => NonterminalKind::TupleValues,
                            151 => NonterminalKind::TypeExpression,
                            152 => NonterminalKind::TypeName,
                            153 => NonterminalKind::TypedTupleMember,
                            154 => NonterminalKind::UncheckedBlock,
                            155 => NonterminalKind::UnicodeStringLiteral,
                            156 => NonterminalKind::UnicodeStringLiterals,
                            157 => NonterminalKind::UnnamedFunctionAttribute,
                            158 => NonterminalKind::UnnamedFunctionAttributes,
                            159 => NonterminalKind::UnnamedFunctionDefinition,
                            160 => NonterminalKind::UntypedTupleMember,
                            161 => NonterminalKind::UserDefinedValueTypeDefinition,
                            162 => NonterminalKind::UsingAlias,
                            163 => NonterminalKind::UsingClause,
                            164 => NonterminalKind::UsingDeconstruction,
                            165 => NonterminalKind::UsingDeconstructionSymbol,
                            166 => NonterminalKind::UsingDeconstructionSymbols,
                            167 => NonterminalKind::UsingDirective,
                            168 => NonterminalKind::UsingOperator,
                            169 => NonterminalKind::UsingTarget,
                            170 => NonterminalKind::VariableDeclarationStatement,
                            171 => NonterminalKind::VariableDeclarationType,
                            172 => NonterminalKind::VariableDeclarationValue,
                            173 => NonterminalKind::VersionComparator,
                            174 => NonterminalKind::VersionExpression,
                            175 => NonterminalKind::VersionExpressionSet,
                            176 => NonterminalKind::VersionExpressionSets,
                            177 => NonterminalKind::VersionPragma,
                            178 => NonterminalKind::VersionRange,
                            179 => NonterminalKind::VersionSpecifiers,
                            180 => NonterminalKind::WhileStatement,
                            181 => NonterminalKind::YulArguments,
                            182 => NonterminalKind::YulAssignmentOperator,
                            183 => NonterminalKind::YulBlock,
                            184 => NonterminalKind::YulBreakStatement,
                            185 => NonterminalKind::YulBuiltInFunction,
                            186 => NonterminalKind::YulColonAndEqual,
                            187 => NonterminalKind::YulContinueStatement,
                            188 => NonterminalKind::YulDefaultCase,
                            189 => NonterminalKind::YulEqualAndColon,
                            190 => NonterminalKind::YulExpression,
                            191 => NonterminalKind::YulForStatement,
                            192 => NonterminalKind::YulFunctionCallExpression,
                            193 => NonterminalKind::YulFunctionDefinition,
                            194 => NonterminalKind::YulIfStatement,
                            195 => NonterminalKind::YulLabel,
                            196 => NonterminalKind::YulLeaveStatement,
                            197 => NonterminalKind::YulLiteral,
                            198 => NonterminalKind::YulParameters,
                            199 => NonterminalKind::YulParametersDeclaration,
                            200 => NonterminalKind::YulPath,
                            201 => NonterminalKind::YulPathComponent,
                            202 => NonterminalKind::YulPaths,
                            203 => NonterminalKind::YulReturnsDeclaration,
                            204 => NonterminalKind::YulStackAssignmentOperator,
                            205 => NonterminalKind::YulStackAssignmentStatement,
                            206 => NonterminalKind::YulStatement,
                            207 => NonterminalKind::YulStatements,
                            208 => NonterminalKind::YulSwitchCase,
                            209 => NonterminalKind::YulSwitchCases,
                            210 => NonterminalKind::YulSwitchStatement,
                            211 => NonterminalKind::YulValueCase,
                            212 => NonterminalKind::YulVariableAssignmentStatement,
                            213 => NonterminalKind::YulVariableDeclarationStatement,
                            214 => NonterminalKind::YulVariableDeclarationValue,
                            215 => NonterminalKind::YulVariableNames,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum EdgeLabel {
                    /// Built-in:
                    Item,
                    Variant,
                    Separator,
                    Operand,
                    LeftOperand,
                    RightOperand,
                    LeadingTrivia,
                    TrailingTrivia,
                    /// Generated:
                    AbicoderKeyword,
                    AbstractKeyword,
                    AddressKeyword,
                    Alias,
                    AnonymousKeyword,
                    Arguments,
                    AsKeyword,
                    AssemblyKeyword,
                    Assignment,
                    Asterisk,
                    Attributes,
                    Block,
                    Body,
                    BreakKeyword,
                    CaseKeyword,
                    Cases,
                    CatchClauses,
                    CatchKeyword,
                    Clause,
                    CloseBrace,
                    CloseBracket,
                    CloseParen,
                    Colon,
                    Condition,
                    ConstantKeyword,
                    ConstructorKeyword,
                    ContinueKeyword,
                    ContractKeyword,
                    DefaultKeyword,
                    DoKeyword,
                    Elements,
                    ElseBranch,
                    ElseKeyword,
                    EmitKeyword,
                    End,
                    EnumKeyword,
                    Equal,
                    EqualGreaterThan,
                    Error,
                    ErrorKeyword,
                    Event,
                    EventKeyword,
                    ExperimentalKeyword,
                    Expression,
                    FallbackKeyword,
                    FalseExpression,
                    Feature,
                    Flags,
                    ForKeyword,
                    FromKeyword,
                    FunctionKeyword,
                    GlobalKeyword,
                    Identifier,
                    IfKeyword,
                    ImportKeyword,
                    Index,
                    IndexedKeyword,
                    Inheritance,
                    Initialization,
                    InterfaceKeyword,
                    IsKeyword,
                    Items,
                    Iterator,
                    KeyType,
                    Label,
                    LeaveKeyword,
                    LetKeyword,
                    LibraryKeyword,
                    Literal,
                    MappingKeyword,
                    Member,
                    Members,
                    MinusGreaterThan,
                    ModifierKeyword,
                    Name,
                    NewKeyword,
                    OpenBrace,
                    OpenBracket,
                    OpenParen,
                    Operator,
                    Options,
                    Overridden,
                    OverrideKeyword,
                    Parameters,
                    Path,
                    Paths,
                    PayableKeyword,
                    Period,
                    Pragma,
                    PragmaKeyword,
                    QuestionMark,
                    ReceiveKeyword,
                    ReturnKeyword,
                    Returns,
                    ReturnsKeyword,
                    RevertKeyword,
                    Semicolon,
                    Sets,
                    SolidityKeyword,
                    Start,
                    Statements,
                    StorageLocation,
                    StructKeyword,
                    SwitchKeyword,
                    Symbols,
                    Target,
                    ThrowKeyword,
                    TrueExpression,
                    TryKeyword,
                    TypeKeyword,
                    TypeName,
                    Types,
                    UncheckedKeyword,
                    Unit,
                    UsingKeyword,
                    Value,
                    ValueType,
                    VarKeyword,
                    Variable,
                    VariableType,
                    Variables,
                    Version,
                    WhileKeyword,
                }
                impl ::core::fmt::Debug for EdgeLabel {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            EdgeLabel::Item => f.debug_tuple("EdgeLabel::Item").finish(),
                            EdgeLabel::Variant => f.debug_tuple("EdgeLabel::Variant").finish(),
                            EdgeLabel::Separator => f.debug_tuple("EdgeLabel::Separator").finish(),
                            EdgeLabel::Operand => f.debug_tuple("EdgeLabel::Operand").finish(),
                            EdgeLabel::LeftOperand => {
                                f.debug_tuple("EdgeLabel::LeftOperand").finish()
                            }
                            EdgeLabel::RightOperand => {
                                f.debug_tuple("EdgeLabel::RightOperand").finish()
                            }
                            EdgeLabel::LeadingTrivia => {
                                f.debug_tuple("EdgeLabel::LeadingTrivia").finish()
                            }
                            EdgeLabel::TrailingTrivia => {
                                f.debug_tuple("EdgeLabel::TrailingTrivia").finish()
                            }
                            EdgeLabel::AbicoderKeyword => {
                                f.debug_tuple("EdgeLabel::AbicoderKeyword").finish()
                            }
                            EdgeLabel::AbstractKeyword => {
                                f.debug_tuple("EdgeLabel::AbstractKeyword").finish()
                            }
                            EdgeLabel::AddressKeyword => {
                                f.debug_tuple("EdgeLabel::AddressKeyword").finish()
                            }
                            EdgeLabel::Alias => f.debug_tuple("EdgeLabel::Alias").finish(),
                            EdgeLabel::AnonymousKeyword => {
                                f.debug_tuple("EdgeLabel::AnonymousKeyword").finish()
                            }
                            EdgeLabel::Arguments => f.debug_tuple("EdgeLabel::Arguments").finish(),
                            EdgeLabel::AsKeyword => f.debug_tuple("EdgeLabel::AsKeyword").finish(),
                            EdgeLabel::AssemblyKeyword => {
                                f.debug_tuple("EdgeLabel::AssemblyKeyword").finish()
                            }
                            EdgeLabel::Assignment => {
                                f.debug_tuple("EdgeLabel::Assignment").finish()
                            }
                            EdgeLabel::Asterisk => f.debug_tuple("EdgeLabel::Asterisk").finish(),
                            EdgeLabel::Attributes => {
                                f.debug_tuple("EdgeLabel::Attributes").finish()
                            }
                            EdgeLabel::Block => f.debug_tuple("EdgeLabel::Block").finish(),
                            EdgeLabel::Body => f.debug_tuple("EdgeLabel::Body").finish(),
                            EdgeLabel::BreakKeyword => {
                                f.debug_tuple("EdgeLabel::BreakKeyword").finish()
                            }
                            EdgeLabel::CaseKeyword => {
                                f.debug_tuple("EdgeLabel::CaseKeyword").finish()
                            }
                            EdgeLabel::Cases => f.debug_tuple("EdgeLabel::Cases").finish(),
                            EdgeLabel::CatchClauses => {
                                f.debug_tuple("EdgeLabel::CatchClauses").finish()
                            }
                            EdgeLabel::CatchKeyword => {
                                f.debug_tuple("EdgeLabel::CatchKeyword").finish()
                            }
                            EdgeLabel::Clause => f.debug_tuple("EdgeLabel::Clause").finish(),
                            EdgeLabel::CloseBrace => {
                                f.debug_tuple("EdgeLabel::CloseBrace").finish()
                            }
                            EdgeLabel::CloseBracket => {
                                f.debug_tuple("EdgeLabel::CloseBracket").finish()
                            }
                            EdgeLabel::CloseParen => {
                                f.debug_tuple("EdgeLabel::CloseParen").finish()
                            }
                            EdgeLabel::Colon => f.debug_tuple("EdgeLabel::Colon").finish(),
                            EdgeLabel::Condition => f.debug_tuple("EdgeLabel::Condition").finish(),
                            EdgeLabel::ConstantKeyword => {
                                f.debug_tuple("EdgeLabel::ConstantKeyword").finish()
                            }
                            EdgeLabel::ConstructorKeyword => {
                                f.debug_tuple("EdgeLabel::ConstructorKeyword").finish()
                            }
                            EdgeLabel::ContinueKeyword => {
                                f.debug_tuple("EdgeLabel::ContinueKeyword").finish()
                            }
                            EdgeLabel::ContractKeyword => {
                                f.debug_tuple("EdgeLabel::ContractKeyword").finish()
                            }
                            EdgeLabel::DefaultKeyword => {
                                f.debug_tuple("EdgeLabel::DefaultKeyword").finish()
                            }
                            EdgeLabel::DoKeyword => f.debug_tuple("EdgeLabel::DoKeyword").finish(),
                            EdgeLabel::Elements => f.debug_tuple("EdgeLabel::Elements").finish(),
                            EdgeLabel::ElseBranch => {
                                f.debug_tuple("EdgeLabel::ElseBranch").finish()
                            }
                            EdgeLabel::ElseKeyword => {
                                f.debug_tuple("EdgeLabel::ElseKeyword").finish()
                            }
                            EdgeLabel::EmitKeyword => {
                                f.debug_tuple("EdgeLabel::EmitKeyword").finish()
                            }
                            EdgeLabel::End => f.debug_tuple("EdgeLabel::End").finish(),
                            EdgeLabel::EnumKeyword => {
                                f.debug_tuple("EdgeLabel::EnumKeyword").finish()
                            }
                            EdgeLabel::Equal => f.debug_tuple("EdgeLabel::Equal").finish(),
                            EdgeLabel::EqualGreaterThan => {
                                f.debug_tuple("EdgeLabel::EqualGreaterThan").finish()
                            }
                            EdgeLabel::Error => f.debug_tuple("EdgeLabel::Error").finish(),
                            EdgeLabel::ErrorKeyword => {
                                f.debug_tuple("EdgeLabel::ErrorKeyword").finish()
                            }
                            EdgeLabel::Event => f.debug_tuple("EdgeLabel::Event").finish(),
                            EdgeLabel::EventKeyword => {
                                f.debug_tuple("EdgeLabel::EventKeyword").finish()
                            }
                            EdgeLabel::ExperimentalKeyword => {
                                f.debug_tuple("EdgeLabel::ExperimentalKeyword").finish()
                            }
                            EdgeLabel::Expression => {
                                f.debug_tuple("EdgeLabel::Expression").finish()
                            }
                            EdgeLabel::FallbackKeyword => {
                                f.debug_tuple("EdgeLabel::FallbackKeyword").finish()
                            }
                            EdgeLabel::FalseExpression => {
                                f.debug_tuple("EdgeLabel::FalseExpression").finish()
                            }
                            EdgeLabel::Feature => f.debug_tuple("EdgeLabel::Feature").finish(),
                            EdgeLabel::Flags => f.debug_tuple("EdgeLabel::Flags").finish(),
                            EdgeLabel::ForKeyword => {
                                f.debug_tuple("EdgeLabel::ForKeyword").finish()
                            }
                            EdgeLabel::FromKeyword => {
                                f.debug_tuple("EdgeLabel::FromKeyword").finish()
                            }
                            EdgeLabel::FunctionKeyword => {
                                f.debug_tuple("EdgeLabel::FunctionKeyword").finish()
                            }
                            EdgeLabel::GlobalKeyword => {
                                f.debug_tuple("EdgeLabel::GlobalKeyword").finish()
                            }
                            EdgeLabel::Identifier => {
                                f.debug_tuple("EdgeLabel::Identifier").finish()
                            }
                            EdgeLabel::IfKeyword => f.debug_tuple("EdgeLabel::IfKeyword").finish(),
                            EdgeLabel::ImportKeyword => {
                                f.debug_tuple("EdgeLabel::ImportKeyword").finish()
                            }
                            EdgeLabel::Index => f.debug_tuple("EdgeLabel::Index").finish(),
                            EdgeLabel::IndexedKeyword => {
                                f.debug_tuple("EdgeLabel::IndexedKeyword").finish()
                            }
                            EdgeLabel::Inheritance => {
                                f.debug_tuple("EdgeLabel::Inheritance").finish()
                            }
                            EdgeLabel::Initialization => {
                                f.debug_tuple("EdgeLabel::Initialization").finish()
                            }
                            EdgeLabel::InterfaceKeyword => {
                                f.debug_tuple("EdgeLabel::InterfaceKeyword").finish()
                            }
                            EdgeLabel::IsKeyword => f.debug_tuple("EdgeLabel::IsKeyword").finish(),
                            EdgeLabel::Items => f.debug_tuple("EdgeLabel::Items").finish(),
                            EdgeLabel::Iterator => f.debug_tuple("EdgeLabel::Iterator").finish(),
                            EdgeLabel::KeyType => f.debug_tuple("EdgeLabel::KeyType").finish(),
                            EdgeLabel::Label => f.debug_tuple("EdgeLabel::Label").finish(),
                            EdgeLabel::LeaveKeyword => {
                                f.debug_tuple("EdgeLabel::LeaveKeyword").finish()
                            }
                            EdgeLabel::LetKeyword => {
                                f.debug_tuple("EdgeLabel::LetKeyword").finish()
                            }
                            EdgeLabel::LibraryKeyword => {
                                f.debug_tuple("EdgeLabel::LibraryKeyword").finish()
                            }
                            EdgeLabel::Literal => f.debug_tuple("EdgeLabel::Literal").finish(),
                            EdgeLabel::MappingKeyword => {
                                f.debug_tuple("EdgeLabel::MappingKeyword").finish()
                            }
                            EdgeLabel::Member => f.debug_tuple("EdgeLabel::Member").finish(),
                            EdgeLabel::Members => f.debug_tuple("EdgeLabel::Members").finish(),
                            EdgeLabel::MinusGreaterThan => {
                                f.debug_tuple("EdgeLabel::MinusGreaterThan").finish()
                            }
                            EdgeLabel::ModifierKeyword => {
                                f.debug_tuple("EdgeLabel::ModifierKeyword").finish()
                            }
                            EdgeLabel::Name => f.debug_tuple("EdgeLabel::Name").finish(),
                            EdgeLabel::NewKeyword => {
                                f.debug_tuple("EdgeLabel::NewKeyword").finish()
                            }
                            EdgeLabel::OpenBrace => f.debug_tuple("EdgeLabel::OpenBrace").finish(),
                            EdgeLabel::OpenBracket => {
                                f.debug_tuple("EdgeLabel::OpenBracket").finish()
                            }
                            EdgeLabel::OpenParen => f.debug_tuple("EdgeLabel::OpenParen").finish(),
                            EdgeLabel::Operator => f.debug_tuple("EdgeLabel::Operator").finish(),
                            EdgeLabel::Options => f.debug_tuple("EdgeLabel::Options").finish(),
                            EdgeLabel::Overridden => {
                                f.debug_tuple("EdgeLabel::Overridden").finish()
                            }
                            EdgeLabel::OverrideKeyword => {
                                f.debug_tuple("EdgeLabel::OverrideKeyword").finish()
                            }
                            EdgeLabel::Parameters => {
                                f.debug_tuple("EdgeLabel::Parameters").finish()
                            }
                            EdgeLabel::Path => f.debug_tuple("EdgeLabel::Path").finish(),
                            EdgeLabel::Paths => f.debug_tuple("EdgeLabel::Paths").finish(),
                            EdgeLabel::PayableKeyword => {
                                f.debug_tuple("EdgeLabel::PayableKeyword").finish()
                            }
                            EdgeLabel::Period => f.debug_tuple("EdgeLabel::Period").finish(),
                            EdgeLabel::Pragma => f.debug_tuple("EdgeLabel::Pragma").finish(),
                            EdgeLabel::PragmaKeyword => {
                                f.debug_tuple("EdgeLabel::PragmaKeyword").finish()
                            }
                            EdgeLabel::QuestionMark => {
                                f.debug_tuple("EdgeLabel::QuestionMark").finish()
                            }
                            EdgeLabel::ReceiveKeyword => {
                                f.debug_tuple("EdgeLabel::ReceiveKeyword").finish()
                            }
                            EdgeLabel::ReturnKeyword => {
                                f.debug_tuple("EdgeLabel::ReturnKeyword").finish()
                            }
                            EdgeLabel::Returns => f.debug_tuple("EdgeLabel::Returns").finish(),
                            EdgeLabel::ReturnsKeyword => {
                                f.debug_tuple("EdgeLabel::ReturnsKeyword").finish()
                            }
                            EdgeLabel::RevertKeyword => {
                                f.debug_tuple("EdgeLabel::RevertKeyword").finish()
                            }
                            EdgeLabel::Semicolon => f.debug_tuple("EdgeLabel::Semicolon").finish(),
                            EdgeLabel::Sets => f.debug_tuple("EdgeLabel::Sets").finish(),
                            EdgeLabel::SolidityKeyword => {
                                f.debug_tuple("EdgeLabel::SolidityKeyword").finish()
                            }
                            EdgeLabel::Start => f.debug_tuple("EdgeLabel::Start").finish(),
                            EdgeLabel::Statements => {
                                f.debug_tuple("EdgeLabel::Statements").finish()
                            }
                            EdgeLabel::StorageLocation => {
                                f.debug_tuple("EdgeLabel::StorageLocation").finish()
                            }
                            EdgeLabel::StructKeyword => {
                                f.debug_tuple("EdgeLabel::StructKeyword").finish()
                            }
                            EdgeLabel::SwitchKeyword => {
                                f.debug_tuple("EdgeLabel::SwitchKeyword").finish()
                            }
                            EdgeLabel::Symbols => f.debug_tuple("EdgeLabel::Symbols").finish(),
                            EdgeLabel::Target => f.debug_tuple("EdgeLabel::Target").finish(),
                            EdgeLabel::ThrowKeyword => {
                                f.debug_tuple("EdgeLabel::ThrowKeyword").finish()
                            }
                            EdgeLabel::TrueExpression => {
                                f.debug_tuple("EdgeLabel::TrueExpression").finish()
                            }
                            EdgeLabel::TryKeyword => {
                                f.debug_tuple("EdgeLabel::TryKeyword").finish()
                            }
                            EdgeLabel::TypeKeyword => {
                                f.debug_tuple("EdgeLabel::TypeKeyword").finish()
                            }
                            EdgeLabel::TypeName => f.debug_tuple("EdgeLabel::TypeName").finish(),
                            EdgeLabel::Types => f.debug_tuple("EdgeLabel::Types").finish(),
                            EdgeLabel::UncheckedKeyword => {
                                f.debug_tuple("EdgeLabel::UncheckedKeyword").finish()
                            }
                            EdgeLabel::Unit => f.debug_tuple("EdgeLabel::Unit").finish(),
                            EdgeLabel::UsingKeyword => {
                                f.debug_tuple("EdgeLabel::UsingKeyword").finish()
                            }
                            EdgeLabel::Value => f.debug_tuple("EdgeLabel::Value").finish(),
                            EdgeLabel::ValueType => f.debug_tuple("EdgeLabel::ValueType").finish(),
                            EdgeLabel::VarKeyword => {
                                f.debug_tuple("EdgeLabel::VarKeyword").finish()
                            }
                            EdgeLabel::Variable => f.debug_tuple("EdgeLabel::Variable").finish(),
                            EdgeLabel::VariableType => {
                                f.debug_tuple("EdgeLabel::VariableType").finish()
                            }
                            EdgeLabel::Variables => f.debug_tuple("EdgeLabel::Variables").finish(),
                            EdgeLabel::Version => f.debug_tuple("EdgeLabel::Version").finish(),
                            EdgeLabel::WhileKeyword => {
                                f.debug_tuple("EdgeLabel::WhileKeyword").finish()
                            }
                        }
                    }
                }

                impl EdgeLabel {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> EdgeLabel {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => EdgeLabel::Item,
                            1 => EdgeLabel::Variant,
                            2 => EdgeLabel::Separator,
                            3 => EdgeLabel::Operand,
                            4 => EdgeLabel::LeftOperand,
                            5 => EdgeLabel::RightOperand,
                            6 => EdgeLabel::LeadingTrivia,
                            7 => EdgeLabel::TrailingTrivia,
                            8 => EdgeLabel::AbicoderKeyword,
                            9 => EdgeLabel::AbstractKeyword,
                            10 => EdgeLabel::AddressKeyword,
                            11 => EdgeLabel::Alias,
                            12 => EdgeLabel::AnonymousKeyword,
                            13 => EdgeLabel::Arguments,
                            14 => EdgeLabel::AsKeyword,
                            15 => EdgeLabel::AssemblyKeyword,
                            16 => EdgeLabel::Assignment,
                            17 => EdgeLabel::Asterisk,
                            18 => EdgeLabel::Attributes,
                            19 => EdgeLabel::Block,
                            20 => EdgeLabel::Body,
                            21 => EdgeLabel::BreakKeyword,
                            22 => EdgeLabel::CaseKeyword,
                            23 => EdgeLabel::Cases,
                            24 => EdgeLabel::CatchClauses,
                            25 => EdgeLabel::CatchKeyword,
                            26 => EdgeLabel::Clause,
                            27 => EdgeLabel::CloseBrace,
                            28 => EdgeLabel::CloseBracket,
                            29 => EdgeLabel::CloseParen,
                            30 => EdgeLabel::Colon,
                            31 => EdgeLabel::Condition,
                            32 => EdgeLabel::ConstantKeyword,
                            33 => EdgeLabel::ConstructorKeyword,
                            34 => EdgeLabel::ContinueKeyword,
                            35 => EdgeLabel::ContractKeyword,
                            36 => EdgeLabel::DefaultKeyword,
                            37 => EdgeLabel::DoKeyword,
                            38 => EdgeLabel::Elements,
                            39 => EdgeLabel::ElseBranch,
                            40 => EdgeLabel::ElseKeyword,
                            41 => EdgeLabel::EmitKeyword,
                            42 => EdgeLabel::End,
                            43 => EdgeLabel::EnumKeyword,
                            44 => EdgeLabel::Equal,
                            45 => EdgeLabel::EqualGreaterThan,
                            46 => EdgeLabel::Error,
                            47 => EdgeLabel::ErrorKeyword,
                            48 => EdgeLabel::Event,
                            49 => EdgeLabel::EventKeyword,
                            50 => EdgeLabel::ExperimentalKeyword,
                            51 => EdgeLabel::Expression,
                            52 => EdgeLabel::FallbackKeyword,
                            53 => EdgeLabel::FalseExpression,
                            54 => EdgeLabel::Feature,
                            55 => EdgeLabel::Flags,
                            56 => EdgeLabel::ForKeyword,
                            57 => EdgeLabel::FromKeyword,
                            58 => EdgeLabel::FunctionKeyword,
                            59 => EdgeLabel::GlobalKeyword,
                            60 => EdgeLabel::Identifier,
                            61 => EdgeLabel::IfKeyword,
                            62 => EdgeLabel::ImportKeyword,
                            63 => EdgeLabel::Index,
                            64 => EdgeLabel::IndexedKeyword,
                            65 => EdgeLabel::Inheritance,
                            66 => EdgeLabel::Initialization,
                            67 => EdgeLabel::InterfaceKeyword,
                            68 => EdgeLabel::IsKeyword,
                            69 => EdgeLabel::Items,
                            70 => EdgeLabel::Iterator,
                            71 => EdgeLabel::KeyType,
                            72 => EdgeLabel::Label,
                            73 => EdgeLabel::LeaveKeyword,
                            74 => EdgeLabel::LetKeyword,
                            75 => EdgeLabel::LibraryKeyword,
                            76 => EdgeLabel::Literal,
                            77 => EdgeLabel::MappingKeyword,
                            78 => EdgeLabel::Member,
                            79 => EdgeLabel::Members,
                            80 => EdgeLabel::MinusGreaterThan,
                            81 => EdgeLabel::ModifierKeyword,
                            82 => EdgeLabel::Name,
                            83 => EdgeLabel::NewKeyword,
                            84 => EdgeLabel::OpenBrace,
                            85 => EdgeLabel::OpenBracket,
                            86 => EdgeLabel::OpenParen,
                            87 => EdgeLabel::Operator,
                            88 => EdgeLabel::Options,
                            89 => EdgeLabel::Overridden,
                            90 => EdgeLabel::OverrideKeyword,
                            91 => EdgeLabel::Parameters,
                            92 => EdgeLabel::Path,
                            93 => EdgeLabel::Paths,
                            94 => EdgeLabel::PayableKeyword,
                            95 => EdgeLabel::Period,
                            96 => EdgeLabel::Pragma,
                            97 => EdgeLabel::PragmaKeyword,
                            98 => EdgeLabel::QuestionMark,
                            99 => EdgeLabel::ReceiveKeyword,
                            100 => EdgeLabel::ReturnKeyword,
                            101 => EdgeLabel::Returns,
                            102 => EdgeLabel::ReturnsKeyword,
                            103 => EdgeLabel::RevertKeyword,
                            104 => EdgeLabel::Semicolon,
                            105 => EdgeLabel::Sets,
                            106 => EdgeLabel::SolidityKeyword,
                            107 => EdgeLabel::Start,
                            108 => EdgeLabel::Statements,
                            109 => EdgeLabel::StorageLocation,
                            110 => EdgeLabel::StructKeyword,
                            111 => EdgeLabel::SwitchKeyword,
                            112 => EdgeLabel::Symbols,
                            113 => EdgeLabel::Target,
                            114 => EdgeLabel::ThrowKeyword,
                            115 => EdgeLabel::TrueExpression,
                            116 => EdgeLabel::TryKeyword,
                            117 => EdgeLabel::TypeKeyword,
                            118 => EdgeLabel::TypeName,
                            119 => EdgeLabel::Types,
                            120 => EdgeLabel::UncheckedKeyword,
                            121 => EdgeLabel::Unit,
                            122 => EdgeLabel::UsingKeyword,
                            123 => EdgeLabel::Value,
                            124 => EdgeLabel::ValueType,
                            125 => EdgeLabel::VarKeyword,
                            126 => EdgeLabel::Variable,
                            127 => EdgeLabel::VariableType,
                            128 => EdgeLabel::Variables,
                            129 => EdgeLabel::Version,
                            130 => EdgeLabel::WhileKeyword,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[repr(u16)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum TerminalKind {
                    /// Built-in:
                    Skipped,
                    /// Generated:
                    AbicoderKeyword,
                    AbstractKeyword,
                    AddressKeyword,
                    AfterKeyword,
                    AliasKeyword,
                    Ampersand,
                    AmpersandAmpersand,
                    AmpersandEqual,
                    AnonymousKeyword,
                    ApplyKeyword,
                    AsKeyword,
                    AssemblyKeyword,
                    Asterisk,
                    AsteriskAsterisk,
                    AsteriskEqual,
                    AutoKeyword,
                    Bang,
                    BangEqual,
                    Bar,
                    BarBar,
                    BarEqual,
                    BoolKeyword,
                    BreakKeyword,
                    ByteKeyword,
                    BytesKeyword,
                    CallDataKeyword,
                    Caret,
                    CaretEqual,
                    CaseKeyword,
                    CatchKeyword,
                    CloseBrace,
                    CloseBracket,
                    CloseParen,
                    Colon,
                    ColonEqual,
                    Comma,
                    ConstantKeyword,
                    ConstructorKeyword,
                    ContinueKeyword,
                    ContractKeyword,
                    CopyOfKeyword,
                    DaysKeyword,
                    DecimalLiteral,
                    DefaultKeyword,
                    DefineKeyword,
                    DeleteKeyword,
                    DoKeyword,
                    DoubleQuotedHexStringLiteral,
                    DoubleQuotedStringLiteral,
                    DoubleQuotedUnicodeStringLiteral,
                    DoubleQuotedVersionLiteral,
                    ElseKeyword,
                    EmitKeyword,
                    EndOfLine,
                    EnumKeyword,
                    Equal,
                    EqualColon,
                    EqualEqual,
                    EqualGreaterThan,
                    ErrorKeyword,
                    EtherKeyword,
                    EventKeyword,
                    ExperimentalKeyword,
                    ExternalKeyword,
                    FallbackKeyword,
                    FalseKeyword,
                    FinalKeyword,
                    FinneyKeyword,
                    FixedKeyword,
                    ForKeyword,
                    FromKeyword,
                    FunctionKeyword,
                    GlobalKeyword,
                    GreaterThan,
                    GreaterThanEqual,
                    GreaterThanGreaterThan,
                    GreaterThanGreaterThanEqual,
                    GreaterThanGreaterThanGreaterThan,
                    GreaterThanGreaterThanGreaterThanEqual,
                    GweiKeyword,
                    HexKeyword,
                    HexLiteral,
                    HoursKeyword,
                    Identifier,
                    IfKeyword,
                    ImmutableKeyword,
                    ImplementsKeyword,
                    ImportKeyword,
                    InKeyword,
                    IndexedKeyword,
                    InlineKeyword,
                    IntKeyword,
                    InterfaceKeyword,
                    InternalKeyword,
                    IsKeyword,
                    LessThan,
                    LessThanEqual,
                    LessThanLessThan,
                    LessThanLessThanEqual,
                    LetKeyword,
                    LibraryKeyword,
                    MacroKeyword,
                    MappingKeyword,
                    MatchKeyword,
                    MemoryKeyword,
                    Minus,
                    MinusEqual,
                    MinusGreaterThan,
                    MinusMinus,
                    MinutesKeyword,
                    ModifierKeyword,
                    MultiLineComment,
                    MultiLineNatSpecComment,
                    MutableKeyword,
                    NewKeyword,
                    NullKeyword,
                    OfKeyword,
                    OpenBrace,
                    OpenBracket,
                    OpenParen,
                    OverrideKeyword,
                    PartialKeyword,
                    PayableKeyword,
                    Percent,
                    PercentEqual,
                    Period,
                    Plus,
                    PlusEqual,
                    PlusPlus,
                    PragmaKeyword,
                    PrivateKeyword,
                    PromiseKeyword,
                    PublicKeyword,
                    PureKeyword,
                    QuestionMark,
                    ReceiveKeyword,
                    ReferenceKeyword,
                    RelocatableKeyword,
                    ReturnKeyword,
                    ReturnsKeyword,
                    RevertKeyword,
                    SealedKeyword,
                    SecondsKeyword,
                    Semicolon,
                    SingleLineComment,
                    SingleLineNatSpecComment,
                    SingleQuotedHexStringLiteral,
                    SingleQuotedStringLiteral,
                    SingleQuotedUnicodeStringLiteral,
                    SingleQuotedVersionLiteral,
                    SizeOfKeyword,
                    Slash,
                    SlashEqual,
                    SolidityKeyword,
                    StaticKeyword,
                    StorageKeyword,
                    StringKeyword,
                    StructKeyword,
                    SupportsKeyword,
                    SwitchKeyword,
                    SzaboKeyword,
                    ThrowKeyword,
                    Tilde,
                    TrueKeyword,
                    TryKeyword,
                    TypeDefKeyword,
                    TypeKeyword,
                    TypeOfKeyword,
                    UfixedKeyword,
                    UintKeyword,
                    UncheckedKeyword,
                    UsingKeyword,
                    VarKeyword,
                    VersionSpecifier,
                    ViewKeyword,
                    VirtualKeyword,
                    WeeksKeyword,
                    WeiKeyword,
                    WhileKeyword,
                    Whitespace,
                    YearsKeyword,
                    YulAbstractKeyword,
                    YulAddKeyword,
                    YulAddModKeyword,
                    YulAddressKeyword,
                    YulAfterKeyword,
                    YulAliasKeyword,
                    YulAndKeyword,
                    YulAnonymousKeyword,
                    YulApplyKeyword,
                    YulAsKeyword,
                    YulAssemblyKeyword,
                    YulAutoKeyword,
                    YulBalanceKeyword,
                    YulBaseFeeKeyword,
                    YulBlobBaseFeeKeyword,
                    YulBlobHashKeyword,
                    YulBlockHashKeyword,
                    YulBoolKeyword,
                    YulBreakKeyword,
                    YulByteKeyword,
                    YulBytesKeyword,
                    YulCallCodeKeyword,
                    YulCallDataCopyKeyword,
                    YulCallDataKeyword,
                    YulCallDataLoadKeyword,
                    YulCallDataSizeKeyword,
                    YulCallKeyword,
                    YulCallValueKeyword,
                    YulCallerKeyword,
                    YulCaseKeyword,
                    YulCatchKeyword,
                    YulChainIdKeyword,
                    YulCoinBaseKeyword,
                    YulConstantKeyword,
                    YulConstructorKeyword,
                    YulContinueKeyword,
                    YulContractKeyword,
                    YulCopyOfKeyword,
                    YulCreate2Keyword,
                    YulCreateKeyword,
                    YulDaysKeyword,
                    YulDecimalLiteral,
                    YulDefaultKeyword,
                    YulDefineKeyword,
                    YulDelegateCallKeyword,
                    YulDeleteKeyword,
                    YulDifficultyKeyword,
                    YulDivKeyword,
                    YulDoKeyword,
                    YulElseKeyword,
                    YulEmitKeyword,
                    YulEnumKeyword,
                    YulEqKeyword,
                    YulEtherKeyword,
                    YulEventKeyword,
                    YulExpKeyword,
                    YulExtCodeCopyKeyword,
                    YulExtCodeHashKeyword,
                    YulExtCodeSizeKeyword,
                    YulExternalKeyword,
                    YulFallbackKeyword,
                    YulFalseKeyword,
                    YulFinalKeyword,
                    YulFinneyKeyword,
                    YulFixedKeyword,
                    YulForKeyword,
                    YulFunctionKeyword,
                    YulGasKeyword,
                    YulGasLimitKeyword,
                    YulGasPriceKeyword,
                    YulGtKeyword,
                    YulGweiKeyword,
                    YulHexKeyword,
                    YulHexLiteral,
                    YulHoursKeyword,
                    YulIdentifier,
                    YulIfKeyword,
                    YulImmutableKeyword,
                    YulImplementsKeyword,
                    YulImportKeyword,
                    YulInKeyword,
                    YulIndexedKeyword,
                    YulInlineKeyword,
                    YulIntKeyword,
                    YulInterfaceKeyword,
                    YulInternalKeyword,
                    YulInvalidKeyword,
                    YulIsKeyword,
                    YulIsZeroKeyword,
                    YulKeccak256Keyword,
                    YulLeaveKeyword,
                    YulLetKeyword,
                    YulLibraryKeyword,
                    YulLog0Keyword,
                    YulLog1Keyword,
                    YulLog2Keyword,
                    YulLog3Keyword,
                    YulLog4Keyword,
                    YulLtKeyword,
                    YulMcopyKeyword,
                    YulMloadKeyword,
                    YulMsizeKeyword,
                    YulMstore8Keyword,
                    YulMstoreKeyword,
                    YulMacroKeyword,
                    YulMappingKeyword,
                    YulMatchKeyword,
                    YulMemoryKeyword,
                    YulMinutesKeyword,
                    YulModKeyword,
                    YulModifierKeyword,
                    YulMulKeyword,
                    YulMulModKeyword,
                    YulMutableKeyword,
                    YulNewKeyword,
                    YulNotKeyword,
                    YulNullKeyword,
                    YulNumberKeyword,
                    YulOfKeyword,
                    YulOrKeyword,
                    YulOriginKeyword,
                    YulOverrideKeyword,
                    YulPartialKeyword,
                    YulPayableKeyword,
                    YulPopKeyword,
                    YulPragmaKeyword,
                    YulPrevRandaoKeyword,
                    YulPrivateKeyword,
                    YulPromiseKeyword,
                    YulPublicKeyword,
                    YulPureKeyword,
                    YulReceiveKeyword,
                    YulReferenceKeyword,
                    YulRelocatableKeyword,
                    YulReturnDataCopyKeyword,
                    YulReturnDataSizeKeyword,
                    YulReturnKeyword,
                    YulReturnsKeyword,
                    YulRevertKeyword,
                    YulSdivKeyword,
                    YulSloadKeyword,
                    YulSmodKeyword,
                    YulSstoreKeyword,
                    YulSarKeyword,
                    YulSealedKeyword,
                    YulSecondsKeyword,
                    YulSelfBalanceKeyword,
                    YulSelfDestructKeyword,
                    YulSgtKeyword,
                    YulSha3Keyword,
                    YulShlKeyword,
                    YulShrKeyword,
                    YulSignExtendKeyword,
                    YulSizeOfKeyword,
                    YulSltKeyword,
                    YulStaticCallKeyword,
                    YulStaticKeyword,
                    YulStopKeyword,
                    YulStorageKeyword,
                    YulStringKeyword,
                    YulStructKeyword,
                    YulSubKeyword,
                    YulSuicideKeyword,
                    YulSupportsKeyword,
                    YulSwitchKeyword,
                    YulSzaboKeyword,
                    YulTloadKeyword,
                    YulTstoreKeyword,
                    YulThrowKeyword,
                    YulTimestampKeyword,
                    YulTrueKeyword,
                    YulTryKeyword,
                    YulTypeDefKeyword,
                    YulTypeKeyword,
                    YulTypeOfKeyword,
                    YulUfixedKeyword,
                    YulUintKeyword,
                    YulUncheckedKeyword,
                    YulUsingKeyword,
                    YulVarKeyword,
                    YulViewKeyword,
                    YulVirtualKeyword,
                    YulWeeksKeyword,
                    YulWeiKeyword,
                    YulWhileKeyword,
                    YulXorKeyword,
                    YulYearsKeyword,
                }
                impl ::core::fmt::Debug for TerminalKind {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            TerminalKind::Skipped => {
                                f.debug_tuple("TerminalKind::Skipped").finish()
                            }
                            TerminalKind::AbicoderKeyword => {
                                f.debug_tuple("TerminalKind::AbicoderKeyword").finish()
                            }
                            TerminalKind::AbstractKeyword => {
                                f.debug_tuple("TerminalKind::AbstractKeyword").finish()
                            }
                            TerminalKind::AddressKeyword => {
                                f.debug_tuple("TerminalKind::AddressKeyword").finish()
                            }
                            TerminalKind::AfterKeyword => {
                                f.debug_tuple("TerminalKind::AfterKeyword").finish()
                            }
                            TerminalKind::AliasKeyword => {
                                f.debug_tuple("TerminalKind::AliasKeyword").finish()
                            }
                            TerminalKind::Ampersand => {
                                f.debug_tuple("TerminalKind::Ampersand").finish()
                            }
                            TerminalKind::AmpersandAmpersand => {
                                f.debug_tuple("TerminalKind::AmpersandAmpersand").finish()
                            }
                            TerminalKind::AmpersandEqual => {
                                f.debug_tuple("TerminalKind::AmpersandEqual").finish()
                            }
                            TerminalKind::AnonymousKeyword => {
                                f.debug_tuple("TerminalKind::AnonymousKeyword").finish()
                            }
                            TerminalKind::ApplyKeyword => {
                                f.debug_tuple("TerminalKind::ApplyKeyword").finish()
                            }
                            TerminalKind::AsKeyword => {
                                f.debug_tuple("TerminalKind::AsKeyword").finish()
                            }
                            TerminalKind::AssemblyKeyword => {
                                f.debug_tuple("TerminalKind::AssemblyKeyword").finish()
                            }
                            TerminalKind::Asterisk => {
                                f.debug_tuple("TerminalKind::Asterisk").finish()
                            }
                            TerminalKind::AsteriskAsterisk => {
                                f.debug_tuple("TerminalKind::AsteriskAsterisk").finish()
                            }
                            TerminalKind::AsteriskEqual => {
                                f.debug_tuple("TerminalKind::AsteriskEqual").finish()
                            }
                            TerminalKind::AutoKeyword => {
                                f.debug_tuple("TerminalKind::AutoKeyword").finish()
                            }
                            TerminalKind::Bang => f.debug_tuple("TerminalKind::Bang").finish(),
                            TerminalKind::BangEqual => {
                                f.debug_tuple("TerminalKind::BangEqual").finish()
                            }
                            TerminalKind::Bar => f.debug_tuple("TerminalKind::Bar").finish(),
                            TerminalKind::BarBar => f.debug_tuple("TerminalKind::BarBar").finish(),
                            TerminalKind::BarEqual => {
                                f.debug_tuple("TerminalKind::BarEqual").finish()
                            }
                            TerminalKind::BoolKeyword => {
                                f.debug_tuple("TerminalKind::BoolKeyword").finish()
                            }
                            TerminalKind::BreakKeyword => {
                                f.debug_tuple("TerminalKind::BreakKeyword").finish()
                            }
                            TerminalKind::ByteKeyword => {
                                f.debug_tuple("TerminalKind::ByteKeyword").finish()
                            }
                            TerminalKind::BytesKeyword => {
                                f.debug_tuple("TerminalKind::BytesKeyword").finish()
                            }
                            TerminalKind::CallDataKeyword => {
                                f.debug_tuple("TerminalKind::CallDataKeyword").finish()
                            }
                            TerminalKind::Caret => f.debug_tuple("TerminalKind::Caret").finish(),
                            TerminalKind::CaretEqual => {
                                f.debug_tuple("TerminalKind::CaretEqual").finish()
                            }
                            TerminalKind::CaseKeyword => {
                                f.debug_tuple("TerminalKind::CaseKeyword").finish()
                            }
                            TerminalKind::CatchKeyword => {
                                f.debug_tuple("TerminalKind::CatchKeyword").finish()
                            }
                            TerminalKind::CloseBrace => {
                                f.debug_tuple("TerminalKind::CloseBrace").finish()
                            }
                            TerminalKind::CloseBracket => {
                                f.debug_tuple("TerminalKind::CloseBracket").finish()
                            }
                            TerminalKind::CloseParen => {
                                f.debug_tuple("TerminalKind::CloseParen").finish()
                            }
                            TerminalKind::Colon => f.debug_tuple("TerminalKind::Colon").finish(),
                            TerminalKind::ColonEqual => {
                                f.debug_tuple("TerminalKind::ColonEqual").finish()
                            }
                            TerminalKind::Comma => f.debug_tuple("TerminalKind::Comma").finish(),
                            TerminalKind::ConstantKeyword => {
                                f.debug_tuple("TerminalKind::ConstantKeyword").finish()
                            }
                            TerminalKind::ConstructorKeyword => {
                                f.debug_tuple("TerminalKind::ConstructorKeyword").finish()
                            }
                            TerminalKind::ContinueKeyword => {
                                f.debug_tuple("TerminalKind::ContinueKeyword").finish()
                            }
                            TerminalKind::ContractKeyword => {
                                f.debug_tuple("TerminalKind::ContractKeyword").finish()
                            }
                            TerminalKind::CopyOfKeyword => {
                                f.debug_tuple("TerminalKind::CopyOfKeyword").finish()
                            }
                            TerminalKind::DaysKeyword => {
                                f.debug_tuple("TerminalKind::DaysKeyword").finish()
                            }
                            TerminalKind::DecimalLiteral => {
                                f.debug_tuple("TerminalKind::DecimalLiteral").finish()
                            }
                            TerminalKind::DefaultKeyword => {
                                f.debug_tuple("TerminalKind::DefaultKeyword").finish()
                            }
                            TerminalKind::DefineKeyword => {
                                f.debug_tuple("TerminalKind::DefineKeyword").finish()
                            }
                            TerminalKind::DeleteKeyword => {
                                f.debug_tuple("TerminalKind::DeleteKeyword").finish()
                            }
                            TerminalKind::DoKeyword => {
                                f.debug_tuple("TerminalKind::DoKeyword").finish()
                            }
                            TerminalKind::DoubleQuotedHexStringLiteral => f
                                .debug_tuple("TerminalKind::DoubleQuotedHexStringLiteral")
                                .finish(),
                            TerminalKind::DoubleQuotedStringLiteral => f
                                .debug_tuple("TerminalKind::DoubleQuotedStringLiteral")
                                .finish(),
                            TerminalKind::DoubleQuotedUnicodeStringLiteral => f
                                .debug_tuple("TerminalKind::DoubleQuotedUnicodeStringLiteral")
                                .finish(),
                            TerminalKind::DoubleQuotedVersionLiteral => f
                                .debug_tuple("TerminalKind::DoubleQuotedVersionLiteral")
                                .finish(),
                            TerminalKind::ElseKeyword => {
                                f.debug_tuple("TerminalKind::ElseKeyword").finish()
                            }
                            TerminalKind::EmitKeyword => {
                                f.debug_tuple("TerminalKind::EmitKeyword").finish()
                            }
                            TerminalKind::EndOfLine => {
                                f.debug_tuple("TerminalKind::EndOfLine").finish()
                            }
                            TerminalKind::EnumKeyword => {
                                f.debug_tuple("TerminalKind::EnumKeyword").finish()
                            }
                            TerminalKind::Equal => f.debug_tuple("TerminalKind::Equal").finish(),
                            TerminalKind::EqualColon => {
                                f.debug_tuple("TerminalKind::EqualColon").finish()
                            }
                            TerminalKind::EqualEqual => {
                                f.debug_tuple("TerminalKind::EqualEqual").finish()
                            }
                            TerminalKind::EqualGreaterThan => {
                                f.debug_tuple("TerminalKind::EqualGreaterThan").finish()
                            }
                            TerminalKind::ErrorKeyword => {
                                f.debug_tuple("TerminalKind::ErrorKeyword").finish()
                            }
                            TerminalKind::EtherKeyword => {
                                f.debug_tuple("TerminalKind::EtherKeyword").finish()
                            }
                            TerminalKind::EventKeyword => {
                                f.debug_tuple("TerminalKind::EventKeyword").finish()
                            }
                            TerminalKind::ExperimentalKeyword => {
                                f.debug_tuple("TerminalKind::ExperimentalKeyword").finish()
                            }
                            TerminalKind::ExternalKeyword => {
                                f.debug_tuple("TerminalKind::ExternalKeyword").finish()
                            }
                            TerminalKind::FallbackKeyword => {
                                f.debug_tuple("TerminalKind::FallbackKeyword").finish()
                            }
                            TerminalKind::FalseKeyword => {
                                f.debug_tuple("TerminalKind::FalseKeyword").finish()
                            }
                            TerminalKind::FinalKeyword => {
                                f.debug_tuple("TerminalKind::FinalKeyword").finish()
                            }
                            TerminalKind::FinneyKeyword => {
                                f.debug_tuple("TerminalKind::FinneyKeyword").finish()
                            }
                            TerminalKind::FixedKeyword => {
                                f.debug_tuple("TerminalKind::FixedKeyword").finish()
                            }
                            TerminalKind::ForKeyword => {
                                f.debug_tuple("TerminalKind::ForKeyword").finish()
                            }
                            TerminalKind::FromKeyword => {
                                f.debug_tuple("TerminalKind::FromKeyword").finish()
                            }
                            TerminalKind::FunctionKeyword => {
                                f.debug_tuple("TerminalKind::FunctionKeyword").finish()
                            }
                            TerminalKind::GlobalKeyword => {
                                f.debug_tuple("TerminalKind::GlobalKeyword").finish()
                            }
                            TerminalKind::GreaterThan => {
                                f.debug_tuple("TerminalKind::GreaterThan").finish()
                            }
                            TerminalKind::GreaterThanEqual => {
                                f.debug_tuple("TerminalKind::GreaterThanEqual").finish()
                            }
                            TerminalKind::GreaterThanGreaterThan => f
                                .debug_tuple("TerminalKind::GreaterThanGreaterThan")
                                .finish(),
                            TerminalKind::GreaterThanGreaterThanEqual => f
                                .debug_tuple("TerminalKind::GreaterThanGreaterThanEqual")
                                .finish(),
                            TerminalKind::GreaterThanGreaterThanGreaterThan => f
                                .debug_tuple("TerminalKind::GreaterThanGreaterThanGreaterThan")
                                .finish(),
                            TerminalKind::GreaterThanGreaterThanGreaterThanEqual => f
                                .debug_tuple("TerminalKind::GreaterThanGreaterThanGreaterThanEqual")
                                .finish(),
                            TerminalKind::GweiKeyword => {
                                f.debug_tuple("TerminalKind::GweiKeyword").finish()
                            }
                            TerminalKind::HexKeyword => {
                                f.debug_tuple("TerminalKind::HexKeyword").finish()
                            }
                            TerminalKind::HexLiteral => {
                                f.debug_tuple("TerminalKind::HexLiteral").finish()
                            }
                            TerminalKind::HoursKeyword => {
                                f.debug_tuple("TerminalKind::HoursKeyword").finish()
                            }
                            TerminalKind::Identifier => {
                                f.debug_tuple("TerminalKind::Identifier").finish()
                            }
                            TerminalKind::IfKeyword => {
                                f.debug_tuple("TerminalKind::IfKeyword").finish()
                            }
                            TerminalKind::ImmutableKeyword => {
                                f.debug_tuple("TerminalKind::ImmutableKeyword").finish()
                            }
                            TerminalKind::ImplementsKeyword => {
                                f.debug_tuple("TerminalKind::ImplementsKeyword").finish()
                            }
                            TerminalKind::ImportKeyword => {
                                f.debug_tuple("TerminalKind::ImportKeyword").finish()
                            }
                            TerminalKind::InKeyword => {
                                f.debug_tuple("TerminalKind::InKeyword").finish()
                            }
                            TerminalKind::IndexedKeyword => {
                                f.debug_tuple("TerminalKind::IndexedKeyword").finish()
                            }
                            TerminalKind::InlineKeyword => {
                                f.debug_tuple("TerminalKind::InlineKeyword").finish()
                            }
                            TerminalKind::IntKeyword => {
                                f.debug_tuple("TerminalKind::IntKeyword").finish()
                            }
                            TerminalKind::InterfaceKeyword => {
                                f.debug_tuple("TerminalKind::InterfaceKeyword").finish()
                            }
                            TerminalKind::InternalKeyword => {
                                f.debug_tuple("TerminalKind::InternalKeyword").finish()
                            }
                            TerminalKind::IsKeyword => {
                                f.debug_tuple("TerminalKind::IsKeyword").finish()
                            }
                            TerminalKind::LessThan => {
                                f.debug_tuple("TerminalKind::LessThan").finish()
                            }
                            TerminalKind::LessThanEqual => {
                                f.debug_tuple("TerminalKind::LessThanEqual").finish()
                            }
                            TerminalKind::LessThanLessThan => {
                                f.debug_tuple("TerminalKind::LessThanLessThan").finish()
                            }
                            TerminalKind::LessThanLessThanEqual => f
                                .debug_tuple("TerminalKind::LessThanLessThanEqual")
                                .finish(),
                            TerminalKind::LetKeyword => {
                                f.debug_tuple("TerminalKind::LetKeyword").finish()
                            }
                            TerminalKind::LibraryKeyword => {
                                f.debug_tuple("TerminalKind::LibraryKeyword").finish()
                            }
                            TerminalKind::MacroKeyword => {
                                f.debug_tuple("TerminalKind::MacroKeyword").finish()
                            }
                            TerminalKind::MappingKeyword => {
                                f.debug_tuple("TerminalKind::MappingKeyword").finish()
                            }
                            TerminalKind::MatchKeyword => {
                                f.debug_tuple("TerminalKind::MatchKeyword").finish()
                            }
                            TerminalKind::MemoryKeyword => {
                                f.debug_tuple("TerminalKind::MemoryKeyword").finish()
                            }
                            TerminalKind::Minus => f.debug_tuple("TerminalKind::Minus").finish(),
                            TerminalKind::MinusEqual => {
                                f.debug_tuple("TerminalKind::MinusEqual").finish()
                            }
                            TerminalKind::MinusGreaterThan => {
                                f.debug_tuple("TerminalKind::MinusGreaterThan").finish()
                            }
                            TerminalKind::MinusMinus => {
                                f.debug_tuple("TerminalKind::MinusMinus").finish()
                            }
                            TerminalKind::MinutesKeyword => {
                                f.debug_tuple("TerminalKind::MinutesKeyword").finish()
                            }
                            TerminalKind::ModifierKeyword => {
                                f.debug_tuple("TerminalKind::ModifierKeyword").finish()
                            }
                            TerminalKind::MultiLineComment => {
                                f.debug_tuple("TerminalKind::MultiLineComment").finish()
                            }
                            TerminalKind::MultiLineNatSpecComment => f
                                .debug_tuple("TerminalKind::MultiLineNatSpecComment")
                                .finish(),
                            TerminalKind::MutableKeyword => {
                                f.debug_tuple("TerminalKind::MutableKeyword").finish()
                            }
                            TerminalKind::NewKeyword => {
                                f.debug_tuple("TerminalKind::NewKeyword").finish()
                            }
                            TerminalKind::NullKeyword => {
                                f.debug_tuple("TerminalKind::NullKeyword").finish()
                            }
                            TerminalKind::OfKeyword => {
                                f.debug_tuple("TerminalKind::OfKeyword").finish()
                            }
                            TerminalKind::OpenBrace => {
                                f.debug_tuple("TerminalKind::OpenBrace").finish()
                            }
                            TerminalKind::OpenBracket => {
                                f.debug_tuple("TerminalKind::OpenBracket").finish()
                            }
                            TerminalKind::OpenParen => {
                                f.debug_tuple("TerminalKind::OpenParen").finish()
                            }
                            TerminalKind::OverrideKeyword => {
                                f.debug_tuple("TerminalKind::OverrideKeyword").finish()
                            }
                            TerminalKind::PartialKeyword => {
                                f.debug_tuple("TerminalKind::PartialKeyword").finish()
                            }
                            TerminalKind::PayableKeyword => {
                                f.debug_tuple("TerminalKind::PayableKeyword").finish()
                            }
                            TerminalKind::Percent => {
                                f.debug_tuple("TerminalKind::Percent").finish()
                            }
                            TerminalKind::PercentEqual => {
                                f.debug_tuple("TerminalKind::PercentEqual").finish()
                            }
                            TerminalKind::Period => f.debug_tuple("TerminalKind::Period").finish(),
                            TerminalKind::Plus => f.debug_tuple("TerminalKind::Plus").finish(),
                            TerminalKind::PlusEqual => {
                                f.debug_tuple("TerminalKind::PlusEqual").finish()
                            }
                            TerminalKind::PlusPlus => {
                                f.debug_tuple("TerminalKind::PlusPlus").finish()
                            }
                            TerminalKind::PragmaKeyword => {
                                f.debug_tuple("TerminalKind::PragmaKeyword").finish()
                            }
                            TerminalKind::PrivateKeyword => {
                                f.debug_tuple("TerminalKind::PrivateKeyword").finish()
                            }
                            TerminalKind::PromiseKeyword => {
                                f.debug_tuple("TerminalKind::PromiseKeyword").finish()
                            }
                            TerminalKind::PublicKeyword => {
                                f.debug_tuple("TerminalKind::PublicKeyword").finish()
                            }
                            TerminalKind::PureKeyword => {
                                f.debug_tuple("TerminalKind::PureKeyword").finish()
                            }
                            TerminalKind::QuestionMark => {
                                f.debug_tuple("TerminalKind::QuestionMark").finish()
                            }
                            TerminalKind::ReceiveKeyword => {
                                f.debug_tuple("TerminalKind::ReceiveKeyword").finish()
                            }
                            TerminalKind::ReferenceKeyword => {
                                f.debug_tuple("TerminalKind::ReferenceKeyword").finish()
                            }
                            TerminalKind::RelocatableKeyword => {
                                f.debug_tuple("TerminalKind::RelocatableKeyword").finish()
                            }
                            TerminalKind::ReturnKeyword => {
                                f.debug_tuple("TerminalKind::ReturnKeyword").finish()
                            }
                            TerminalKind::ReturnsKeyword => {
                                f.debug_tuple("TerminalKind::ReturnsKeyword").finish()
                            }
                            TerminalKind::RevertKeyword => {
                                f.debug_tuple("TerminalKind::RevertKeyword").finish()
                            }
                            TerminalKind::SealedKeyword => {
                                f.debug_tuple("TerminalKind::SealedKeyword").finish()
                            }
                            TerminalKind::SecondsKeyword => {
                                f.debug_tuple("TerminalKind::SecondsKeyword").finish()
                            }
                            TerminalKind::Semicolon => {
                                f.debug_tuple("TerminalKind::Semicolon").finish()
                            }
                            TerminalKind::SingleLineComment => {
                                f.debug_tuple("TerminalKind::SingleLineComment").finish()
                            }
                            TerminalKind::SingleLineNatSpecComment => f
                                .debug_tuple("TerminalKind::SingleLineNatSpecComment")
                                .finish(),
                            TerminalKind::SingleQuotedHexStringLiteral => f
                                .debug_tuple("TerminalKind::SingleQuotedHexStringLiteral")
                                .finish(),
                            TerminalKind::SingleQuotedStringLiteral => f
                                .debug_tuple("TerminalKind::SingleQuotedStringLiteral")
                                .finish(),
                            TerminalKind::SingleQuotedUnicodeStringLiteral => f
                                .debug_tuple("TerminalKind::SingleQuotedUnicodeStringLiteral")
                                .finish(),
                            TerminalKind::SingleQuotedVersionLiteral => f
                                .debug_tuple("TerminalKind::SingleQuotedVersionLiteral")
                                .finish(),
                            TerminalKind::SizeOfKeyword => {
                                f.debug_tuple("TerminalKind::SizeOfKeyword").finish()
                            }
                            TerminalKind::Slash => f.debug_tuple("TerminalKind::Slash").finish(),
                            TerminalKind::SlashEqual => {
                                f.debug_tuple("TerminalKind::SlashEqual").finish()
                            }
                            TerminalKind::SolidityKeyword => {
                                f.debug_tuple("TerminalKind::SolidityKeyword").finish()
                            }
                            TerminalKind::StaticKeyword => {
                                f.debug_tuple("TerminalKind::StaticKeyword").finish()
                            }
                            TerminalKind::StorageKeyword => {
                                f.debug_tuple("TerminalKind::StorageKeyword").finish()
                            }
                            TerminalKind::StringKeyword => {
                                f.debug_tuple("TerminalKind::StringKeyword").finish()
                            }
                            TerminalKind::StructKeyword => {
                                f.debug_tuple("TerminalKind::StructKeyword").finish()
                            }
                            TerminalKind::SupportsKeyword => {
                                f.debug_tuple("TerminalKind::SupportsKeyword").finish()
                            }
                            TerminalKind::SwitchKeyword => {
                                f.debug_tuple("TerminalKind::SwitchKeyword").finish()
                            }
                            TerminalKind::SzaboKeyword => {
                                f.debug_tuple("TerminalKind::SzaboKeyword").finish()
                            }
                            TerminalKind::ThrowKeyword => {
                                f.debug_tuple("TerminalKind::ThrowKeyword").finish()
                            }
                            TerminalKind::Tilde => f.debug_tuple("TerminalKind::Tilde").finish(),
                            TerminalKind::TrueKeyword => {
                                f.debug_tuple("TerminalKind::TrueKeyword").finish()
                            }
                            TerminalKind::TryKeyword => {
                                f.debug_tuple("TerminalKind::TryKeyword").finish()
                            }
                            TerminalKind::TypeDefKeyword => {
                                f.debug_tuple("TerminalKind::TypeDefKeyword").finish()
                            }
                            TerminalKind::TypeKeyword => {
                                f.debug_tuple("TerminalKind::TypeKeyword").finish()
                            }
                            TerminalKind::TypeOfKeyword => {
                                f.debug_tuple("TerminalKind::TypeOfKeyword").finish()
                            }
                            TerminalKind::UfixedKeyword => {
                                f.debug_tuple("TerminalKind::UfixedKeyword").finish()
                            }
                            TerminalKind::UintKeyword => {
                                f.debug_tuple("TerminalKind::UintKeyword").finish()
                            }
                            TerminalKind::UncheckedKeyword => {
                                f.debug_tuple("TerminalKind::UncheckedKeyword").finish()
                            }
                            TerminalKind::UsingKeyword => {
                                f.debug_tuple("TerminalKind::UsingKeyword").finish()
                            }
                            TerminalKind::VarKeyword => {
                                f.debug_tuple("TerminalKind::VarKeyword").finish()
                            }
                            TerminalKind::VersionSpecifier => {
                                f.debug_tuple("TerminalKind::VersionSpecifier").finish()
                            }
                            TerminalKind::ViewKeyword => {
                                f.debug_tuple("TerminalKind::ViewKeyword").finish()
                            }
                            TerminalKind::VirtualKeyword => {
                                f.debug_tuple("TerminalKind::VirtualKeyword").finish()
                            }
                            TerminalKind::WeeksKeyword => {
                                f.debug_tuple("TerminalKind::WeeksKeyword").finish()
                            }
                            TerminalKind::WeiKeyword => {
                                f.debug_tuple("TerminalKind::WeiKeyword").finish()
                            }
                            TerminalKind::WhileKeyword => {
                                f.debug_tuple("TerminalKind::WhileKeyword").finish()
                            }
                            TerminalKind::Whitespace => {
                                f.debug_tuple("TerminalKind::Whitespace").finish()
                            }
                            TerminalKind::YearsKeyword => {
                                f.debug_tuple("TerminalKind::YearsKeyword").finish()
                            }
                            TerminalKind::YulAbstractKeyword => {
                                f.debug_tuple("TerminalKind::YulAbstractKeyword").finish()
                            }
                            TerminalKind::YulAddKeyword => {
                                f.debug_tuple("TerminalKind::YulAddKeyword").finish()
                            }
                            TerminalKind::YulAddModKeyword => {
                                f.debug_tuple("TerminalKind::YulAddModKeyword").finish()
                            }
                            TerminalKind::YulAddressKeyword => {
                                f.debug_tuple("TerminalKind::YulAddressKeyword").finish()
                            }
                            TerminalKind::YulAfterKeyword => {
                                f.debug_tuple("TerminalKind::YulAfterKeyword").finish()
                            }
                            TerminalKind::YulAliasKeyword => {
                                f.debug_tuple("TerminalKind::YulAliasKeyword").finish()
                            }
                            TerminalKind::YulAndKeyword => {
                                f.debug_tuple("TerminalKind::YulAndKeyword").finish()
                            }
                            TerminalKind::YulAnonymousKeyword => {
                                f.debug_tuple("TerminalKind::YulAnonymousKeyword").finish()
                            }
                            TerminalKind::YulApplyKeyword => {
                                f.debug_tuple("TerminalKind::YulApplyKeyword").finish()
                            }
                            TerminalKind::YulAsKeyword => {
                                f.debug_tuple("TerminalKind::YulAsKeyword").finish()
                            }
                            TerminalKind::YulAssemblyKeyword => {
                                f.debug_tuple("TerminalKind::YulAssemblyKeyword").finish()
                            }
                            TerminalKind::YulAutoKeyword => {
                                f.debug_tuple("TerminalKind::YulAutoKeyword").finish()
                            }
                            TerminalKind::YulBalanceKeyword => {
                                f.debug_tuple("TerminalKind::YulBalanceKeyword").finish()
                            }
                            TerminalKind::YulBaseFeeKeyword => {
                                f.debug_tuple("TerminalKind::YulBaseFeeKeyword").finish()
                            }
                            TerminalKind::YulBlobBaseFeeKeyword => f
                                .debug_tuple("TerminalKind::YulBlobBaseFeeKeyword")
                                .finish(),
                            TerminalKind::YulBlobHashKeyword => {
                                f.debug_tuple("TerminalKind::YulBlobHashKeyword").finish()
                            }
                            TerminalKind::YulBlockHashKeyword => {
                                f.debug_tuple("TerminalKind::YulBlockHashKeyword").finish()
                            }
                            TerminalKind::YulBoolKeyword => {
                                f.debug_tuple("TerminalKind::YulBoolKeyword").finish()
                            }
                            TerminalKind::YulBreakKeyword => {
                                f.debug_tuple("TerminalKind::YulBreakKeyword").finish()
                            }
                            TerminalKind::YulByteKeyword => {
                                f.debug_tuple("TerminalKind::YulByteKeyword").finish()
                            }
                            TerminalKind::YulBytesKeyword => {
                                f.debug_tuple("TerminalKind::YulBytesKeyword").finish()
                            }
                            TerminalKind::YulCallCodeKeyword => {
                                f.debug_tuple("TerminalKind::YulCallCodeKeyword").finish()
                            }
                            TerminalKind::YulCallDataCopyKeyword => f
                                .debug_tuple("TerminalKind::YulCallDataCopyKeyword")
                                .finish(),
                            TerminalKind::YulCallDataKeyword => {
                                f.debug_tuple("TerminalKind::YulCallDataKeyword").finish()
                            }
                            TerminalKind::YulCallDataLoadKeyword => f
                                .debug_tuple("TerminalKind::YulCallDataLoadKeyword")
                                .finish(),
                            TerminalKind::YulCallDataSizeKeyword => f
                                .debug_tuple("TerminalKind::YulCallDataSizeKeyword")
                                .finish(),
                            TerminalKind::YulCallKeyword => {
                                f.debug_tuple("TerminalKind::YulCallKeyword").finish()
                            }
                            TerminalKind::YulCallValueKeyword => {
                                f.debug_tuple("TerminalKind::YulCallValueKeyword").finish()
                            }
                            TerminalKind::YulCallerKeyword => {
                                f.debug_tuple("TerminalKind::YulCallerKeyword").finish()
                            }
                            TerminalKind::YulCaseKeyword => {
                                f.debug_tuple("TerminalKind::YulCaseKeyword").finish()
                            }
                            TerminalKind::YulCatchKeyword => {
                                f.debug_tuple("TerminalKind::YulCatchKeyword").finish()
                            }
                            TerminalKind::YulChainIdKeyword => {
                                f.debug_tuple("TerminalKind::YulChainIdKeyword").finish()
                            }
                            TerminalKind::YulCoinBaseKeyword => {
                                f.debug_tuple("TerminalKind::YulCoinBaseKeyword").finish()
                            }
                            TerminalKind::YulConstantKeyword => {
                                f.debug_tuple("TerminalKind::YulConstantKeyword").finish()
                            }
                            TerminalKind::YulConstructorKeyword => f
                                .debug_tuple("TerminalKind::YulConstructorKeyword")
                                .finish(),
                            TerminalKind::YulContinueKeyword => {
                                f.debug_tuple("TerminalKind::YulContinueKeyword").finish()
                            }
                            TerminalKind::YulContractKeyword => {
                                f.debug_tuple("TerminalKind::YulContractKeyword").finish()
                            }
                            TerminalKind::YulCopyOfKeyword => {
                                f.debug_tuple("TerminalKind::YulCopyOfKeyword").finish()
                            }
                            TerminalKind::YulCreate2Keyword => {
                                f.debug_tuple("TerminalKind::YulCreate2Keyword").finish()
                            }
                            TerminalKind::YulCreateKeyword => {
                                f.debug_tuple("TerminalKind::YulCreateKeyword").finish()
                            }
                            TerminalKind::YulDaysKeyword => {
                                f.debug_tuple("TerminalKind::YulDaysKeyword").finish()
                            }
                            TerminalKind::YulDecimalLiteral => {
                                f.debug_tuple("TerminalKind::YulDecimalLiteral").finish()
                            }
                            TerminalKind::YulDefaultKeyword => {
                                f.debug_tuple("TerminalKind::YulDefaultKeyword").finish()
                            }
                            TerminalKind::YulDefineKeyword => {
                                f.debug_tuple("TerminalKind::YulDefineKeyword").finish()
                            }
                            TerminalKind::YulDelegateCallKeyword => f
                                .debug_tuple("TerminalKind::YulDelegateCallKeyword")
                                .finish(),
                            TerminalKind::YulDeleteKeyword => {
                                f.debug_tuple("TerminalKind::YulDeleteKeyword").finish()
                            }
                            TerminalKind::YulDifficultyKeyword => {
                                f.debug_tuple("TerminalKind::YulDifficultyKeyword").finish()
                            }
                            TerminalKind::YulDivKeyword => {
                                f.debug_tuple("TerminalKind::YulDivKeyword").finish()
                            }
                            TerminalKind::YulDoKeyword => {
                                f.debug_tuple("TerminalKind::YulDoKeyword").finish()
                            }
                            TerminalKind::YulElseKeyword => {
                                f.debug_tuple("TerminalKind::YulElseKeyword").finish()
                            }
                            TerminalKind::YulEmitKeyword => {
                                f.debug_tuple("TerminalKind::YulEmitKeyword").finish()
                            }
                            TerminalKind::YulEnumKeyword => {
                                f.debug_tuple("TerminalKind::YulEnumKeyword").finish()
                            }
                            TerminalKind::YulEqKeyword => {
                                f.debug_tuple("TerminalKind::YulEqKeyword").finish()
                            }
                            TerminalKind::YulEtherKeyword => {
                                f.debug_tuple("TerminalKind::YulEtherKeyword").finish()
                            }
                            TerminalKind::YulEventKeyword => {
                                f.debug_tuple("TerminalKind::YulEventKeyword").finish()
                            }
                            TerminalKind::YulExpKeyword => {
                                f.debug_tuple("TerminalKind::YulExpKeyword").finish()
                            }
                            TerminalKind::YulExtCodeCopyKeyword => f
                                .debug_tuple("TerminalKind::YulExtCodeCopyKeyword")
                                .finish(),
                            TerminalKind::YulExtCodeHashKeyword => f
                                .debug_tuple("TerminalKind::YulExtCodeHashKeyword")
                                .finish(),
                            TerminalKind::YulExtCodeSizeKeyword => f
                                .debug_tuple("TerminalKind::YulExtCodeSizeKeyword")
                                .finish(),
                            TerminalKind::YulExternalKeyword => {
                                f.debug_tuple("TerminalKind::YulExternalKeyword").finish()
                            }
                            TerminalKind::YulFallbackKeyword => {
                                f.debug_tuple("TerminalKind::YulFallbackKeyword").finish()
                            }
                            TerminalKind::YulFalseKeyword => {
                                f.debug_tuple("TerminalKind::YulFalseKeyword").finish()
                            }
                            TerminalKind::YulFinalKeyword => {
                                f.debug_tuple("TerminalKind::YulFinalKeyword").finish()
                            }
                            TerminalKind::YulFinneyKeyword => {
                                f.debug_tuple("TerminalKind::YulFinneyKeyword").finish()
                            }
                            TerminalKind::YulFixedKeyword => {
                                f.debug_tuple("TerminalKind::YulFixedKeyword").finish()
                            }
                            TerminalKind::YulForKeyword => {
                                f.debug_tuple("TerminalKind::YulForKeyword").finish()
                            }
                            TerminalKind::YulFunctionKeyword => {
                                f.debug_tuple("TerminalKind::YulFunctionKeyword").finish()
                            }
                            TerminalKind::YulGasKeyword => {
                                f.debug_tuple("TerminalKind::YulGasKeyword").finish()
                            }
                            TerminalKind::YulGasLimitKeyword => {
                                f.debug_tuple("TerminalKind::YulGasLimitKeyword").finish()
                            }
                            TerminalKind::YulGasPriceKeyword => {
                                f.debug_tuple("TerminalKind::YulGasPriceKeyword").finish()
                            }
                            TerminalKind::YulGtKeyword => {
                                f.debug_tuple("TerminalKind::YulGtKeyword").finish()
                            }
                            TerminalKind::YulGweiKeyword => {
                                f.debug_tuple("TerminalKind::YulGweiKeyword").finish()
                            }
                            TerminalKind::YulHexKeyword => {
                                f.debug_tuple("TerminalKind::YulHexKeyword").finish()
                            }
                            TerminalKind::YulHexLiteral => {
                                f.debug_tuple("TerminalKind::YulHexLiteral").finish()
                            }
                            TerminalKind::YulHoursKeyword => {
                                f.debug_tuple("TerminalKind::YulHoursKeyword").finish()
                            }
                            TerminalKind::YulIdentifier => {
                                f.debug_tuple("TerminalKind::YulIdentifier").finish()
                            }
                            TerminalKind::YulIfKeyword => {
                                f.debug_tuple("TerminalKind::YulIfKeyword").finish()
                            }
                            TerminalKind::YulImmutableKeyword => {
                                f.debug_tuple("TerminalKind::YulImmutableKeyword").finish()
                            }
                            TerminalKind::YulImplementsKeyword => {
                                f.debug_tuple("TerminalKind::YulImplementsKeyword").finish()
                            }
                            TerminalKind::YulImportKeyword => {
                                f.debug_tuple("TerminalKind::YulImportKeyword").finish()
                            }
                            TerminalKind::YulInKeyword => {
                                f.debug_tuple("TerminalKind::YulInKeyword").finish()
                            }
                            TerminalKind::YulIndexedKeyword => {
                                f.debug_tuple("TerminalKind::YulIndexedKeyword").finish()
                            }
                            TerminalKind::YulInlineKeyword => {
                                f.debug_tuple("TerminalKind::YulInlineKeyword").finish()
                            }
                            TerminalKind::YulIntKeyword => {
                                f.debug_tuple("TerminalKind::YulIntKeyword").finish()
                            }
                            TerminalKind::YulInterfaceKeyword => {
                                f.debug_tuple("TerminalKind::YulInterfaceKeyword").finish()
                            }
                            TerminalKind::YulInternalKeyword => {
                                f.debug_tuple("TerminalKind::YulInternalKeyword").finish()
                            }
                            TerminalKind::YulInvalidKeyword => {
                                f.debug_tuple("TerminalKind::YulInvalidKeyword").finish()
                            }
                            TerminalKind::YulIsKeyword => {
                                f.debug_tuple("TerminalKind::YulIsKeyword").finish()
                            }
                            TerminalKind::YulIsZeroKeyword => {
                                f.debug_tuple("TerminalKind::YulIsZeroKeyword").finish()
                            }
                            TerminalKind::YulKeccak256Keyword => {
                                f.debug_tuple("TerminalKind::YulKeccak256Keyword").finish()
                            }
                            TerminalKind::YulLeaveKeyword => {
                                f.debug_tuple("TerminalKind::YulLeaveKeyword").finish()
                            }
                            TerminalKind::YulLetKeyword => {
                                f.debug_tuple("TerminalKind::YulLetKeyword").finish()
                            }
                            TerminalKind::YulLibraryKeyword => {
                                f.debug_tuple("TerminalKind::YulLibraryKeyword").finish()
                            }
                            TerminalKind::YulLog0Keyword => {
                                f.debug_tuple("TerminalKind::YulLog0Keyword").finish()
                            }
                            TerminalKind::YulLog1Keyword => {
                                f.debug_tuple("TerminalKind::YulLog1Keyword").finish()
                            }
                            TerminalKind::YulLog2Keyword => {
                                f.debug_tuple("TerminalKind::YulLog2Keyword").finish()
                            }
                            TerminalKind::YulLog3Keyword => {
                                f.debug_tuple("TerminalKind::YulLog3Keyword").finish()
                            }
                            TerminalKind::YulLog4Keyword => {
                                f.debug_tuple("TerminalKind::YulLog4Keyword").finish()
                            }
                            TerminalKind::YulLtKeyword => {
                                f.debug_tuple("TerminalKind::YulLtKeyword").finish()
                            }
                            TerminalKind::YulMcopyKeyword => {
                                f.debug_tuple("TerminalKind::YulMcopyKeyword").finish()
                            }
                            TerminalKind::YulMloadKeyword => {
                                f.debug_tuple("TerminalKind::YulMloadKeyword").finish()
                            }
                            TerminalKind::YulMsizeKeyword => {
                                f.debug_tuple("TerminalKind::YulMsizeKeyword").finish()
                            }
                            TerminalKind::YulMstore8Keyword => {
                                f.debug_tuple("TerminalKind::YulMstore8Keyword").finish()
                            }
                            TerminalKind::YulMstoreKeyword => {
                                f.debug_tuple("TerminalKind::YulMstoreKeyword").finish()
                            }
                            TerminalKind::YulMacroKeyword => {
                                f.debug_tuple("TerminalKind::YulMacroKeyword").finish()
                            }
                            TerminalKind::YulMappingKeyword => {
                                f.debug_tuple("TerminalKind::YulMappingKeyword").finish()
                            }
                            TerminalKind::YulMatchKeyword => {
                                f.debug_tuple("TerminalKind::YulMatchKeyword").finish()
                            }
                            TerminalKind::YulMemoryKeyword => {
                                f.debug_tuple("TerminalKind::YulMemoryKeyword").finish()
                            }
                            TerminalKind::YulMinutesKeyword => {
                                f.debug_tuple("TerminalKind::YulMinutesKeyword").finish()
                            }
                            TerminalKind::YulModKeyword => {
                                f.debug_tuple("TerminalKind::YulModKeyword").finish()
                            }
                            TerminalKind::YulModifierKeyword => {
                                f.debug_tuple("TerminalKind::YulModifierKeyword").finish()
                            }
                            TerminalKind::YulMulKeyword => {
                                f.debug_tuple("TerminalKind::YulMulKeyword").finish()
                            }
                            TerminalKind::YulMulModKeyword => {
                                f.debug_tuple("TerminalKind::YulMulModKeyword").finish()
                            }
                            TerminalKind::YulMutableKeyword => {
                                f.debug_tuple("TerminalKind::YulMutableKeyword").finish()
                            }
                            TerminalKind::YulNewKeyword => {
                                f.debug_tuple("TerminalKind::YulNewKeyword").finish()
                            }
                            TerminalKind::YulNotKeyword => {
                                f.debug_tuple("TerminalKind::YulNotKeyword").finish()
                            }
                            TerminalKind::YulNullKeyword => {
                                f.debug_tuple("TerminalKind::YulNullKeyword").finish()
                            }
                            TerminalKind::YulNumberKeyword => {
                                f.debug_tuple("TerminalKind::YulNumberKeyword").finish()
                            }
                            TerminalKind::YulOfKeyword => {
                                f.debug_tuple("TerminalKind::YulOfKeyword").finish()
                            }
                            TerminalKind::YulOrKeyword => {
                                f.debug_tuple("TerminalKind::YulOrKeyword").finish()
                            }
                            TerminalKind::YulOriginKeyword => {
                                f.debug_tuple("TerminalKind::YulOriginKeyword").finish()
                            }
                            TerminalKind::YulOverrideKeyword => {
                                f.debug_tuple("TerminalKind::YulOverrideKeyword").finish()
                            }
                            TerminalKind::YulPartialKeyword => {
                                f.debug_tuple("TerminalKind::YulPartialKeyword").finish()
                            }
                            TerminalKind::YulPayableKeyword => {
                                f.debug_tuple("TerminalKind::YulPayableKeyword").finish()
                            }
                            TerminalKind::YulPopKeyword => {
                                f.debug_tuple("TerminalKind::YulPopKeyword").finish()
                            }
                            TerminalKind::YulPragmaKeyword => {
                                f.debug_tuple("TerminalKind::YulPragmaKeyword").finish()
                            }
                            TerminalKind::YulPrevRandaoKeyword => {
                                f.debug_tuple("TerminalKind::YulPrevRandaoKeyword").finish()
                            }
                            TerminalKind::YulPrivateKeyword => {
                                f.debug_tuple("TerminalKind::YulPrivateKeyword").finish()
                            }
                            TerminalKind::YulPromiseKeyword => {
                                f.debug_tuple("TerminalKind::YulPromiseKeyword").finish()
                            }
                            TerminalKind::YulPublicKeyword => {
                                f.debug_tuple("TerminalKind::YulPublicKeyword").finish()
                            }
                            TerminalKind::YulPureKeyword => {
                                f.debug_tuple("TerminalKind::YulPureKeyword").finish()
                            }
                            TerminalKind::YulReceiveKeyword => {
                                f.debug_tuple("TerminalKind::YulReceiveKeyword").finish()
                            }
                            TerminalKind::YulReferenceKeyword => {
                                f.debug_tuple("TerminalKind::YulReferenceKeyword").finish()
                            }
                            TerminalKind::YulRelocatableKeyword => f
                                .debug_tuple("TerminalKind::YulRelocatableKeyword")
                                .finish(),
                            TerminalKind::YulReturnDataCopyKeyword => f
                                .debug_tuple("TerminalKind::YulReturnDataCopyKeyword")
                                .finish(),
                            TerminalKind::YulReturnDataSizeKeyword => f
                                .debug_tuple("TerminalKind::YulReturnDataSizeKeyword")
                                .finish(),
                            TerminalKind::YulReturnKeyword => {
                                f.debug_tuple("TerminalKind::YulReturnKeyword").finish()
                            }
                            TerminalKind::YulReturnsKeyword => {
                                f.debug_tuple("TerminalKind::YulReturnsKeyword").finish()
                            }
                            TerminalKind::YulRevertKeyword => {
                                f.debug_tuple("TerminalKind::YulRevertKeyword").finish()
                            }
                            TerminalKind::YulSdivKeyword => {
                                f.debug_tuple("TerminalKind::YulSdivKeyword").finish()
                            }
                            TerminalKind::YulSloadKeyword => {
                                f.debug_tuple("TerminalKind::YulSloadKeyword").finish()
                            }
                            TerminalKind::YulSmodKeyword => {
                                f.debug_tuple("TerminalKind::YulSmodKeyword").finish()
                            }
                            TerminalKind::YulSstoreKeyword => {
                                f.debug_tuple("TerminalKind::YulSstoreKeyword").finish()
                            }
                            TerminalKind::YulSarKeyword => {
                                f.debug_tuple("TerminalKind::YulSarKeyword").finish()
                            }
                            TerminalKind::YulSealedKeyword => {
                                f.debug_tuple("TerminalKind::YulSealedKeyword").finish()
                            }
                            TerminalKind::YulSecondsKeyword => {
                                f.debug_tuple("TerminalKind::YulSecondsKeyword").finish()
                            }
                            TerminalKind::YulSelfBalanceKeyword => f
                                .debug_tuple("TerminalKind::YulSelfBalanceKeyword")
                                .finish(),
                            TerminalKind::YulSelfDestructKeyword => f
                                .debug_tuple("TerminalKind::YulSelfDestructKeyword")
                                .finish(),
                            TerminalKind::YulSgtKeyword => {
                                f.debug_tuple("TerminalKind::YulSgtKeyword").finish()
                            }
                            TerminalKind::YulSha3Keyword => {
                                f.debug_tuple("TerminalKind::YulSha3Keyword").finish()
                            }
                            TerminalKind::YulShlKeyword => {
                                f.debug_tuple("TerminalKind::YulShlKeyword").finish()
                            }
                            TerminalKind::YulShrKeyword => {
                                f.debug_tuple("TerminalKind::YulShrKeyword").finish()
                            }
                            TerminalKind::YulSignExtendKeyword => {
                                f.debug_tuple("TerminalKind::YulSignExtendKeyword").finish()
                            }
                            TerminalKind::YulSizeOfKeyword => {
                                f.debug_tuple("TerminalKind::YulSizeOfKeyword").finish()
                            }
                            TerminalKind::YulSltKeyword => {
                                f.debug_tuple("TerminalKind::YulSltKeyword").finish()
                            }
                            TerminalKind::YulStaticCallKeyword => {
                                f.debug_tuple("TerminalKind::YulStaticCallKeyword").finish()
                            }
                            TerminalKind::YulStaticKeyword => {
                                f.debug_tuple("TerminalKind::YulStaticKeyword").finish()
                            }
                            TerminalKind::YulStopKeyword => {
                                f.debug_tuple("TerminalKind::YulStopKeyword").finish()
                            }
                            TerminalKind::YulStorageKeyword => {
                                f.debug_tuple("TerminalKind::YulStorageKeyword").finish()
                            }
                            TerminalKind::YulStringKeyword => {
                                f.debug_tuple("TerminalKind::YulStringKeyword").finish()
                            }
                            TerminalKind::YulStructKeyword => {
                                f.debug_tuple("TerminalKind::YulStructKeyword").finish()
                            }
                            TerminalKind::YulSubKeyword => {
                                f.debug_tuple("TerminalKind::YulSubKeyword").finish()
                            }
                            TerminalKind::YulSuicideKeyword => {
                                f.debug_tuple("TerminalKind::YulSuicideKeyword").finish()
                            }
                            TerminalKind::YulSupportsKeyword => {
                                f.debug_tuple("TerminalKind::YulSupportsKeyword").finish()
                            }
                            TerminalKind::YulSwitchKeyword => {
                                f.debug_tuple("TerminalKind::YulSwitchKeyword").finish()
                            }
                            TerminalKind::YulSzaboKeyword => {
                                f.debug_tuple("TerminalKind::YulSzaboKeyword").finish()
                            }
                            TerminalKind::YulTloadKeyword => {
                                f.debug_tuple("TerminalKind::YulTloadKeyword").finish()
                            }
                            TerminalKind::YulTstoreKeyword => {
                                f.debug_tuple("TerminalKind::YulTstoreKeyword").finish()
                            }
                            TerminalKind::YulThrowKeyword => {
                                f.debug_tuple("TerminalKind::YulThrowKeyword").finish()
                            }
                            TerminalKind::YulTimestampKeyword => {
                                f.debug_tuple("TerminalKind::YulTimestampKeyword").finish()
                            }
                            TerminalKind::YulTrueKeyword => {
                                f.debug_tuple("TerminalKind::YulTrueKeyword").finish()
                            }
                            TerminalKind::YulTryKeyword => {
                                f.debug_tuple("TerminalKind::YulTryKeyword").finish()
                            }
                            TerminalKind::YulTypeDefKeyword => {
                                f.debug_tuple("TerminalKind::YulTypeDefKeyword").finish()
                            }
                            TerminalKind::YulTypeKeyword => {
                                f.debug_tuple("TerminalKind::YulTypeKeyword").finish()
                            }
                            TerminalKind::YulTypeOfKeyword => {
                                f.debug_tuple("TerminalKind::YulTypeOfKeyword").finish()
                            }
                            TerminalKind::YulUfixedKeyword => {
                                f.debug_tuple("TerminalKind::YulUfixedKeyword").finish()
                            }
                            TerminalKind::YulUintKeyword => {
                                f.debug_tuple("TerminalKind::YulUintKeyword").finish()
                            }
                            TerminalKind::YulUncheckedKeyword => {
                                f.debug_tuple("TerminalKind::YulUncheckedKeyword").finish()
                            }
                            TerminalKind::YulUsingKeyword => {
                                f.debug_tuple("TerminalKind::YulUsingKeyword").finish()
                            }
                            TerminalKind::YulVarKeyword => {
                                f.debug_tuple("TerminalKind::YulVarKeyword").finish()
                            }
                            TerminalKind::YulViewKeyword => {
                                f.debug_tuple("TerminalKind::YulViewKeyword").finish()
                            }
                            TerminalKind::YulVirtualKeyword => {
                                f.debug_tuple("TerminalKind::YulVirtualKeyword").finish()
                            }
                            TerminalKind::YulWeeksKeyword => {
                                f.debug_tuple("TerminalKind::YulWeeksKeyword").finish()
                            }
                            TerminalKind::YulWeiKeyword => {
                                f.debug_tuple("TerminalKind::YulWeiKeyword").finish()
                            }
                            TerminalKind::YulWhileKeyword => {
                                f.debug_tuple("TerminalKind::YulWhileKeyword").finish()
                            }
                            TerminalKind::YulXorKeyword => {
                                f.debug_tuple("TerminalKind::YulXorKeyword").finish()
                            }
                            TerminalKind::YulYearsKeyword => {
                                f.debug_tuple("TerminalKind::YulYearsKeyword").finish()
                            }
                        }
                    }
                }

                impl TerminalKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u16) -> TerminalKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => TerminalKind::Skipped,
                            1 => TerminalKind::AbicoderKeyword,
                            2 => TerminalKind::AbstractKeyword,
                            3 => TerminalKind::AddressKeyword,
                            4 => TerminalKind::AfterKeyword,
                            5 => TerminalKind::AliasKeyword,
                            6 => TerminalKind::Ampersand,
                            7 => TerminalKind::AmpersandAmpersand,
                            8 => TerminalKind::AmpersandEqual,
                            9 => TerminalKind::AnonymousKeyword,
                            10 => TerminalKind::ApplyKeyword,
                            11 => TerminalKind::AsKeyword,
                            12 => TerminalKind::AssemblyKeyword,
                            13 => TerminalKind::Asterisk,
                            14 => TerminalKind::AsteriskAsterisk,
                            15 => TerminalKind::AsteriskEqual,
                            16 => TerminalKind::AutoKeyword,
                            17 => TerminalKind::Bang,
                            18 => TerminalKind::BangEqual,
                            19 => TerminalKind::Bar,
                            20 => TerminalKind::BarBar,
                            21 => TerminalKind::BarEqual,
                            22 => TerminalKind::BoolKeyword,
                            23 => TerminalKind::BreakKeyword,
                            24 => TerminalKind::ByteKeyword,
                            25 => TerminalKind::BytesKeyword,
                            26 => TerminalKind::CallDataKeyword,
                            27 => TerminalKind::Caret,
                            28 => TerminalKind::CaretEqual,
                            29 => TerminalKind::CaseKeyword,
                            30 => TerminalKind::CatchKeyword,
                            31 => TerminalKind::CloseBrace,
                            32 => TerminalKind::CloseBracket,
                            33 => TerminalKind::CloseParen,
                            34 => TerminalKind::Colon,
                            35 => TerminalKind::ColonEqual,
                            36 => TerminalKind::Comma,
                            37 => TerminalKind::ConstantKeyword,
                            38 => TerminalKind::ConstructorKeyword,
                            39 => TerminalKind::ContinueKeyword,
                            40 => TerminalKind::ContractKeyword,
                            41 => TerminalKind::CopyOfKeyword,
                            42 => TerminalKind::DaysKeyword,
                            43 => TerminalKind::DecimalLiteral,
                            44 => TerminalKind::DefaultKeyword,
                            45 => TerminalKind::DefineKeyword,
                            46 => TerminalKind::DeleteKeyword,
                            47 => TerminalKind::DoKeyword,
                            48 => TerminalKind::DoubleQuotedHexStringLiteral,
                            49 => TerminalKind::DoubleQuotedStringLiteral,
                            50 => TerminalKind::DoubleQuotedUnicodeStringLiteral,
                            51 => TerminalKind::DoubleQuotedVersionLiteral,
                            52 => TerminalKind::ElseKeyword,
                            53 => TerminalKind::EmitKeyword,
                            54 => TerminalKind::EndOfLine,
                            55 => TerminalKind::EnumKeyword,
                            56 => TerminalKind::Equal,
                            57 => TerminalKind::EqualColon,
                            58 => TerminalKind::EqualEqual,
                            59 => TerminalKind::EqualGreaterThan,
                            60 => TerminalKind::ErrorKeyword,
                            61 => TerminalKind::EtherKeyword,
                            62 => TerminalKind::EventKeyword,
                            63 => TerminalKind::ExperimentalKeyword,
                            64 => TerminalKind::ExternalKeyword,
                            65 => TerminalKind::FallbackKeyword,
                            66 => TerminalKind::FalseKeyword,
                            67 => TerminalKind::FinalKeyword,
                            68 => TerminalKind::FinneyKeyword,
                            69 => TerminalKind::FixedKeyword,
                            70 => TerminalKind::ForKeyword,
                            71 => TerminalKind::FromKeyword,
                            72 => TerminalKind::FunctionKeyword,
                            73 => TerminalKind::GlobalKeyword,
                            74 => TerminalKind::GreaterThan,
                            75 => TerminalKind::GreaterThanEqual,
                            76 => TerminalKind::GreaterThanGreaterThan,
                            77 => TerminalKind::GreaterThanGreaterThanEqual,
                            78 => TerminalKind::GreaterThanGreaterThanGreaterThan,
                            79 => TerminalKind::GreaterThanGreaterThanGreaterThanEqual,
                            80 => TerminalKind::GweiKeyword,
                            81 => TerminalKind::HexKeyword,
                            82 => TerminalKind::HexLiteral,
                            83 => TerminalKind::HoursKeyword,
                            84 => TerminalKind::Identifier,
                            85 => TerminalKind::IfKeyword,
                            86 => TerminalKind::ImmutableKeyword,
                            87 => TerminalKind::ImplementsKeyword,
                            88 => TerminalKind::ImportKeyword,
                            89 => TerminalKind::InKeyword,
                            90 => TerminalKind::IndexedKeyword,
                            91 => TerminalKind::InlineKeyword,
                            92 => TerminalKind::IntKeyword,
                            93 => TerminalKind::InterfaceKeyword,
                            94 => TerminalKind::InternalKeyword,
                            95 => TerminalKind::IsKeyword,
                            96 => TerminalKind::LessThan,
                            97 => TerminalKind::LessThanEqual,
                            98 => TerminalKind::LessThanLessThan,
                            99 => TerminalKind::LessThanLessThanEqual,
                            100 => TerminalKind::LetKeyword,
                            101 => TerminalKind::LibraryKeyword,
                            102 => TerminalKind::MacroKeyword,
                            103 => TerminalKind::MappingKeyword,
                            104 => TerminalKind::MatchKeyword,
                            105 => TerminalKind::MemoryKeyword,
                            106 => TerminalKind::Minus,
                            107 => TerminalKind::MinusEqual,
                            108 => TerminalKind::MinusGreaterThan,
                            109 => TerminalKind::MinusMinus,
                            110 => TerminalKind::MinutesKeyword,
                            111 => TerminalKind::ModifierKeyword,
                            112 => TerminalKind::MultiLineComment,
                            113 => TerminalKind::MultiLineNatSpecComment,
                            114 => TerminalKind::MutableKeyword,
                            115 => TerminalKind::NewKeyword,
                            116 => TerminalKind::NullKeyword,
                            117 => TerminalKind::OfKeyword,
                            118 => TerminalKind::OpenBrace,
                            119 => TerminalKind::OpenBracket,
                            120 => TerminalKind::OpenParen,
                            121 => TerminalKind::OverrideKeyword,
                            122 => TerminalKind::PartialKeyword,
                            123 => TerminalKind::PayableKeyword,
                            124 => TerminalKind::Percent,
                            125 => TerminalKind::PercentEqual,
                            126 => TerminalKind::Period,
                            127 => TerminalKind::Plus,
                            128 => TerminalKind::PlusEqual,
                            129 => TerminalKind::PlusPlus,
                            130 => TerminalKind::PragmaKeyword,
                            131 => TerminalKind::PrivateKeyword,
                            132 => TerminalKind::PromiseKeyword,
                            133 => TerminalKind::PublicKeyword,
                            134 => TerminalKind::PureKeyword,
                            135 => TerminalKind::QuestionMark,
                            136 => TerminalKind::ReceiveKeyword,
                            137 => TerminalKind::ReferenceKeyword,
                            138 => TerminalKind::RelocatableKeyword,
                            139 => TerminalKind::ReturnKeyword,
                            140 => TerminalKind::ReturnsKeyword,
                            141 => TerminalKind::RevertKeyword,
                            142 => TerminalKind::SealedKeyword,
                            143 => TerminalKind::SecondsKeyword,
                            144 => TerminalKind::Semicolon,
                            145 => TerminalKind::SingleLineComment,
                            146 => TerminalKind::SingleLineNatSpecComment,
                            147 => TerminalKind::SingleQuotedHexStringLiteral,
                            148 => TerminalKind::SingleQuotedStringLiteral,
                            149 => TerminalKind::SingleQuotedUnicodeStringLiteral,
                            150 => TerminalKind::SingleQuotedVersionLiteral,
                            151 => TerminalKind::SizeOfKeyword,
                            152 => TerminalKind::Slash,
                            153 => TerminalKind::SlashEqual,
                            154 => TerminalKind::SolidityKeyword,
                            155 => TerminalKind::StaticKeyword,
                            156 => TerminalKind::StorageKeyword,
                            157 => TerminalKind::StringKeyword,
                            158 => TerminalKind::StructKeyword,
                            159 => TerminalKind::SupportsKeyword,
                            160 => TerminalKind::SwitchKeyword,
                            161 => TerminalKind::SzaboKeyword,
                            162 => TerminalKind::ThrowKeyword,
                            163 => TerminalKind::Tilde,
                            164 => TerminalKind::TrueKeyword,
                            165 => TerminalKind::TryKeyword,
                            166 => TerminalKind::TypeDefKeyword,
                            167 => TerminalKind::TypeKeyword,
                            168 => TerminalKind::TypeOfKeyword,
                            169 => TerminalKind::UfixedKeyword,
                            170 => TerminalKind::UintKeyword,
                            171 => TerminalKind::UncheckedKeyword,
                            172 => TerminalKind::UsingKeyword,
                            173 => TerminalKind::VarKeyword,
                            174 => TerminalKind::VersionSpecifier,
                            175 => TerminalKind::ViewKeyword,
                            176 => TerminalKind::VirtualKeyword,
                            177 => TerminalKind::WeeksKeyword,
                            178 => TerminalKind::WeiKeyword,
                            179 => TerminalKind::WhileKeyword,
                            180 => TerminalKind::Whitespace,
                            181 => TerminalKind::YearsKeyword,
                            182 => TerminalKind::YulAbstractKeyword,
                            183 => TerminalKind::YulAddKeyword,
                            184 => TerminalKind::YulAddModKeyword,
                            185 => TerminalKind::YulAddressKeyword,
                            186 => TerminalKind::YulAfterKeyword,
                            187 => TerminalKind::YulAliasKeyword,
                            188 => TerminalKind::YulAndKeyword,
                            189 => TerminalKind::YulAnonymousKeyword,
                            190 => TerminalKind::YulApplyKeyword,
                            191 => TerminalKind::YulAsKeyword,
                            192 => TerminalKind::YulAssemblyKeyword,
                            193 => TerminalKind::YulAutoKeyword,
                            194 => TerminalKind::YulBalanceKeyword,
                            195 => TerminalKind::YulBaseFeeKeyword,
                            196 => TerminalKind::YulBlobBaseFeeKeyword,
                            197 => TerminalKind::YulBlobHashKeyword,
                            198 => TerminalKind::YulBlockHashKeyword,
                            199 => TerminalKind::YulBoolKeyword,
                            200 => TerminalKind::YulBreakKeyword,
                            201 => TerminalKind::YulByteKeyword,
                            202 => TerminalKind::YulBytesKeyword,
                            203 => TerminalKind::YulCallCodeKeyword,
                            204 => TerminalKind::YulCallDataCopyKeyword,
                            205 => TerminalKind::YulCallDataKeyword,
                            206 => TerminalKind::YulCallDataLoadKeyword,
                            207 => TerminalKind::YulCallDataSizeKeyword,
                            208 => TerminalKind::YulCallKeyword,
                            209 => TerminalKind::YulCallValueKeyword,
                            210 => TerminalKind::YulCallerKeyword,
                            211 => TerminalKind::YulCaseKeyword,
                            212 => TerminalKind::YulCatchKeyword,
                            213 => TerminalKind::YulChainIdKeyword,
                            214 => TerminalKind::YulCoinBaseKeyword,
                            215 => TerminalKind::YulConstantKeyword,
                            216 => TerminalKind::YulConstructorKeyword,
                            217 => TerminalKind::YulContinueKeyword,
                            218 => TerminalKind::YulContractKeyword,
                            219 => TerminalKind::YulCopyOfKeyword,
                            220 => TerminalKind::YulCreate2Keyword,
                            221 => TerminalKind::YulCreateKeyword,
                            222 => TerminalKind::YulDaysKeyword,
                            223 => TerminalKind::YulDecimalLiteral,
                            224 => TerminalKind::YulDefaultKeyword,
                            225 => TerminalKind::YulDefineKeyword,
                            226 => TerminalKind::YulDelegateCallKeyword,
                            227 => TerminalKind::YulDeleteKeyword,
                            228 => TerminalKind::YulDifficultyKeyword,
                            229 => TerminalKind::YulDivKeyword,
                            230 => TerminalKind::YulDoKeyword,
                            231 => TerminalKind::YulElseKeyword,
                            232 => TerminalKind::YulEmitKeyword,
                            233 => TerminalKind::YulEnumKeyword,
                            234 => TerminalKind::YulEqKeyword,
                            235 => TerminalKind::YulEtherKeyword,
                            236 => TerminalKind::YulEventKeyword,
                            237 => TerminalKind::YulExpKeyword,
                            238 => TerminalKind::YulExtCodeCopyKeyword,
                            239 => TerminalKind::YulExtCodeHashKeyword,
                            240 => TerminalKind::YulExtCodeSizeKeyword,
                            241 => TerminalKind::YulExternalKeyword,
                            242 => TerminalKind::YulFallbackKeyword,
                            243 => TerminalKind::YulFalseKeyword,
                            244 => TerminalKind::YulFinalKeyword,
                            245 => TerminalKind::YulFinneyKeyword,
                            246 => TerminalKind::YulFixedKeyword,
                            247 => TerminalKind::YulForKeyword,
                            248 => TerminalKind::YulFunctionKeyword,
                            249 => TerminalKind::YulGasKeyword,
                            250 => TerminalKind::YulGasLimitKeyword,
                            251 => TerminalKind::YulGasPriceKeyword,
                            252 => TerminalKind::YulGtKeyword,
                            253 => TerminalKind::YulGweiKeyword,
                            254 => TerminalKind::YulHexKeyword,
                            255 => TerminalKind::YulHexLiteral,
                            256 => TerminalKind::YulHoursKeyword,
                            257 => TerminalKind::YulIdentifier,
                            258 => TerminalKind::YulIfKeyword,
                            259 => TerminalKind::YulImmutableKeyword,
                            260 => TerminalKind::YulImplementsKeyword,
                            261 => TerminalKind::YulImportKeyword,
                            262 => TerminalKind::YulInKeyword,
                            263 => TerminalKind::YulIndexedKeyword,
                            264 => TerminalKind::YulInlineKeyword,
                            265 => TerminalKind::YulIntKeyword,
                            266 => TerminalKind::YulInterfaceKeyword,
                            267 => TerminalKind::YulInternalKeyword,
                            268 => TerminalKind::YulInvalidKeyword,
                            269 => TerminalKind::YulIsKeyword,
                            270 => TerminalKind::YulIsZeroKeyword,
                            271 => TerminalKind::YulKeccak256Keyword,
                            272 => TerminalKind::YulLeaveKeyword,
                            273 => TerminalKind::YulLetKeyword,
                            274 => TerminalKind::YulLibraryKeyword,
                            275 => TerminalKind::YulLog0Keyword,
                            276 => TerminalKind::YulLog1Keyword,
                            277 => TerminalKind::YulLog2Keyword,
                            278 => TerminalKind::YulLog3Keyword,
                            279 => TerminalKind::YulLog4Keyword,
                            280 => TerminalKind::YulLtKeyword,
                            281 => TerminalKind::YulMcopyKeyword,
                            282 => TerminalKind::YulMloadKeyword,
                            283 => TerminalKind::YulMsizeKeyword,
                            284 => TerminalKind::YulMstore8Keyword,
                            285 => TerminalKind::YulMstoreKeyword,
                            286 => TerminalKind::YulMacroKeyword,
                            287 => TerminalKind::YulMappingKeyword,
                            288 => TerminalKind::YulMatchKeyword,
                            289 => TerminalKind::YulMemoryKeyword,
                            290 => TerminalKind::YulMinutesKeyword,
                            291 => TerminalKind::YulModKeyword,
                            292 => TerminalKind::YulModifierKeyword,
                            293 => TerminalKind::YulMulKeyword,
                            294 => TerminalKind::YulMulModKeyword,
                            295 => TerminalKind::YulMutableKeyword,
                            296 => TerminalKind::YulNewKeyword,
                            297 => TerminalKind::YulNotKeyword,
                            298 => TerminalKind::YulNullKeyword,
                            299 => TerminalKind::YulNumberKeyword,
                            300 => TerminalKind::YulOfKeyword,
                            301 => TerminalKind::YulOrKeyword,
                            302 => TerminalKind::YulOriginKeyword,
                            303 => TerminalKind::YulOverrideKeyword,
                            304 => TerminalKind::YulPartialKeyword,
                            305 => TerminalKind::YulPayableKeyword,
                            306 => TerminalKind::YulPopKeyword,
                            307 => TerminalKind::YulPragmaKeyword,
                            308 => TerminalKind::YulPrevRandaoKeyword,
                            309 => TerminalKind::YulPrivateKeyword,
                            310 => TerminalKind::YulPromiseKeyword,
                            311 => TerminalKind::YulPublicKeyword,
                            312 => TerminalKind::YulPureKeyword,
                            313 => TerminalKind::YulReceiveKeyword,
                            314 => TerminalKind::YulReferenceKeyword,
                            315 => TerminalKind::YulRelocatableKeyword,
                            316 => TerminalKind::YulReturnDataCopyKeyword,
                            317 => TerminalKind::YulReturnDataSizeKeyword,
                            318 => TerminalKind::YulReturnKeyword,
                            319 => TerminalKind::YulReturnsKeyword,
                            320 => TerminalKind::YulRevertKeyword,
                            321 => TerminalKind::YulSdivKeyword,
                            322 => TerminalKind::YulSloadKeyword,
                            323 => TerminalKind::YulSmodKeyword,
                            324 => TerminalKind::YulSstoreKeyword,
                            325 => TerminalKind::YulSarKeyword,
                            326 => TerminalKind::YulSealedKeyword,
                            327 => TerminalKind::YulSecondsKeyword,
                            328 => TerminalKind::YulSelfBalanceKeyword,
                            329 => TerminalKind::YulSelfDestructKeyword,
                            330 => TerminalKind::YulSgtKeyword,
                            331 => TerminalKind::YulSha3Keyword,
                            332 => TerminalKind::YulShlKeyword,
                            333 => TerminalKind::YulShrKeyword,
                            334 => TerminalKind::YulSignExtendKeyword,
                            335 => TerminalKind::YulSizeOfKeyword,
                            336 => TerminalKind::YulSltKeyword,
                            337 => TerminalKind::YulStaticCallKeyword,
                            338 => TerminalKind::YulStaticKeyword,
                            339 => TerminalKind::YulStopKeyword,
                            340 => TerminalKind::YulStorageKeyword,
                            341 => TerminalKind::YulStringKeyword,
                            342 => TerminalKind::YulStructKeyword,
                            343 => TerminalKind::YulSubKeyword,
                            344 => TerminalKind::YulSuicideKeyword,
                            345 => TerminalKind::YulSupportsKeyword,
                            346 => TerminalKind::YulSwitchKeyword,
                            347 => TerminalKind::YulSzaboKeyword,
                            348 => TerminalKind::YulTloadKeyword,
                            349 => TerminalKind::YulTstoreKeyword,
                            350 => TerminalKind::YulThrowKeyword,
                            351 => TerminalKind::YulTimestampKeyword,
                            352 => TerminalKind::YulTrueKeyword,
                            353 => TerminalKind::YulTryKeyword,
                            354 => TerminalKind::YulTypeDefKeyword,
                            355 => TerminalKind::YulTypeKeyword,
                            356 => TerminalKind::YulTypeOfKeyword,
                            357 => TerminalKind::YulUfixedKeyword,
                            358 => TerminalKind::YulUintKeyword,
                            359 => TerminalKind::YulUncheckedKeyword,
                            360 => TerminalKind::YulUsingKeyword,
                            361 => TerminalKind::YulVarKeyword,
                            362 => TerminalKind::YulViewKeyword,
                            363 => TerminalKind::YulVirtualKeyword,
                            364 => TerminalKind::YulWeeksKeyword,
                            365 => TerminalKind::YulWeiKeyword,
                            366 => TerminalKind::YulWhileKeyword,
                            367 => TerminalKind::YulXorKeyword,
                            368 => TerminalKind::YulYearsKeyword,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_kinds_0_16_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_kinds_0_16_0_cabi;
            }

            #[allow(dead_code, clippy::all)]
            pub mod text_index {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct TextIndex {
                    pub utf8: u32,
                    pub utf16: u32,
                    pub line: u32,
                    pub column: u32,
                }
                impl ::core::fmt::Debug for TextIndex {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TextIndex")
                            .field("utf8", &self.utf8)
                            .field("utf16", &self.utf16)
                            .field("line", &self.line)
                            .field("column", &self.column)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct TextRange {
                    pub start: TextIndex,
                    pub end: TextIndex,
                }
                impl ::core::fmt::Debug for TextRange {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TextRange")
                            .field("start", &self.start)
                            .field("end", &self.end)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_text_index_0_16_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_text_index_0_16_0_cabi;
            }

            #[allow(dead_code, clippy::all)]
            pub mod cst {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type NonterminalKind = super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind;
                pub type TerminalKind = super::super::super::super::exports::nomic_foundation::slang::kinds::TerminalKind;
                pub type TextIndex = super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct NonterminalNode {
                    handle: _rt::Resource<NonterminalNode>,
                }

                type _NonterminalNodeRep<T> = Option<T>;

                impl NonterminalNode {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `NonterminalNode`.
                    pub fn new<T: GuestNonterminalNode>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _NonterminalNodeRep<T> = Some(val);
                        let ptr: *mut _NonterminalNodeRep<T> =
                            _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestNonterminalNode>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestNonterminalNode>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestNonterminalNode>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestNonterminalNode` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _NonterminalNodeRep<T>);
                    }

                    fn as_ptr<T: GuestNonterminalNode>(&self) -> *mut _NonterminalNodeRep<T> {
                        NonterminalNode::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`NonterminalNode`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct NonterminalNodeBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a NonterminalNode>,
                }

                impl<'a> NonterminalNodeBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestNonterminalNode>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _NonterminalNodeRep<T> {
                        NonterminalNode::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for NonterminalNode {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]nonterminal-node"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct TerminalNode {
                    handle: _rt::Resource<TerminalNode>,
                }

                type _TerminalNodeRep<T> = Option<T>;

                impl TerminalNode {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `TerminalNode`.
                    pub fn new<T: GuestTerminalNode>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _TerminalNodeRep<T> = Some(val);
                        let ptr: *mut _TerminalNodeRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestTerminalNode>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestTerminalNode>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestTerminalNode>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestTerminalNode` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _TerminalNodeRep<T>);
                    }

                    fn as_ptr<T: GuestTerminalNode>(&self) -> *mut _TerminalNodeRep<T> {
                        TerminalNode::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`TerminalNode`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct TerminalNodeBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a TerminalNode>,
                }

                impl<'a> TerminalNodeBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestTerminalNode>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _TerminalNodeRep<T> {
                        TerminalNode::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for TerminalNode {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]terminal-node"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                pub enum Node {
                    Nonterminal(NonterminalNode),
                    Terminal(TerminalNode),
                }
                impl ::core::fmt::Debug for Node {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Node::Nonterminal(e) => {
                                f.debug_tuple("Node::Nonterminal").field(e).finish()
                            }
                            Node::Terminal(e) => f.debug_tuple("Node::Terminal").field(e).finish(),
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_nonterminal_node_kind_cabi<T: GuestNonterminalNode>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::kind(NonterminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_nonterminal_node_text_len_cabi<
                    T: GuestNonterminalNode,
                >(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::text_len(NonterminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf82, utf16:utf162, line:line2, column:column2, } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(utf82);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(utf162);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(line2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(column2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_nonterminal_node_children_cabi<
                    T: GuestNonterminalNode,
                >(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::children(NonterminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 8);
                        {
                            match e {
                                Node::Nonterminal(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    *base.add(4).cast::<i32>() = (e).take_handle() as i32;
                                }
                                Node::Terminal(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    *base.add(4).cast::<i32>() = (e).take_handle() as i32;
                                }
                            }
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_nonterminal_node_children<
                    T: GuestNonterminalNode,
                >(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 8, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_nonterminal_node_unparse_cabi<
                    T: GuestNonterminalNode,
                >(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::unparse(NonterminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_nonterminal_node_unparse<
                    T: GuestNonterminalNode,
                >(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_terminal_node_kind_cabi<T: GuestTerminalNode>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::kind(TerminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_terminal_node_text_len_cabi<T: GuestTerminalNode>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::text_len(TerminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf82, utf16:utf162, line:line2, column:column2, } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(utf82);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(utf162);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(line2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(column2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_terminal_node_text_cabi<T: GuestTerminalNode>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::text(TerminalNodeBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_terminal_node_text<T: GuestTerminalNode>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    type NonterminalNode: GuestNonterminalNode;
                    type TerminalNode: GuestTerminalNode;
                }
                pub trait GuestNonterminalNode: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]nonterminal-node"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]nonterminal-node"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn kind(&self) -> NonterminalKind;
                    fn text_len(&self) -> TextIndex;
                    fn children(&self) -> _rt::Vec<Node>;
                    /// TODO: re-enable once we solve circular references:
                    /// create-cursor: func(text-offset: text-index) -> cursor;
                    fn unparse(&self) -> _rt::String;
                }
                pub trait GuestTerminalNode: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]terminal-node"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cst@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]terminal-node"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn kind(&self) -> TerminalKind;
                    fn text_len(&self) -> TextIndex;
                    fn text(&self) -> _rt::String;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_cst_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.kind"]
    unsafe extern "C" fn export_method_nonterminal_node_kind(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_nonterminal_node_kind_cabi::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.text-len"]
    unsafe extern "C" fn export_method_nonterminal_node_text_len(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_nonterminal_node_text_len_cabi::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.children"]
    unsafe extern "C" fn export_method_nonterminal_node_children(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_nonterminal_node_children_cabi::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.children"]
    unsafe extern "C" fn _post_return_method_nonterminal_node_children(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_nonterminal_node_children::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.unparse"]
    unsafe extern "C" fn export_method_nonterminal_node_unparse(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_nonterminal_node_unparse_cabi::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/cst@0.16.0#[method]nonterminal-node.unparse"]
    unsafe extern "C" fn _post_return_method_nonterminal_node_unparse(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_nonterminal_node_unparse::<<$ty as $($path_to_types)*::Guest>::NonterminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]terminal-node.kind"]
    unsafe extern "C" fn export_method_terminal_node_kind(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_terminal_node_kind_cabi::<<$ty as $($path_to_types)*::Guest>::TerminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]terminal-node.text-len"]
    unsafe extern "C" fn export_method_terminal_node_text_len(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_terminal_node_text_len_cabi::<<$ty as $($path_to_types)*::Guest>::TerminalNode>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cst@0.16.0#[method]terminal-node.text"]
    unsafe extern "C" fn export_method_terminal_node_text(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_terminal_node_text_cabi::<<$ty as $($path_to_types)*::Guest>::TerminalNode>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/cst@0.16.0#[method]terminal-node.text"]
    unsafe extern "C" fn _post_return_method_terminal_node_text(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_terminal_node_text::<<$ty as $($path_to_types)*::Guest>::TerminalNode>(arg0)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/cst@0.16.0#[dtor]nonterminal-node"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::NonterminalNode::dtor::<
        <$ty as $($path_to_types)*::Guest>::NonterminalNode
        >(rep)
      }
    };


    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/cst@0.16.0#[dtor]terminal-node"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::TerminalNode::dtor::<
        <$ty as $($path_to_types)*::Guest>::TerminalNode
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_cst_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod cursor {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Node =
                    super::super::super::super::exports::nomic_foundation::slang::cst::Node;
                pub type NonterminalNode = super::super::super::super::exports::nomic_foundation::slang::cst::NonterminalNode;
                pub type NonterminalNodeBorrow<'a> = super::super::super::super::exports::nomic_foundation::slang::cst::NonterminalNodeBorrow<'a>;
                pub type EdgeLabel =
                    super::super::super::super::exports::nomic_foundation::slang::kinds::EdgeLabel;
                pub type NonterminalKind = super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind;
                pub type TerminalKind = super::super::super::super::exports::nomic_foundation::slang::kinds::TerminalKind;
                pub type TextIndex = super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex;
                pub type TextRange = super::super::super::super::exports::nomic_foundation::slang::text_index::TextRange;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Cursor {
                    handle: _rt::Resource<Cursor>,
                }

                type _CursorRep<T> = Option<T>;

                impl Cursor {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Cursor`.
                    pub fn new<T: GuestCursor>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _CursorRep<T> = Some(val);
                        let ptr: *mut _CursorRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestCursor>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestCursor>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestCursor>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestCursor` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _CursorRep<T>);
                    }

                    fn as_ptr<T: GuestCursor>(&self) -> *mut _CursorRep<T> {
                        Cursor::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`Cursor`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct CursorBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Cursor>,
                }

                impl<'a> CursorBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestCursor>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _CursorRep<T> {
                        Cursor::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for Cursor {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cursor@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]cursor"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_reset_cabi<T: GuestCursor>(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    T::reset(CursorBorrow::lift(arg0 as u32 as usize).get());
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_complete_cabi<T: GuestCursor>(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    T::complete(CursorBorrow::lift(arg0 as u32 as usize).get());
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_is_completed_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::is_completed(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_clone_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::clone(CursorBorrow::lift(arg0 as u32 as usize).get());
                    (result0).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_spawn_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::spawn(CursorBorrow::lift(arg0 as u32 as usize).get());
                    (result0).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_node_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::node(CursorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    use super::super::super::super::exports::nomic_foundation::slang::cst::Node as V2;
                    match result0 {
                        V2::Nonterminal(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                        V2::Terminal(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_label_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::label(CursorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(1).cast::<u8>() = (e.clone() as i32) as u8;
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_text_offset_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::text_offset(CursorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf82, utf16:utf162, line:line2, column:column2, } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(utf82);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(utf162);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(line2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(column2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_text_range_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::text_range(CursorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextRange{ start:start2, end:end2, } = result0;
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf83, utf16:utf163, line:line3, column:column3, } = start2;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(utf83);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(utf163);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(line3);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(column3);
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf84, utf16:utf164, line:line4, column:column4, } = end2;
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(utf84);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(utf164);
                    *ptr1.add(24).cast::<i32>() = _rt::as_i32(line4);
                    *ptr1.add(28).cast::<i32>() = _rt::as_i32(column4);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_depth_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::depth(CursorBorrow::lift(arg0 as u32 as usize).get());
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_ancestors_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::ancestors(CursorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 4, 4);
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_cursor_ancestors<T: GuestCursor>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 4, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_next(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_non_descendent_cabi<
                    T: GuestCursor,
                >(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_next_non_descendent(
                        CursorBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_previous_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_previous(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_parent_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_parent(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_first_child_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_first_child(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_last_child_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_last_child(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_nth_child_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_nth_child(
                        CursorBorrow::lift(arg0 as u32 as usize).get(),
                        arg1 as u32,
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_sibling_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_next_sibling(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_previous_sibling_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_previous_sibling(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_terminal_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_next_terminal(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_terminal_with_kind_cabi<
                    T: GuestCursor,
                >(
                    arg0: *mut u8,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_next_terminal_with_kind(CursorBorrow::lift(arg0 as u32 as usize).get(), super::super::super::super::exports::nomic_foundation::slang::kinds::TerminalKind::_lift(arg1 as u16));
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_terminal_with_kinds_cabi<
                    T: GuestCursor,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let base1 = arg1;
                    let len1 = arg2;
                    let mut result1 = _rt::Vec::with_capacity(len1);
                    for i in 0..len1 {
                        let base = base1.add(i * 2);
                        let e1 = {
                            let l0 = i32::from(*base.add(0).cast::<u16>());

                            super::super::super::super::exports::nomic_foundation::slang::kinds::TerminalKind::_lift(l0 as u16)
                        };
                        result1.push(e1);
                    }
                    _rt::cabi_dealloc(base1, len1 * 2, 2);
                    let result2 = T::go_to_next_terminal_with_kinds(
                        CursorBorrow::lift(arg0 as u32 as usize).get(),
                        result1,
                    );
                    match result2 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_nonterminal_cabi<T: GuestCursor>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::go_to_next_nonterminal(CursorBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_nonterminal_with_kind_cabi<
                    T: GuestCursor,
                >(
                    arg0: *mut u8,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::go_to_next_nonterminal_with_kind(CursorBorrow::lift(arg0 as u32 as usize).get(), super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind::_lift(arg1 as u8));
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_cursor_go_to_next_nonterminal_with_kinds_cabi<
                    T: GuestCursor,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let base1 = arg1;
                    let len1 = arg2;
                    let mut result1 = _rt::Vec::with_capacity(len1);
                    for i in 0..len1 {
                        let base = base1.add(i * 1);
                        let e1 = {
                            let l0 = i32::from(*base.add(0).cast::<u8>());

                            super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind::_lift(l0 as u8)
                        };
                        result1.push(e1);
                    }
                    _rt::cabi_dealloc(base1, len1 * 1, 1);
                    let result2 = T::go_to_next_nonterminal_with_kinds(
                        CursorBorrow::lift(arg0 as u32 as usize).get(),
                        result1,
                    );
                    match result2 {
                        true => 1,
                        false => 0,
                    }
                }
                pub trait Guest {
                    type Cursor: GuestCursor;
                }
                pub trait GuestCursor: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cursor@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]cursor"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/cursor@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]cursor"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn reset(&self);
                    fn complete(&self);
                    fn is_completed(&self) -> bool;
                    fn clone(&self) -> Cursor;
                    fn spawn(&self) -> Cursor;
                    fn node(&self) -> Node;
                    fn label(&self) -> Option<EdgeLabel>;
                    fn text_offset(&self) -> TextIndex;
                    fn text_range(&self) -> TextRange;
                    fn depth(&self) -> u32;
                    fn ancestors(&self) -> _rt::Vec<NonterminalNode>;
                    fn go_to_next(&self) -> bool;
                    fn go_to_next_non_descendent(&self) -> bool;
                    fn go_to_previous(&self) -> bool;
                    fn go_to_parent(&self) -> bool;
                    fn go_to_first_child(&self) -> bool;
                    fn go_to_last_child(&self) -> bool;
                    fn go_to_nth_child(&self, child_number: u32) -> bool;
                    fn go_to_next_sibling(&self) -> bool;
                    fn go_to_previous_sibling(&self) -> bool;
                    fn go_to_next_terminal(&self) -> bool;
                    fn go_to_next_terminal_with_kind(&self, kind: TerminalKind) -> bool;
                    fn go_to_next_terminal_with_kinds(&self, kinds: _rt::Vec<TerminalKind>)
                        -> bool;
                    fn go_to_next_nonterminal(&self) -> bool;
                    fn go_to_next_nonterminal_with_kind(&self, kind: NonterminalKind) -> bool;
                    fn go_to_next_nonterminal_with_kinds(
                        &self,
                        kinds: _rt::Vec<NonterminalKind>,
                    ) -> bool;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_cursor_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.reset"]
    unsafe extern "C" fn export_method_cursor_reset(arg0: *mut u8,) {
      $($path_to_types)*::_export_method_cursor_reset_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.complete"]
    unsafe extern "C" fn export_method_cursor_complete(arg0: *mut u8,) {
      $($path_to_types)*::_export_method_cursor_complete_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.is-completed"]
    unsafe extern "C" fn export_method_cursor_is_completed(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_is_completed_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.clone"]
    unsafe extern "C" fn export_method_cursor_clone(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_clone_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.spawn"]
    unsafe extern "C" fn export_method_cursor_spawn(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_spawn_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.node"]
    unsafe extern "C" fn export_method_cursor_node(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_cursor_node_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.label"]
    unsafe extern "C" fn export_method_cursor_label(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_cursor_label_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.text-offset"]
    unsafe extern "C" fn export_method_cursor_text_offset(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_cursor_text_offset_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.text-range"]
    unsafe extern "C" fn export_method_cursor_text_range(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_cursor_text_range_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.depth"]
    unsafe extern "C" fn export_method_cursor_depth(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_depth_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.ancestors"]
    unsafe extern "C" fn export_method_cursor_ancestors(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_cursor_ancestors_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/cursor@0.16.0#[method]cursor.ancestors"]
    unsafe extern "C" fn _post_return_method_cursor_ancestors(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_cursor_ancestors::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next"]
    unsafe extern "C" fn export_method_cursor_go_to_next(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-non-descendent"]
    unsafe extern "C" fn export_method_cursor_go_to_next_non_descendent(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_non_descendent_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-previous"]
    unsafe extern "C" fn export_method_cursor_go_to_previous(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_previous_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-parent"]
    unsafe extern "C" fn export_method_cursor_go_to_parent(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_parent_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-first-child"]
    unsafe extern "C" fn export_method_cursor_go_to_first_child(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_first_child_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-last-child"]
    unsafe extern "C" fn export_method_cursor_go_to_last_child(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_last_child_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-nth-child"]
    unsafe extern "C" fn export_method_cursor_go_to_nth_child(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_nth_child_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0, arg1)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-sibling"]
    unsafe extern "C" fn export_method_cursor_go_to_next_sibling(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_sibling_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-previous-sibling"]
    unsafe extern "C" fn export_method_cursor_go_to_previous_sibling(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_previous_sibling_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-terminal"]
    unsafe extern "C" fn export_method_cursor_go_to_next_terminal(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_terminal_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-terminal-with-kind"]
    unsafe extern "C" fn export_method_cursor_go_to_next_terminal_with_kind(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_terminal_with_kind_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0, arg1)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-terminal-with-kinds"]
    unsafe extern "C" fn export_method_cursor_go_to_next_terminal_with_kinds(arg0: *mut u8,arg1: *mut u8,arg2: usize,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_terminal_with_kinds_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0, arg1, arg2)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-nonterminal"]
    unsafe extern "C" fn export_method_cursor_go_to_next_nonterminal(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_nonterminal_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-nonterminal-with-kind"]
    unsafe extern "C" fn export_method_cursor_go_to_next_nonterminal_with_kind(arg0: *mut u8,arg1: i32,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_nonterminal_with_kind_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0, arg1)
    }
    #[export_name = "nomic-foundation:slang/cursor@0.16.0#[method]cursor.go-to-next-nonterminal-with-kinds"]
    unsafe extern "C" fn export_method_cursor_go_to_next_nonterminal_with_kinds(arg0: *mut u8,arg1: *mut u8,arg2: usize,) -> i32 {
      $($path_to_types)*::_export_method_cursor_go_to_next_nonterminal_with_kinds_cabi::<<$ty as $($path_to_types)*::Guest>::Cursor>(arg0, arg1, arg2)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/cursor@0.16.0#[dtor]cursor"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::Cursor::dtor::<
        <$ty as $($path_to_types)*::Guest>::Cursor
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_cursor_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod diagnostic {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum Severity {
                    Error,
                    Warning,
                    Information,
                    Hint,
                }
                impl ::core::fmt::Debug for Severity {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Severity::Error => f.debug_tuple("Severity::Error").finish(),
                            Severity::Warning => f.debug_tuple("Severity::Warning").finish(),
                            Severity::Information => {
                                f.debug_tuple("Severity::Information").finish()
                            }
                            Severity::Hint => f.debug_tuple("Severity::Hint").finish(),
                        }
                    }
                }

                impl Severity {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Severity {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => Severity::Error,
                            1 => Severity::Warning,
                            2 => Severity::Information,
                            3 => Severity::Hint,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_diagnostic_0_16_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_diagnostic_0_16_0_cabi;
            }

            #[allow(dead_code, clippy::all)]
            pub mod parse_error {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Severity = super::super::super::super::exports::nomic_foundation::slang::diagnostic::Severity;
                pub type TextRange = super::super::super::super::exports::nomic_foundation::slang::text_index::TextRange;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct ParseError {
                    handle: _rt::Resource<ParseError>,
                }

                type _ParseErrorRep<T> = Option<T>;

                impl ParseError {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `ParseError`.
                    pub fn new<T: GuestParseError>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _ParseErrorRep<T> = Some(val);
                        let ptr: *mut _ParseErrorRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestParseError>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestParseError>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestParseError>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestParseError` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _ParseErrorRep<T>);
                    }

                    fn as_ptr<T: GuestParseError>(&self) -> *mut _ParseErrorRep<T> {
                        ParseError::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`ParseError`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct ParseErrorBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a ParseError>,
                }

                impl<'a> ParseErrorBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestParseError>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _ParseErrorRep<T> {
                        ParseError::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for ParseError {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-error@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]parse-error"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_error_severity_cabi<T: GuestParseError>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::severity(ParseErrorBorrow::lift(arg0 as u32 as usize).get());
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_error_text_range_cabi<T: GuestParseError>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::text_range(ParseErrorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextRange{ start:start2, end:end2, } = result0;
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf83, utf16:utf163, line:line3, column:column3, } = start2;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(utf83);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(utf163);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(line3);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(column3);
                    let super::super::super::super::exports::nomic_foundation::slang::text_index::TextIndex{ utf8:utf84, utf16:utf164, line:line4, column:column4, } = end2;
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(utf84);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(utf164);
                    *ptr1.add(24).cast::<i32>() = _rt::as_i32(line4);
                    *ptr1.add(28).cast::<i32>() = _rt::as_i32(column4);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_error_message_cabi<T: GuestParseError>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::message(ParseErrorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_parse_error_message<T: GuestParseError>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    type ParseError: GuestParseError;
                }
                pub trait GuestParseError: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-error@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]parse-error"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-error@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]parse-error"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn severity(&self) -> Severity;
                    fn text_range(&self) -> TextRange;
                    fn message(&self) -> _rt::String;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_parse_error_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/parse-error@0.16.0#[method]parse-error.severity"]
    unsafe extern "C" fn export_method_parse_error_severity(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_parse_error_severity_cabi::<<$ty as $($path_to_types)*::Guest>::ParseError>(arg0)
    }
    #[export_name = "nomic-foundation:slang/parse-error@0.16.0#[method]parse-error.text-range"]
    unsafe extern "C" fn export_method_parse_error_text_range(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_parse_error_text_range_cabi::<<$ty as $($path_to_types)*::Guest>::ParseError>(arg0)
    }
    #[export_name = "nomic-foundation:slang/parse-error@0.16.0#[method]parse-error.message"]
    unsafe extern "C" fn export_method_parse_error_message(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_parse_error_message_cabi::<<$ty as $($path_to_types)*::Guest>::ParseError>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/parse-error@0.16.0#[method]parse-error.message"]
    unsafe extern "C" fn _post_return_method_parse_error_message(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_parse_error_message::<<$ty as $($path_to_types)*::Guest>::ParseError>(arg0)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/parse-error@0.16.0#[dtor]parse-error"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::ParseError::dtor::<
        <$ty as $($path_to_types)*::Guest>::ParseError
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_parse_error_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod parse_output {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Node =
                    super::super::super::super::exports::nomic_foundation::slang::cst::Node;
                pub type Cursor =
                    super::super::super::super::exports::nomic_foundation::slang::cursor::Cursor;
                pub type CursorBorrow<'a> = super::super::super::super::exports::nomic_foundation::slang::cursor::CursorBorrow<'a>;
                pub type ParseError = super::super::super::super::exports::nomic_foundation::slang::parse_error::ParseError;
                pub type ParseErrorBorrow<'a> = super::super::super::super::exports::nomic_foundation::slang::parse_error::ParseErrorBorrow<'a>;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct ParseOutput {
                    handle: _rt::Resource<ParseOutput>,
                }

                type _ParseOutputRep<T> = Option<T>;

                impl ParseOutput {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `ParseOutput`.
                    pub fn new<T: GuestParseOutput>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _ParseOutputRep<T> = Some(val);
                        let ptr: *mut _ParseOutputRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestParseOutput>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestParseOutput>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestParseOutput>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestParseOutput` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _ParseOutputRep<T>);
                    }

                    fn as_ptr<T: GuestParseOutput>(&self) -> *mut _ParseOutputRep<T> {
                        ParseOutput::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`ParseOutput`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct ParseOutputBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a ParseOutput>,
                }

                impl<'a> ParseOutputBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestParseOutput>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _ParseOutputRep<T> {
                        ParseOutput::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for ParseOutput {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-output@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]parse-output"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_output_tree_cabi<T: GuestParseOutput>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::tree(ParseOutputBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    use super::super::super::super::exports::nomic_foundation::slang::cst::Node as V2;
                    match result0 {
                        V2::Nonterminal(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                        V2::Terminal(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_output_errors_cabi<T: GuestParseOutput>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::errors(ParseOutputBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 4, 4);
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_parse_output_errors<T: GuestParseOutput>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 4, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_output_is_valid_cabi<T: GuestParseOutput>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::is_valid(ParseOutputBorrow::lift(arg0 as u32 as usize).get());
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_parse_output_create_tree_cursor_cabi<
                    T: GuestParseOutput,
                >(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::create_tree_cursor(ParseOutputBorrow::lift(arg0 as u32 as usize).get());
                    (result0).take_handle() as i32
                }
                pub trait Guest {
                    type ParseOutput: GuestParseOutput;
                }
                pub trait GuestParseOutput: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-output@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]parse-output"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/parse-output@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]parse-output"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn tree(&self) -> Node;
                    fn errors(&self) -> _rt::Vec<ParseError>;
                    fn is_valid(&self) -> bool;
                    fn create_tree_cursor(&self) -> Cursor;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_parse_output_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/parse-output@0.16.0#[method]parse-output.tree"]
    unsafe extern "C" fn export_method_parse_output_tree(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_parse_output_tree_cabi::<<$ty as $($path_to_types)*::Guest>::ParseOutput>(arg0)
    }
    #[export_name = "nomic-foundation:slang/parse-output@0.16.0#[method]parse-output.errors"]
    unsafe extern "C" fn export_method_parse_output_errors(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_parse_output_errors_cabi::<<$ty as $($path_to_types)*::Guest>::ParseOutput>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/parse-output@0.16.0#[method]parse-output.errors"]
    unsafe extern "C" fn _post_return_method_parse_output_errors(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_parse_output_errors::<<$ty as $($path_to_types)*::Guest>::ParseOutput>(arg0)
    }
    #[export_name = "nomic-foundation:slang/parse-output@0.16.0#[method]parse-output.is-valid"]
    unsafe extern "C" fn export_method_parse_output_is_valid(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_parse_output_is_valid_cabi::<<$ty as $($path_to_types)*::Guest>::ParseOutput>(arg0)
    }
    #[export_name = "nomic-foundation:slang/parse-output@0.16.0#[method]parse-output.create-tree-cursor"]
    unsafe extern "C" fn export_method_parse_output_create_tree_cursor(arg0: *mut u8,) -> i32 {
      $($path_to_types)*::_export_method_parse_output_create_tree_cursor_cabi::<<$ty as $($path_to_types)*::Guest>::ParseOutput>(arg0)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/parse-output@0.16.0#[dtor]parse-output"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::ParseOutput::dtor::<
        <$ty as $($path_to_types)*::Guest>::ParseOutput
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_parse_output_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod language {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type NonterminalKind = super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind;
                pub type ParseOutput = super::super::super::super::exports::nomic_foundation::slang::parse_output::ParseOutput;
                pub type ParseOutputBorrow<'a> = super::super::super::super::exports::nomic_foundation::slang::parse_output::ParseOutputBorrow<'a>;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Language {
                    handle: _rt::Resource<Language>,
                }

                type _LanguageRep<T> = Option<T>;

                impl Language {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Language`.
                    pub fn new<T: GuestLanguage>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _LanguageRep<T> = Some(val);
                        let ptr: *mut _LanguageRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestLanguage>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestLanguage>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestLanguage>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestLanguage` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _LanguageRep<T>);
                    }

                    fn as_ptr<T: GuestLanguage>(&self) -> *mut _LanguageRep<T> {
                        Language::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`Language`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct LanguageBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Language>,
                }

                impl<'a> LanguageBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestLanguage>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _LanguageRep<T> {
                        Language::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for Language {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/language@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]language"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_static_language_supported_versions_cabi<T: GuestLanguage>(
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::supported_versions();
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec3 = result0;
                    let len3 = vec3.len();
                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 8, 4);
                    let result3 = if layout3.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3.add(i * 8);
                        {
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = result3;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_static_language_supported_versions<T: GuestLanguage>(
                    arg0: *mut u8,
                ) {
                    let l2 = *arg0.add(0).cast::<*mut u8>();
                    let l3 = *arg0.add(4).cast::<usize>();
                    let base4 = l2;
                    let len4 = l3;
                    for i in 0..len4 {
                        let base = base4.add(i * 8);
                        {
                            let l0 = *base.add(0).cast::<*mut u8>();
                            let l1 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l0, l1, 1);
                        }
                    }
                    _rt::cabi_dealloc(base4, len4 * 8, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_static_language_new_cabi<T: GuestLanguage>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::new(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr2.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2.add(8).cast::<usize>() = len3;
                            *ptr2.add(4).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_static_language_new<T: GuestLanguage>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => (),
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_language_version_cabi<T: GuestLanguage>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::version(LanguageBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_language_version<T: GuestLanguage>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_language_parse_cabi<T: GuestLanguage>(
                    arg0: *mut u8,
                    arg1: i32,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg3;
                    let bytes0 = _rt::Vec::from_raw_parts(arg2.cast(), len0, len0);
                    let result1 = T::parse(LanguageBorrow::lift(arg0 as u32 as usize).get(), super::super::super::super::exports::nomic_foundation::slang::kinds::NonterminalKind::_lift(arg1 as u8), _rt::string_lift(bytes0));
                    (result1).take_handle() as i32
                }
                pub trait Guest {
                    type Language: GuestLanguage;
                }
                pub trait GuestLanguage: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/language@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]language"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/language@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]language"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn supported_versions() -> _rt::Vec<_rt::String>;
                    fn new(version: _rt::String) -> Result<Language, _rt::String>;
                    fn version(&self) -> _rt::String;
                    fn parse(&self, kind: NonterminalKind, input: _rt::String) -> ParseOutput;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_language_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/language@0.16.0#[static]language.supported-versions"]
    unsafe extern "C" fn export_static_language_supported_versions() -> *mut u8 {
      $($path_to_types)*::_export_static_language_supported_versions_cabi::<<$ty as $($path_to_types)*::Guest>::Language>()
    }
    #[export_name = "cabi_post_nomic-foundation:slang/language@0.16.0#[static]language.supported-versions"]
    unsafe extern "C" fn _post_return_static_language_supported_versions(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_static_language_supported_versions::<<$ty as $($path_to_types)*::Guest>::Language>(arg0)
    }
    #[export_name = "nomic-foundation:slang/language@0.16.0#[static]language.new"]
    unsafe extern "C" fn export_static_language_new(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_static_language_new_cabi::<<$ty as $($path_to_types)*::Guest>::Language>(arg0, arg1)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/language@0.16.0#[static]language.new"]
    unsafe extern "C" fn _post_return_static_language_new(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_static_language_new::<<$ty as $($path_to_types)*::Guest>::Language>(arg0)
    }
    #[export_name = "nomic-foundation:slang/language@0.16.0#[method]language.version"]
    unsafe extern "C" fn export_method_language_version(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_language_version_cabi::<<$ty as $($path_to_types)*::Guest>::Language>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/language@0.16.0#[method]language.version"]
    unsafe extern "C" fn _post_return_method_language_version(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_language_version::<<$ty as $($path_to_types)*::Guest>::Language>(arg0)
    }
    #[export_name = "nomic-foundation:slang/language@0.16.0#[method]language.parse"]
    unsafe extern "C" fn export_method_language_parse(arg0: *mut u8,arg1: i32,arg2: *mut u8,arg3: usize,) -> i32 {
      $($path_to_types)*::_export_method_language_parse_cabi::<<$ty as $($path_to_types)*::Guest>::Language>(arg0, arg1, arg2, arg3)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/language@0.16.0#[dtor]language"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::Language::dtor::<
        <$ty as $($path_to_types)*::Guest>::Language
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_language_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod query {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Cursor =
                    super::super::super::super::exports::nomic_foundation::slang::cursor::Cursor;
                pub type CursorBorrow<'a> = super::super::super::super::exports::nomic_foundation::slang::cursor::CursorBorrow<'a>;

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Query {
                    handle: _rt::Resource<Query>,
                }

                type _QueryRep<T> = Option<T>;

                impl Query {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Query`.
                    pub fn new<T: GuestQuery>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _QueryRep<T> = Some(val);
                        let ptr: *mut _QueryRep<T> = _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestQuery>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestQuery>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestQuery>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestQuery` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _QueryRep<T>);
                    }

                    fn as_ptr<T: GuestQuery>(&self) -> *mut _QueryRep<T> {
                        Query::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`Query`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct QueryBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Query>,
                }

                impl<'a> QueryBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestQuery>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _QueryRep<T> {
                        Query::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for Query {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]query"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[derive(Clone)]
                pub struct QueryError {
                    pub message: _rt::String,
                    pub row: u32,
                    pub column: u32,
                }
                impl ::core::fmt::Debug for QueryError {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("QueryError")
                            .field("message", &self.message)
                            .field("row", &self.row)
                            .field("column", &self.column)
                            .finish()
                    }
                }
                impl ::core::fmt::Display for QueryError {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                    }
                }
                impl std::error::Error for QueryError {}
                pub struct QueryMatch {
                    pub query_number: u32,
                    pub captures: _rt::Vec<(_rt::String, _rt::Vec<Cursor>)>,
                }
                impl ::core::fmt::Debug for QueryMatch {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("QueryMatch")
                            .field("query-number", &self.query_number)
                            .field("captures", &self.captures)
                            .finish()
                    }
                }

                #[derive(Debug)]
                #[repr(transparent)]
                pub struct QueryMatchIterator {
                    handle: _rt::Resource<QueryMatchIterator>,
                }

                type _QueryMatchIteratorRep<T> = Option<T>;

                impl QueryMatchIterator {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `QueryMatchIterator`.
                    pub fn new<T: GuestQueryMatchIterator>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _QueryMatchIteratorRep<T> = Some(val);
                        let ptr: *mut _QueryMatchIteratorRep<T> =
                            _rt::Box::into_raw(_rt::Box::new(val));
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }

                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestQueryMatchIterator>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestQueryMatchIterator>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }

                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestQueryMatchIterator>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }

                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }

                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }

                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }

                    // It's theoretically possible to implement the `GuestQueryMatchIterator` trait twice
                    // so guard against using it with two different types here.
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(!cfg!(target_feature = "threads"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => assert!(
                                    ty == id,
                                    "cannot use two types with this resource type"
                                ),
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }

                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _QueryMatchIteratorRep<T>);
                    }

                    fn as_ptr<T: GuestQueryMatchIterator>(&self) -> *mut _QueryMatchIteratorRep<T> {
                        QueryMatchIterator::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }

                /// A borrowed version of [`QueryMatchIterator`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct QueryMatchIteratorBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a QueryMatchIterator>,
                }

                impl<'a> QueryMatchIteratorBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }

                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestQueryMatchIterator>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }

                    // NB: mutable access is not allowed due to the component model allowing
                    // multiple borrows of the same resource.

                    fn as_ptr<T: 'static>(&self) -> *mut _QueryMatchIteratorRep<T> {
                        QueryMatchIterator::type_guard::<T>();
                        self.rep.cast()
                    }
                }

                unsafe impl _rt::WasmResource for QueryMatchIterator {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]query-match-iterator"]
                                fn drop(_: u32);
                            }

                            drop(_handle);
                        }
                    }
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_static_query_parse_cabi<T: GuestQuery>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::parse(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr2.add(4).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let QueryError {
                                message: message3,
                                row: row3,
                                column: column3,
                            } = e;
                            let vec4 = (message3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2.add(8).cast::<usize>() = len4;
                            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
                            *ptr2.add(12).cast::<i32>() = _rt::as_i32(row3);
                            *ptr2.add(16).cast::<i32>() = _rt::as_i32(column3);
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_static_query_parse<T: GuestQuery>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => (),
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_query_match_iterator_next_cabi<
                    T: GuestQueryMatchIterator,
                >(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 =
                        T::next(QueryMatchIteratorBorrow::lift(arg0 as u32 as usize).get());
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let QueryMatch {
                                query_number: query_number2,
                                captures: captures2,
                            } = e;
                            *ptr1.add(4).cast::<i32>() = _rt::as_i32(query_number2);
                            let vec6 = captures2;
                            let len6 = vec6.len();
                            let layout6 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 16, 4);
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 16);
                                {
                                    let (t3_0, t3_1) = e;
                                    let vec4 = (t3_0.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base.add(4).cast::<usize>() = len4;
                                    *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = t3_1;
                                    let len5 = vec5.len();
                                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec5.len() * 4,
                                        4,
                                    );
                                    let result5 = if layout5.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout5);
                                        }
                                        ptr
                                    } else {
                                        {
                                            ::core::ptr::null_mut()
                                        }
                                    };
                                    for (i, e) in vec5.into_iter().enumerate() {
                                        let base = result5.add(i * 4);
                                        {
                                            *base.add(0).cast::<i32>() = (e).take_handle() as i32;
                                        }
                                    }
                                    *base.add(12).cast::<usize>() = len5;
                                    *base.add(8).cast::<*mut u8>() = result5;
                                }
                            }
                            *ptr1.add(12).cast::<usize>() = len6;
                            *ptr1.add(8).cast::<*mut u8>() = result6;
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_query_match_iterator_next<
                    T: GuestQueryMatchIterator,
                >(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => (),
                        _ => {
                            let l6 = *arg0.add(8).cast::<*mut u8>();
                            let l7 = *arg0.add(12).cast::<usize>();
                            let base8 = l6;
                            let len8 = l7;
                            for i in 0..len8 {
                                let base = base8.add(i * 16);
                                {
                                    let l1 = *base.add(0).cast::<*mut u8>();
                                    let l2 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l1, l2, 1);
                                    let l3 = *base.add(8).cast::<*mut u8>();
                                    let l4 = *base.add(12).cast::<usize>();
                                    let base5 = l3;
                                    let len5 = l4;
                                    _rt::cabi_dealloc(base5, len5 * 4, 4);
                                }
                            }
                            _rt::cabi_dealloc(base8, len8 * 16, 4);
                        }
                    }
                }
                pub trait Guest {
                    type Query: GuestQuery;
                    type QueryMatchIterator: GuestQueryMatchIterator;
                }
                pub trait GuestQuery: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]query"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]query"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn parse(text: _rt::String) -> Result<Query, QueryError>;
                }
                pub trait GuestQueryMatchIterator: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]query-match-iterator"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }

                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }

                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nomic-foundation:slang/query@0.16.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]query-match-iterator"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }

                    fn next(&self) -> Option<QueryMatch>;
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_nomic_foundation_slang_query_0_16_0_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "nomic-foundation:slang/query@0.16.0#[static]query.parse"]
    unsafe extern "C" fn export_static_query_parse(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_static_query_parse_cabi::<<$ty as $($path_to_types)*::Guest>::Query>(arg0, arg1)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/query@0.16.0#[static]query.parse"]
    unsafe extern "C" fn _post_return_static_query_parse(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_static_query_parse::<<$ty as $($path_to_types)*::Guest>::Query>(arg0)
    }
    #[export_name = "nomic-foundation:slang/query@0.16.0#[method]query-match-iterator.next"]
    unsafe extern "C" fn export_method_query_match_iterator_next(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_method_query_match_iterator_next_cabi::<<$ty as $($path_to_types)*::Guest>::QueryMatchIterator>(arg0)
    }
    #[export_name = "cabi_post_nomic-foundation:slang/query@0.16.0#[method]query-match-iterator.next"]
    unsafe extern "C" fn _post_return_method_query_match_iterator_next(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_method_query_match_iterator_next::<<$ty as $($path_to_types)*::Guest>::QueryMatchIterator>(arg0)
    }

    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/query@0.16.0#[dtor]query"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::Query::dtor::<
        <$ty as $($path_to_types)*::Guest>::Query
        >(rep)
      }
    };


    const _: () = {
      #[doc(hidden)]
      #[export_name = "nomic-foundation:slang/query@0.16.0#[dtor]query-match-iterator"]
      #[allow(non_snake_case)]
      unsafe extern "C" fn dtor(rep: *mut u8) {
        $($path_to_types)*::QueryMatchIterator::dtor::<
        <$ty as $($path_to_types)*::Guest>::QueryMatchIterator
        >(rep)
      }
    };

  };);
}
                #[doc(hidden)]
                pub use __export_nomic_foundation_slang_query_0_16_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }
        }
    }
}
mod _rt {

    use core::sync::atomic::AtomicU32;
    use core::sync::atomic::Ordering::Relaxed;
    use core::{fmt, marker};

    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        // NB: This would ideally be `u32` but it is not. The fact that this has
        // interior mutability is not exposed in the API of this type except for the
        // `take_handle` method which is supposed to in theory be private.
        //
        // This represents, almost all the time, a valid handle value. When it's
        // invalid it's stored as `u32::MAX`.
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }

    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }

    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }

        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }

        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }

    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource")
                .field("handle", &self.handle)
                .finish()
        }
    }

    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    // If this handle was "taken" then don't do anything in the
                    // destructor.
                    u32::MAX => {}

                    // ... but otherwise do actually destroy it with the imported
                    // component model intrinsic as defined through `T`.
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
#[macro_export]
macro_rules! __export_slang_impl {
  ($ty:ident) => ($crate::wit::slang::export!($ty with_types_in $crate::wit::slang););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::nomic_foundation::slang::kinds::__export_nomic_foundation_slang_kinds_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::kinds);
  $($path_to_types_root)*::exports::nomic_foundation::slang::text_index::__export_nomic_foundation_slang_text_index_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::text_index);
  $($path_to_types_root)*::exports::nomic_foundation::slang::cst::__export_nomic_foundation_slang_cst_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::cst);
  $($path_to_types_root)*::exports::nomic_foundation::slang::cursor::__export_nomic_foundation_slang_cursor_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::cursor);
  $($path_to_types_root)*::exports::nomic_foundation::slang::diagnostic::__export_nomic_foundation_slang_diagnostic_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::diagnostic);
  $($path_to_types_root)*::exports::nomic_foundation::slang::parse_error::__export_nomic_foundation_slang_parse_error_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::parse_error);
  $($path_to_types_root)*::exports::nomic_foundation::slang::parse_output::__export_nomic_foundation_slang_parse_output_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::parse_output);
  $($path_to_types_root)*::exports::nomic_foundation::slang::language::__export_nomic_foundation_slang_language_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::language);
  $($path_to_types_root)*::exports::nomic_foundation::slang::query::__export_nomic_foundation_slang_query_0_16_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::nomic_foundation::slang::query);
  const _: () = {

    #[cfg(target_arch = "wasm32")]
    #[link_section = "component-type:wit-bindgen:0.26.0:slang:imports and exports"]
    #[doc(hidden)]
    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 15822] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd2z\x01A\x02\x01A\x1d\
\x01B\x06\x01m\xd8\x01\x0fabicoder-pragma\x13additive-expression\x0caddress-type\
\x0eand-expression\x15arguments-declaration\x10array-expression\x0farray-type-na\
me\x0carray-values\x0eassembly-flags\x1aassembly-flags-declaration\x12assembly-s\
tatement\x15assignment-expression\x16bitwise-and-expression\x15bitwise-or-expres\
sion\x16bitwise-xor-expression\x05block\x0fbreak-statement\x0ccall-options\x17ca\
ll-options-expression\x0ccatch-clause\x12catch-clause-error\x0dcatch-clauses\x15\
comparison-expression\x16conditional-expression\x13constant-definition\x15constr\
uctor-attribute\x16constructor-attributes\x16constructor-definition\x12continue-\
statement\x13contract-definition\x0fcontract-member\x10contract-members\x19decim\
al-number-expression\x12do-while-statement\x0felementary-type\x0belse-branch\x0e\
emit-statement\x0fenum-definition\x0cenum-members\x13equality-expression\x10erro\
r-definition\x0ferror-parameter\x10error-parameters\x1cerror-parameters-declarat\
ion\x10event-definition\x0fevent-parameter\x10event-parameters\x1cevent-paramete\
rs-declaration\x14experimental-feature\x13experimental-pragma\x19exponentiation-\
expression\x0aexpression\x14expression-statement\x1bfallback-function-attribute\x1c\
fallback-function-attributes\x1cfallback-function-definition\x0dfor-statement\x17\
for-statement-condition\x1cfor-statement-initialization\x12function-attribute\x13\
function-attributes\x0dfunction-body\x18function-call-expression\x13function-def\
inition\x0dfunction-name\x0dfunction-type\x17function-type-attribute\x18function\
-type-attributes\x15hex-number-expression\x12hex-string-literal\x13hex-string-li\
terals\x0fidentifier-path\x0cif-statement\x0cimport-alias\x0dimport-clause\x15im\
port-deconstruction\x1cimport-deconstruction-symbol\x1dimport-deconstruction-sym\
bols\x10import-directive\x10index-access-end\x17index-access-expression\x15inher\
itance-specifier\x10inheritance-type\x11inheritance-types\x14interface-definitio\
n\x11interface-members\x12library-definition\x0flibrary-members\x0bmapping-key\x10\
mapping-key-type\x0cmapping-type\x0dmapping-value\x18member-access-expression\x12\
modifier-attribute\x13modifier-attributes\x13modifier-definition\x13modifier-inv\
ocation\x19multiplicative-expression\x0enamed-argument\x14named-argument-group\x0f\
named-arguments\x1bnamed-arguments-declaration\x0cnamed-import\x0enew-expression\
\x0bnumber-unit\x0dor-expression\x0eoverride-paths\x1aoverride-paths-declaration\
\x12override-specifier\x09parameter\x0aparameters\x16parameters-declaration\x0bp\
ath-import\x14positional-arguments\x20positional-arguments-declaration\x12postfi\
x-expression\x06pragma\x10pragma-directive\x11prefix-expression\x1areceive-funct\
ion-attribute\x1breceive-function-attributes\x1breceive-function-definition\x10r\
eturn-statement\x13returns-declaration\x10revert-statement\x10shift-expression\x0b\
source-unit\x12source-unit-member\x13source-unit-members\x18state-variable-attri\
bute\x19state-variable-attributes\x19state-variable-definition\x1fstate-variable\
-definition-value\x09statement\x0astatements\x10storage-location\x11string-expre\
ssion\x0estring-literal\x0fstring-literals\x11struct-definition\x0dstruct-member\
\x0estruct-members\x0fthrow-statement\x0dtry-statement\x1ctuple-deconstruction-e\
lement\x1dtuple-deconstruction-elements\x1etuple-deconstruction-statement\x10tup\
le-expression\x0ctuple-member\x0btuple-value\x0ctuple-values\x0ftype-expression\x09\
type-name\x12typed-tuple-member\x0funchecked-block\x16unicode-string-literal\x17\
unicode-string-literals\x1aunnamed-function-attribute\x1bunnamed-function-attrib\
utes\x1bunnamed-function-definition\x14untyped-tuple-member\"user-defined-value-\
type-definition\x0busing-alias\x0cusing-clause\x14using-deconstruction\x1busing-\
deconstruction-symbol\x1cusing-deconstruction-symbols\x0fusing-directive\x0eusin\
g-operator\x0cusing-target\x1evariable-declaration-statement\x19variable-declara\
tion-type\x1avariable-declaration-value\x12version-comparator\x12version-express\
ion\x16version-expression-set\x17version-expression-sets\x0eversion-pragma\x0dve\
rsion-range\x12version-specifiers\x0fwhile-statement\x0dyul-arguments\x17yul-ass\
ignment-operator\x09yul-block\x13yul-break-statement\x15yul-built-in-function\x13\
yul-colon-and-equal\x16yul-continue-statement\x10yul-default-case\x13yul-equal-a\
nd-colon\x0eyul-expression\x11yul-for-statement\x1cyul-function-call-expression\x17\
yul-function-definition\x10yul-if-statement\x09yul-label\x13yul-leave-statement\x0b\
yul-literal\x0eyul-parameters\x1ayul-parameters-declaration\x08yul-path\x12yul-p\
ath-component\x09yul-paths\x17yul-returns-declaration\x1dyul-stack-assignment-op\
erator\x1eyul-stack-assignment-statement\x0dyul-statement\x0eyul-statements\x0fy\
ul-switch-case\x10yul-switch-cases\x14yul-switch-statement\x0eyul-value-case!yul\
-variable-assignment-statement\"yul-variable-declaration-statement\x1eyul-variab\
le-declaration-value\x12yul-variable-names\x04\0\x10nonterminal-kind\x03\0\0\x01\
m\x83\x01\x04item\x07variant\x09separator\x07operand\x0cleft-operand\x0dright-op\
erand\x0eleading-trivia\x0ftrailing-trivia\x10abicoder-keyword\x10abstract-keywo\
rd\x0faddress-keyword\x05alias\x11anonymous-keyword\x09arguments\x0aas-keyword\x10\
assembly-keyword\x0aassignment\x08asterisk\x0aattributes\x05block\x04body\x0dbre\
ak-keyword\x0ccase-keyword\x05cases\x0dcatch-clauses\x0dcatch-keyword\x06clause\x0b\
close-brace\x0dclose-bracket\x0bclose-paren\x05colon\x09condition\x10constant-ke\
yword\x13constructor-keyword\x10continue-keyword\x10contract-keyword\x0fdefault-\
keyword\x0ado-keyword\x08elements\x0belse-branch\x0celse-keyword\x0cemit-keyword\
\x03end\x0cenum-keyword\x05equal\x12equal-greater-than\x05error\x0derror-keyword\
\x05event\x0devent-keyword\x14experimental-keyword\x0aexpression\x10fallback-key\
word\x10false-expression\x07feature\x05flags\x0bfor-keyword\x0cfrom-keyword\x10f\
unction-keyword\x0eglobal-keyword\x0aidentifier\x0aif-keyword\x0eimport-keyword\x05\
index\x0findexed-keyword\x0binheritance\x0einitialization\x11interface-keyword\x0a\
is-keyword\x05items\x08iterator\x08key-type\x05label\x0dleave-keyword\x0blet-key\
word\x0flibrary-keyword\x07literal\x0fmapping-keyword\x06member\x07members\x12mi\
nus-greater-than\x10modifier-keyword\x04name\x0bnew-keyword\x0aopen-brace\x0cope\
n-bracket\x0aopen-paren\x08operator\x07options\x0aoverridden\x10override-keyword\
\x0aparameters\x04path\x05paths\x0fpayable-keyword\x06period\x06pragma\x0epragma\
-keyword\x0dquestion-mark\x0freceive-keyword\x0ereturn-keyword\x07returns\x0fret\
urns-keyword\x0erevert-keyword\x09semicolon\x04sets\x10solidity-keyword\x05start\
\x0astatements\x10storage-location\x0estruct-keyword\x0eswitch-keyword\x07symbol\
s\x06target\x0dthrow-keyword\x0ftrue-expression\x0btry-keyword\x0ctype-keyword\x09\
type-name\x05types\x11unchecked-keyword\x04unit\x0dusing-keyword\x05value\x0aval\
ue-type\x0bvar-keyword\x08variable\x0dvariable-type\x09variables\x07version\x0dw\
hile-keyword\x04\0\x0aedge-label\x03\0\x02\x01m\xf1\x02\x07skipped\x10abicoder-k\
eyword\x10abstract-keyword\x0faddress-keyword\x0dafter-keyword\x0dalias-keyword\x09\
ampersand\x13ampersand-ampersand\x0fampersand-equal\x11anonymous-keyword\x0dappl\
y-keyword\x0aas-keyword\x10assembly-keyword\x08asterisk\x11asterisk-asterisk\x0e\
asterisk-equal\x0cauto-keyword\x04bang\x0abang-equal\x03bar\x07bar-bar\x09bar-eq\
ual\x0cbool-keyword\x0dbreak-keyword\x0cbyte-keyword\x0dbytes-keyword\x11call-da\
ta-keyword\x05caret\x0bcaret-equal\x0ccase-keyword\x0dcatch-keyword\x0bclose-bra\
ce\x0dclose-bracket\x0bclose-paren\x05colon\x0bcolon-equal\x05comma\x10constant-\
keyword\x13constructor-keyword\x10continue-keyword\x10contract-keyword\x0fcopy-o\
f-keyword\x0cdays-keyword\x0fdecimal-literal\x0fdefault-keyword\x0edefine-keywor\
d\x0edelete-keyword\x0ado-keyword\x20double-quoted-hex-string-literal\x1cdouble-\
quoted-string-literal$double-quoted-unicode-string-literal\x1ddouble-quoted-vers\
ion-literal\x0celse-keyword\x0cemit-keyword\x0bend-of-line\x0cenum-keyword\x05eq\
ual\x0bequal-colon\x0bequal-equal\x12equal-greater-than\x0derror-keyword\x0dethe\
r-keyword\x0devent-keyword\x14experimental-keyword\x10external-keyword\x10fallba\
ck-keyword\x0dfalse-keyword\x0dfinal-keyword\x0efinney-keyword\x0dfixed-keyword\x0b\
for-keyword\x0cfrom-keyword\x10function-keyword\x0eglobal-keyword\x0cgreater-tha\
n\x12greater-than-equal\x19greater-than-greater-than\x1fgreater-than-greater-tha\
n-equal&greater-than-greater-than-greater-than,greater-than-greater-than-greater\
-than-equal\x0cgwei-keyword\x0bhex-keyword\x0bhex-literal\x0dhours-keyword\x0aid\
entifier\x0aif-keyword\x11immutable-keyword\x12implements-keyword\x0eimport-keyw\
ord\x0ain-keyword\x0findexed-keyword\x0einline-keyword\x0bint-keyword\x11interfa\
ce-keyword\x10internal-keyword\x0ais-keyword\x09less-than\x0fless-than-equal\x13\
less-than-less-than\x19less-than-less-than-equal\x0blet-keyword\x0flibrary-keywo\
rd\x0dmacro-keyword\x0fmapping-keyword\x0dmatch-keyword\x0ememory-keyword\x05min\
us\x0bminus-equal\x12minus-greater-than\x0bminus-minus\x0fminutes-keyword\x10mod\
ifier-keyword\x12multi-line-comment\x1bmulti-line-nat-spec-comment\x0fmutable-ke\
yword\x0bnew-keyword\x0cnull-keyword\x0aof-keyword\x0aopen-brace\x0copen-bracket\
\x0aopen-paren\x10override-keyword\x0fpartial-keyword\x0fpayable-keyword\x07perc\
ent\x0dpercent-equal\x06period\x04plus\x0aplus-equal\x09plus-plus\x0epragma-keyw\
ord\x0fprivate-keyword\x0fpromise-keyword\x0epublic-keyword\x0cpure-keyword\x0dq\
uestion-mark\x0freceive-keyword\x11reference-keyword\x13relocatable-keyword\x0er\
eturn-keyword\x0freturns-keyword\x0erevert-keyword\x0esealed-keyword\x0fseconds-\
keyword\x09semicolon\x13single-line-comment\x1csingle-line-nat-spec-comment\x20s\
ingle-quoted-hex-string-literal\x1csingle-quoted-string-literal$single-quoted-un\
icode-string-literal\x1dsingle-quoted-version-literal\x0fsize-of-keyword\x05slas\
h\x0bslash-equal\x10solidity-keyword\x0estatic-keyword\x0fstorage-keyword\x0estr\
ing-keyword\x0estruct-keyword\x10supports-keyword\x0eswitch-keyword\x0dszabo-key\
word\x0dthrow-keyword\x05tilde\x0ctrue-keyword\x0btry-keyword\x10type-def-keywor\
d\x0ctype-keyword\x0ftype-of-keyword\x0eufixed-keyword\x0cuint-keyword\x11unchec\
ked-keyword\x0dusing-keyword\x0bvar-keyword\x11version-specifier\x0cview-keyword\
\x0fvirtual-keyword\x0dweeks-keyword\x0bwei-keyword\x0dwhile-keyword\x0awhitespa\
ce\x0dyears-keyword\x14yul-abstract-keyword\x0fyul-add-keyword\x13yul-add-mod-ke\
yword\x13yul-address-keyword\x11yul-after-keyword\x11yul-alias-keyword\x0fyul-an\
d-keyword\x15yul-anonymous-keyword\x11yul-apply-keyword\x0eyul-as-keyword\x14yul\
-assembly-keyword\x10yul-auto-keyword\x13yul-balance-keyword\x14yul-base-fee-key\
word\x19yul-blob-base-fee-keyword\x15yul-blob-hash-keyword\x16yul-block-hash-key\
word\x10yul-bool-keyword\x11yul-break-keyword\x10yul-byte-keyword\x11yul-bytes-k\
eyword\x15yul-call-code-keyword\x1ayul-call-data-copy-keyword\x15yul-call-data-k\
eyword\x1ayul-call-data-load-keyword\x1ayul-call-data-size-keyword\x10yul-call-k\
eyword\x16yul-call-value-keyword\x12yul-caller-keyword\x10yul-case-keyword\x11yu\
l-catch-keyword\x14yul-chain-id-keyword\x15yul-coin-base-keyword\x14yul-constant\
-keyword\x17yul-constructor-keyword\x14yul-continue-keyword\x14yul-contract-keyw\
ord\x13yul-copy-of-keyword\x13yul-create2-keyword\x12yul-create-keyword\x10yul-d\
ays-keyword\x13yul-decimal-literal\x13yul-default-keyword\x12yul-define-keyword\x19\
yul-delegate-call-keyword\x12yul-delete-keyword\x16yul-difficulty-keyword\x0fyul\
-div-keyword\x0eyul-do-keyword\x10yul-else-keyword\x10yul-emit-keyword\x10yul-en\
um-keyword\x0eyul-eq-keyword\x11yul-ether-keyword\x11yul-event-keyword\x0fyul-ex\
p-keyword\x19yul-ext-code-copy-keyword\x19yul-ext-code-hash-keyword\x19yul-ext-c\
ode-size-keyword\x14yul-external-keyword\x14yul-fallback-keyword\x11yul-false-ke\
yword\x11yul-final-keyword\x12yul-finney-keyword\x11yul-fixed-keyword\x0fyul-for\
-keyword\x14yul-function-keyword\x0fyul-gas-keyword\x15yul-gas-limit-keyword\x15\
yul-gas-price-keyword\x0eyul-gt-keyword\x10yul-gwei-keyword\x0fyul-hex-keyword\x0f\
yul-hex-literal\x11yul-hours-keyword\x0eyul-identifier\x0eyul-if-keyword\x15yul-\
immutable-keyword\x16yul-implements-keyword\x12yul-import-keyword\x0eyul-in-keyw\
ord\x13yul-indexed-keyword\x12yul-inline-keyword\x0fyul-int-keyword\x15yul-inter\
face-keyword\x14yul-internal-keyword\x13yul-invalid-keyword\x0eyul-is-keyword\x13\
yul-is-zero-keyword\x15yul-keccak256-keyword\x11yul-leave-keyword\x0fyul-let-key\
word\x13yul-library-keyword\x10yul-log0-keyword\x10yul-log1-keyword\x10yul-log2-\
keyword\x10yul-log3-keyword\x10yul-log4-keyword\x0eyul-lt-keyword\x11yul-mcopy-k\
eyword\x11yul-mload-keyword\x11yul-msize-keyword\x13yul-mstore8-keyword\x12yul-m\
store-keyword\x11yul-macro-keyword\x13yul-mapping-keyword\x11yul-match-keyword\x12\
yul-memory-keyword\x13yul-minutes-keyword\x0fyul-mod-keyword\x14yul-modifier-key\
word\x0fyul-mul-keyword\x13yul-mul-mod-keyword\x13yul-mutable-keyword\x0fyul-new\
-keyword\x0fyul-not-keyword\x10yul-null-keyword\x12yul-number-keyword\x0eyul-of-\
keyword\x0eyul-or-keyword\x12yul-origin-keyword\x14yul-override-keyword\x13yul-p\
artial-keyword\x13yul-payable-keyword\x0fyul-pop-keyword\x12yul-pragma-keyword\x17\
yul-prev-randao-keyword\x13yul-private-keyword\x13yul-promise-keyword\x12yul-pub\
lic-keyword\x10yul-pure-keyword\x13yul-receive-keyword\x15yul-reference-keyword\x17\
yul-relocatable-keyword\x1cyul-return-data-copy-keyword\x1cyul-return-data-size-\
keyword\x12yul-return-keyword\x13yul-returns-keyword\x12yul-revert-keyword\x10yu\
l-sdiv-keyword\x11yul-sload-keyword\x10yul-smod-keyword\x12yul-sstore-keyword\x0f\
yul-sar-keyword\x12yul-sealed-keyword\x13yul-seconds-keyword\x18yul-self-balance\
-keyword\x19yul-self-destruct-keyword\x0fyul-sgt-keyword\x10yul-sha3-keyword\x0f\
yul-shl-keyword\x0fyul-shr-keyword\x17yul-sign-extend-keyword\x13yul-size-of-key\
word\x0fyul-slt-keyword\x17yul-static-call-keyword\x12yul-static-keyword\x10yul-\
stop-keyword\x13yul-storage-keyword\x12yul-string-keyword\x12yul-struct-keyword\x0f\
yul-sub-keyword\x13yul-suicide-keyword\x14yul-supports-keyword\x12yul-switch-key\
word\x11yul-szabo-keyword\x11yul-tload-keyword\x12yul-tstore-keyword\x11yul-thro\
w-keyword\x15yul-timestamp-keyword\x10yul-true-keyword\x0fyul-try-keyword\x14yul\
-type-def-keyword\x10yul-type-keyword\x13yul-type-of-keyword\x12yul-ufixed-keywo\
rd\x10yul-uint-keyword\x15yul-unchecked-keyword\x11yul-using-keyword\x0fyul-var-\
keyword\x10yul-view-keyword\x13yul-virtual-keyword\x11yul-weeks-keyword\x0fyul-w\
ei-keyword\x11yul-while-keyword\x0fyul-xor-keyword\x11yul-years-keyword\x04\0\x0d\
terminal-kind\x03\0\x04\x04\x01#nomic-foundation:slang/kinds@0.16.0\x05\0\x01B\x04\
\x01r\x04\x04utf8y\x05utf16y\x04liney\x06columny\x04\0\x0atext-index\x03\0\0\x01\
r\x02\x05start\x01\x03end\x01\x04\0\x0atext-range\x03\0\x02\x04\x01(nomic-founda\
tion:slang/text-index@0.16.0\x05\x01\x02\x03\0\0\x10nonterminal-kind\x02\x03\0\0\
\x0dterminal-kind\x02\x03\0\x01\x0atext-index\x01B\x1d\x02\x03\x02\x01\x02\x04\0\
\x10nonterminal-kind\x03\0\0\x02\x03\x02\x01\x03\x04\0\x0dterminal-kind\x03\0\x02\
\x02\x03\x02\x01\x04\x04\0\x0atext-index\x03\0\x04\x04\0\x10nonterminal-node\x03\
\x01\x04\0\x0dterminal-node\x03\x01\x01i\x06\x01i\x07\x01q\x02\x0bnonterminal\x01\
\x08\0\x08terminal\x01\x09\0\x04\0\x04node\x03\0\x0a\x01h\x06\x01@\x01\x04self\x0c\
\0\x01\x04\0\x1d[method]nonterminal-node.kind\x01\x0d\x01@\x01\x04self\x0c\0\x05\
\x04\0![method]nonterminal-node.text-len\x01\x0e\x01p\x0b\x01@\x01\x04self\x0c\0\
\x0f\x04\0![method]nonterminal-node.children\x01\x10\x01@\x01\x04self\x0c\0s\x04\
\0\x20[method]nonterminal-node.unparse\x01\x11\x01h\x07\x01@\x01\x04self\x12\0\x03\
\x04\0\x1a[method]terminal-node.kind\x01\x13\x01@\x01\x04self\x12\0\x05\x04\0\x1e\
[method]terminal-node.text-len\x01\x14\x01@\x01\x04self\x12\0s\x04\0\x1a[method]\
terminal-node.text\x01\x15\x04\x01!nomic-foundation:slang/cst@0.16.0\x05\x05\x02\
\x03\0\x02\x04node\x02\x03\0\x02\x10nonterminal-node\x02\x03\0\0\x0aedge-label\x02\
\x03\0\x01\x0atext-range\x01B>\x02\x03\x02\x01\x06\x04\0\x04node\x03\0\0\x02\x03\
\x02\x01\x07\x04\0\x10nonterminal-node\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x0aed\
ge-label\x03\0\x04\x02\x03\x02\x01\x02\x04\0\x10nonterminal-kind\x03\0\x06\x02\x03\
\x02\x01\x03\x04\0\x0dterminal-kind\x03\0\x08\x02\x03\x02\x01\x04\x04\0\x0atext-\
index\x03\0\x0a\x02\x03\x02\x01\x09\x04\0\x0atext-range\x03\0\x0c\x04\0\x06curso\
r\x03\x01\x01h\x0e\x01@\x01\x04self\x0f\x01\0\x04\0\x14[method]cursor.reset\x01\x10\
\x04\0\x17[method]cursor.complete\x01\x10\x01@\x01\x04self\x0f\0\x7f\x04\0\x1b[m\
ethod]cursor.is-completed\x01\x11\x01i\x0e\x01@\x01\x04self\x0f\0\x12\x04\0\x14[\
method]cursor.clone\x01\x13\x04\0\x14[method]cursor.spawn\x01\x13\x01@\x01\x04se\
lf\x0f\0\x01\x04\0\x13[method]cursor.node\x01\x14\x01k\x05\x01@\x01\x04self\x0f\0\
\x15\x04\0\x14[method]cursor.label\x01\x16\x01@\x01\x04self\x0f\0\x0b\x04\0\x1a[\
method]cursor.text-offset\x01\x17\x01@\x01\x04self\x0f\0\x0d\x04\0\x19[method]cu\
rsor.text-range\x01\x18\x01@\x01\x04self\x0f\0y\x04\0\x14[method]cursor.depth\x01\
\x19\x01i\x03\x01p\x1a\x01@\x01\x04self\x0f\0\x1b\x04\0\x18[method]cursor.ancest\
ors\x01\x1c\x04\0\x19[method]cursor.go-to-next\x01\x11\x04\0([method]cursor.go-t\
o-next-non-descendent\x01\x11\x04\0\x1d[method]cursor.go-to-previous\x01\x11\x04\
\0\x1b[method]cursor.go-to-parent\x01\x11\x04\0\x20[method]cursor.go-to-first-ch\
ild\x01\x11\x04\0\x1f[method]cursor.go-to-last-child\x01\x11\x01@\x02\x04self\x0f\
\x0cchild-numbery\0\x7f\x04\0\x1e[method]cursor.go-to-nth-child\x01\x1d\x04\0![m\
ethod]cursor.go-to-next-sibling\x01\x11\x04\0%[method]cursor.go-to-previous-sibl\
ing\x01\x11\x04\0\"[method]cursor.go-to-next-terminal\x01\x11\x01@\x02\x04self\x0f\
\x04kind\x09\0\x7f\x04\0,[method]cursor.go-to-next-terminal-with-kind\x01\x1e\x01\
p\x09\x01@\x02\x04self\x0f\x05kinds\x1f\0\x7f\x04\0-[method]cursor.go-to-next-te\
rminal-with-kinds\x01\x20\x04\0%[method]cursor.go-to-next-nonterminal\x01\x11\x01\
@\x02\x04self\x0f\x04kind\x07\0\x7f\x04\0/[method]cursor.go-to-next-nonterminal-\
with-kind\x01!\x01p\x07\x01@\x02\x04self\x0f\x05kinds\"\0\x7f\x04\00[method]curs\
or.go-to-next-nonterminal-with-kinds\x01#\x04\x01$nomic-foundation:slang/cursor@\
0.16.0\x05\x0a\x01B\x02\x01m\x04\x05error\x07warning\x0binformation\x04hint\x04\0\
\x08severity\x03\0\0\x04\x01(nomic-foundation:slang/diagnostic@0.16.0\x05\x0b\x02\
\x03\0\x04\x08severity\x01B\x0c\x02\x03\x02\x01\x0c\x04\0\x08severity\x03\0\0\x02\
\x03\x02\x01\x09\x04\0\x0atext-range\x03\0\x02\x04\0\x0bparse-error\x03\x01\x01h\
\x04\x01@\x01\x04self\x05\0\x01\x04\0\x1c[method]parse-error.severity\x01\x06\x01\
@\x01\x04self\x05\0\x03\x04\0\x1e[method]parse-error.text-range\x01\x07\x01@\x01\
\x04self\x05\0s\x04\0\x1b[method]parse-error.message\x01\x08\x04\x01)nomic-found\
ation:slang/parse-error@0.16.0\x05\x0d\x02\x03\0\x03\x06cursor\x02\x03\0\x05\x0b\
parse-error\x01B\x13\x02\x03\x02\x01\x06\x04\0\x04node\x03\0\0\x02\x03\x02\x01\x0e\
\x04\0\x06cursor\x03\0\x02\x02\x03\x02\x01\x0f\x04\0\x0bparse-error\x03\0\x04\x04\
\0\x0cparse-output\x03\x01\x01h\x06\x01@\x01\x04self\x07\0\x01\x04\0\x19[method]\
parse-output.tree\x01\x08\x01i\x05\x01p\x09\x01@\x01\x04self\x07\0\x0a\x04\0\x1b\
[method]parse-output.errors\x01\x0b\x01@\x01\x04self\x07\0\x7f\x04\0\x1d[method]\
parse-output.is-valid\x01\x0c\x01i\x03\x01@\x01\x04self\x07\0\x0d\x04\0'[method]\
parse-output.create-tree-cursor\x01\x0e\x04\x01*nomic-foundation:slang/parse-out\
put@0.16.0\x05\x10\x02\x03\0\x06\x0cparse-output\x01B\x12\x02\x03\x02\x01\x02\x04\
\0\x10nonterminal-kind\x03\0\0\x02\x03\x02\x01\x11\x04\0\x0cparse-output\x03\0\x02\
\x04\0\x08language\x03\x01\x01ps\x01@\0\0\x05\x04\0#[static]language.supported-v\
ersions\x01\x06\x01i\x04\x01j\x01\x07\x01s\x01@\x01\x07versions\0\x08\x04\0\x14[\
static]language.new\x01\x09\x01h\x04\x01@\x01\x04self\x0a\0s\x04\0\x18[method]la\
nguage.version\x01\x0b\x01i\x03\x01@\x03\x04self\x0a\x04kind\x01\x05inputs\0\x0c\
\x04\0\x16[method]language.parse\x01\x0d\x04\x01&nomic-foundation:slang/language\
@0.16.0\x05\x12\x01B\x14\x02\x03\x02\x01\x0e\x04\0\x06cursor\x03\0\0\x04\0\x05qu\
ery\x03\x01\x01r\x03\x07messages\x03rowy\x06columny\x04\0\x0bquery-error\x03\0\x03\
\x01i\x01\x01p\x05\x01o\x02s\x06\x01p\x07\x01r\x02\x0cquery-numbery\x08captures\x08\
\x04\0\x0bquery-match\x03\0\x09\x04\0\x14query-match-iterator\x03\x01\x01i\x02\x01\
j\x01\x0c\x01\x04\x01@\x01\x04texts\0\x0d\x04\0\x13[static]query.parse\x01\x0e\x01\
h\x0b\x01k\x0a\x01@\x01\x04self\x0f\0\x10\x04\0![method]query-match-iterator.nex\
t\x01\x11\x04\x01#nomic-foundation:slang/query@0.16.0\x05\x13\x04\x01#nomic-foun\
dation:slang/slang@0.16.0\x04\0\x0b\x0b\x01\0\x05slang\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.209.0\x10wit-bindgen-rust\x060.26.0";
  };
  )
}
#[doc(inline)]
pub use __export_slang_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.26.0:slang-with-all-of-its-exports-removed:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 233] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07N\x01A\x02\x01A\0\x04\
\x01Cnomic-foundation:slang/slang-with-all-of-its-exports-removed@0.16.0\x04\0\x0b\
+\x01\0%slang-with-all-of-its-exports-removed\x03\0\0\0G\x09producers\x01\x0cpro\
cessed-by\x02\x0dwit-component\x070.209.0\x10wit-bindgen-rust\x060.26.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
