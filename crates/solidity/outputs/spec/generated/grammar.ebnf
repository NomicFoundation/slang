(* This file is generated automatically by infrastructure scripts. Please don't edit by hand. *)

(*
 * 1. File Structure:
 *)

(* 1.1. Source Unit: *)

SourceUnit = (* members: *) SourceUnitMembers;

SourceUnitMembers = (* item: *) SourceUnitMember*;

SourceUnitMember = (* variant: *) PragmaDirective
                 | (* variant: *) ImportDirective
                 | (* variant: *) ContractDefinition
                 | (* variant: *) InterfaceDefinition
                 | (* variant: *) LibraryDefinition
                 | (* variant: *) StructDefinition (* Introduced in 0.6.0 *)
                 | (* variant: *) EnumDefinition (* Introduced in 0.6.0 *)
                 | (* variant: *) FunctionDefinition (* Introduced in 0.7.1 *)
                 | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)
                 | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)
                 | (* variant: *) UsingDirective (* Introduced in 0.8.13 *)
                 | (* variant: *) EventDefinition (* Introduced in 0.8.22 *)
                 | (* variant: *) ConstantDefinition; (* Introduced in 0.7.4 *)

(* 1.2. Pragma Directives: *)

PragmaDirective = (* pragma_keyword: *) PRAGMA_KEYWORD
                  (* pragma: *) Pragma
                  (* semicolon: *) SEMICOLON;

Pragma = (* variant: *) VersionPragma
       | (* variant: *) AbicoderPragma (* Introduced in 0.7.5 *)
       | (* variant: *) ExperimentalPragma; (* Introduced in 0.4.16 *)

(* Introduced in 0.7.5 *)
AbicoderPragma = (* abicoder_keyword: *) ABICODER_KEYWORD
                 (* version: *) AbicoderVersion;

(* Introduced in 0.4.16 *)
ExperimentalPragma = (* experimental_keyword: *) EXPERIMENTAL_KEYWORD
                     (* feature: *) ExperimentalFeature;

(* Introduced in 0.7.5 *)
AbicoderVersion = (* variant: *) ABICODER_V1_KEYWORD
                | (* variant: *) ABICODER_V2_KEYWORD;

(* Introduced in 0.4.16 *)
ExperimentalFeature = (* variant: *) ABI_ENCODER_V2_KEYWORD
                    | (* variant: *) SMT_CHECKER_KEYWORD
                    | (* variant: *) StringLiteral;

VersionPragma = (* solidity_keyword: *) SOLIDITY_KEYWORD
                (* sets: *) VersionExpressionSets;

VersionExpressionSets = (* item: *) VersionExpressionSet ((* separator: *) BAR_BAR (* item: *) VersionExpressionSet)*;

VersionExpressionSet = (* item: *) VersionExpression+;

VersionExpression = (* variant: *) VersionRange
                  | (* variant: *) VersionTerm;

VersionRange = (* start: *) VersionLiteral
               (* minus: *) MINUS
               (* end: *) VersionLiteral;

VersionTerm = (* operator: *) VersionOperator?
              (* literal: *) VersionLiteral;

VersionOperator = (* variant: *) CARET
                | (* variant: *) TILDE
                | (* variant: *) EQUAL
                | (* variant: *) LESS_THAN
                | (* variant: *) GREATER_THAN
                | (* variant: *) LESS_THAN_EQUAL
                | (* variant: *) GREATER_THAN_EQUAL;

VersionLiteral = (* variant: *) SimpleVersionLiteral
               | (* variant: *) SINGLE_QUOTED_VERSION_LITERAL
               | (* variant: *) DOUBLE_QUOTED_VERSION_LITERAL;

SimpleVersionLiteral = (* item: *) VERSION_SPECIFIER ((* separator: *) PERIOD (* item: *) VERSION_SPECIFIER)*;

VERSION_SPECIFIER = «VERSION_SPECIFIER_FRAGMENT»;

SINGLE_QUOTED_VERSION_LITERAL = "'" «VERSION_SPECIFIER_FRAGMENT» ("." «VERSION_SPECIFIER_FRAGMENT»)* "'";

DOUBLE_QUOTED_VERSION_LITERAL = '"' «VERSION_SPECIFIER_FRAGMENT» ("." «VERSION_SPECIFIER_FRAGMENT»)* '"';

«VERSION_SPECIFIER_FRAGMENT» = ("0"…"9" | "x" | "X" | "*")+;

(* 1.3. Import Directives: *)

ImportDirective = (* import_keyword: *) IMPORT_KEYWORD
                  (* clause: *) ImportClause
                  (* semicolon: *) SEMICOLON;

ImportClause = (* variant: *) PathImport
             | (* variant: *) NamedImport
             | (* variant: *) ImportDeconstruction;

PathImport = (* path: *) StringLiteral
             (* alias: *) ImportAlias?;

NamedImport = (* asterisk: *) ASTERISK
              (* alias: *) ImportAlias
              (* from_keyword: *) FROM_KEYWORD
              (* path: *) StringLiteral;

ImportDeconstruction = (* open_brace: *) OPEN_BRACE
                       (* symbols: *) ImportDeconstructionSymbols
                       (* close_brace: *) CLOSE_BRACE
                       (* from_keyword: *) FROM_KEYWORD
                       (* path: *) StringLiteral;

ImportDeconstructionSymbols = (* item: *) ImportDeconstructionSymbol ((* separator: *) COMMA (* item: *) ImportDeconstructionSymbol)*;

ImportDeconstructionSymbol = (* name: *) IDENTIFIER
                             (* alias: *) ImportAlias?;

ImportAlias = (* as_keyword: *) AS_KEYWORD
              (* identifier: *) IDENTIFIER;

(* 1.4. Using Directives: *)

UsingDirective = (* using_keyword: *) USING_KEYWORD
                 (* clause: *) UsingClause
                 (* for_keyword: *) FOR_KEYWORD
                 (* target: *) UsingTarget
                 (* global_keyword: *) GLOBAL_KEYWORD? (* Introduced in 0.8.13 *)
                 (* semicolon: *) SEMICOLON;

UsingClause = (* variant: *) IdentifierPath
            | (* variant: *) UsingDeconstruction; (* Introduced in 0.8.13 *)

(* Introduced in 0.8.13 *)
UsingDeconstruction = (* open_brace: *) OPEN_BRACE
                      (* symbols: *) UsingDeconstructionSymbols
                      (* close_brace: *) CLOSE_BRACE;

(* Introduced in 0.8.13 *)
UsingDeconstructionSymbols = (* item: *) UsingDeconstructionSymbol ((* separator: *) COMMA (* item: *) UsingDeconstructionSymbol)*;

(* Introduced in 0.8.13 *)
UsingDeconstructionSymbol = (* name: *) IdentifierPath
                            (* alias: *) UsingAlias?; (* Introduced in 0.8.19 *)

(* Introduced in 0.8.19 *)
UsingAlias = (* as_keyword: *) AS_KEYWORD
             (* operator: *) UsingOperator;

(* Introduced in 0.8.19 *)
UsingOperator = (* variant: *) AMPERSAND
              | (* variant: *) ASTERISK
              | (* variant: *) BANG_EQUAL
              | (* variant: *) BAR
              | (* variant: *) CARET
              | (* variant: *) EQUAL_EQUAL
              | (* variant: *) GREATER_THAN
              | (* variant: *) GREATER_THAN_EQUAL
              | (* variant: *) LESS_THAN
              | (* variant: *) LESS_THAN_EQUAL
              | (* variant: *) MINUS
              | (* variant: *) PERCENT
              | (* variant: *) PLUS
              | (* variant: *) SLASH
              | (* variant: *) TILDE;

UsingTarget = (* variant: *) TypeName
            | (* variant: *) ASTERISK;

(* 1.5. Trivia: *)

WHITESPACE = (" " | "\t")+;

END_OF_LINE = "\n" | ("\r" "\n"?);

SINGLE_LINE_COMMENT = "//" (?!"/") (!("\r" | "\n"))*;

MULTI_LINE_COMMENT = "/*" (?!"*" !"/") (!"*" | ("*" (?!"/")))* "*/";

SINGLE_LINE_NAT_SPEC_COMMENT = "///" (!("\r" | "\n"))*;

MULTI_LINE_NAT_SPEC_COMMENT = "/**" (?!"/") (!"*" | ("*" (?!"/")))* "*/";

(* 1.6. Keywords: *)

(* Introduced in 0.7.5 *)
(* Never reserved *)
ABICODER_KEYWORD = "abicoder";

(* Introduced in 0.7.5 *)
(* Never reserved *)
ABICODER_V1_KEYWORD = "v1";

(* Introduced in 0.7.5 *)
(* Never reserved *)
ABICODER_V2_KEYWORD = "v2";

(* Introduced in 0.4.16 *)
(* Never reserved *)
ABI_ENCODER_V2_KEYWORD = "ABIEncoderV2";

(* Introduced in 0.6.0 *)
ABSTRACT_KEYWORD = "abstract";

(* Never reserved *)
ADDRESS_KEYWORD = "address";

AFTER_KEYWORD = "after";

(* Reserved in 0.5.0 *)
ALIAS_KEYWORD = "alias";

ANONYMOUS_KEYWORD = "anonymous";

(* Reserved in 0.5.0 *)
APPLY_KEYWORD = "apply";

AS_KEYWORD = "as";

ASSEMBLY_KEYWORD = "assembly";

(* Introduced in 0.8.29 *)
(* Never reserved *)
AT_KEYWORD = "at";

(* Reserved in 0.5.0 *)
AUTO_KEYWORD = "auto";

BOOL_KEYWORD = "bool";

BREAK_KEYWORD = "break";

(* Deprecated in 0.8.0 *)
BYTE_KEYWORD = "byte";

BYTES_KEYWORD = "bytes" ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "32")?;

(* Introduced in 0.5.0 *)
(* Reserved in 0.5.0 *)
CALL_DATA_KEYWORD = "calldata";

CASE_KEYWORD = "case";

(* Introduced in 0.6.0 *)
CATCH_KEYWORD = "catch";

CONSTANT_KEYWORD = "constant";

(* Introduced in 0.4.22 *)
(* Reserved in 0.5.0 *)
CONSTRUCTOR_KEYWORD = "constructor";

CONTINUE_KEYWORD = "continue";

CONTRACT_KEYWORD = "contract";

(* Reserved in 0.5.0 *)
COPY_OF_KEYWORD = "copyof";

DAYS_KEYWORD = "days";

DEFAULT_KEYWORD = "default";

(* Reserved in 0.5.0 *)
DEFINE_KEYWORD = "define";

DELETE_KEYWORD = "delete";

DO_KEYWORD = "do";

ELSE_KEYWORD = "else";

(* Introduced in 0.4.21 *)
(* Reserved in 0.5.0 *)
EMIT_KEYWORD = "emit";

ENUM_KEYWORD = "enum";

(* Introduced in 0.8.4 *)
(* Never reserved *)
ERROR_KEYWORD = "error";

ETHER_KEYWORD = "ether";

EVENT_KEYWORD = "event";

(* Introduced in 0.4.16 *)
(* Never reserved *)
EXPERIMENTAL_KEYWORD = "experimental";

EXTERNAL_KEYWORD = "external";

(* Reserved in 0.6.0 *)
FALLBACK_KEYWORD = "fallback";

FALSE_KEYWORD = "false";

FINAL_KEYWORD = "final";

(* Deprecated in 0.7.0 *)
(* Reserved until 0.7.0 *)
FINNEY_KEYWORD = "finney";

FIXED_KEYWORD = "fixed";

FIXED_KEYWORD = "fixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176") "x" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80");

FIXED_KEYWORD = "fixed" ("184x8" | "184x16" | "184x24" | "184x32" | "184x40" | "184x48" | "184x56" | "184x64" | "184x72" | "192x8" | "192x16" | "192x24" | "192x32" | "192x40" | "192x48" | "192x56" | "192x64" | "200x8" | "200x16" | "200x24" | "200x32" | "200x40" | "200x48" | "200x56" | "208x8" | "208x16" | "208x24" | "208x32" | "208x40" | "208x48" | "216x8" | "216x16" | "216x24" | "216x32" | "216x40" | "224x8" | "224x16" | "224x24" | "224x32" | "232x8" | "232x16" | "232x24" | "240x8" | "240x16" | "248x8");

(* Reserved in 0.4.14 *)
FIXED_KEYWORD = "fixed" ("184x80" | "192x72" | "192x80" | "200x64" | "200x72" | "200x80" | "208x56" | "208x64" | "208x72" | "208x80" | "216x48" | "216x56" | "216x64" | "216x72" | "216x80" | "224x40" | "224x48" | "224x56" | "224x64" | "224x72" | "224x80" | "232x32" | "232x40" | "232x48" | "232x56" | "232x64" | "232x72" | "232x80" | "240x24" | "240x32" | "240x40" | "240x48" | "240x56" | "240x64" | "240x72" | "240x80" | "248x16" | "248x24" | "248x32" | "248x40" | "248x48" | "248x56" | "248x64" | "248x72" | "248x80" | "256x8" | "256x16" | "256x24" | "256x32" | "256x40" | "256x48" | "256x56" | "256x64" | "256x72" | "256x80");

(* Reserved in 0.4.14 *)
FIXED_KEYWORD = "fixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256") "x" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "41" | "42" | "43" | "44" | "45" | "46" | "47" | "49" | "50" | "51" | "52" | "53" | "54" | "55" | "57" | "58" | "59" | "60" | "61" | "62" | "63" | "65" | "66" | "67" | "68" | "69" | "70" | "71" | "73" | "74" | "75" | "76" | "77" | "78" | "79");

FOR_KEYWORD = "for";

(* Never reserved *)
FROM_KEYWORD = "from";

FUNCTION_KEYWORD = "function";

(* Introduced in 0.8.13 *)
(* Never reserved *)
GLOBAL_KEYWORD = "global";

(* Introduced in 0.6.11 *)
(* Reserved in 0.7.0 *)
GWEI_KEYWORD = "gwei";

HEX_KEYWORD = "hex";

HOURS_KEYWORD = "hours";

IF_KEYWORD = "if";

(* Introduced in 0.6.5 *)
(* Reserved in 0.5.0 *)
IMMUTABLE_KEYWORD = "immutable";

(* Reserved in 0.5.0 *)
IMPLEMENTS_KEYWORD = "implements";

IMPORT_KEYWORD = "import";

INDEXED_KEYWORD = "indexed";

IN_KEYWORD = "in";

INLINE_KEYWORD = "inline";

INTERFACE_KEYWORD = "interface";

INTERNAL_KEYWORD = "internal";

INT_KEYWORD = "int" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256")?;

IS_KEYWORD = "is";

(* Introduced in 0.8.29 *)
(* Never reserved *)
LAYOUT_KEYWORD = "layout";

LET_KEYWORD = "let";

LIBRARY_KEYWORD = "library";

(* Reserved in 0.5.0 *)
MACRO_KEYWORD = "macro";

MAPPING_KEYWORD = "mapping";

MATCH_KEYWORD = "match";

MEMORY_KEYWORD = "memory";

MINUTES_KEYWORD = "minutes";

MODIFIER_KEYWORD = "modifier";

(* Reserved in 0.5.0 *)
MUTABLE_KEYWORD = "mutable";

NEW_KEYWORD = "new";

NULL_KEYWORD = "null";

OF_KEYWORD = "of";

(* Introduced in 0.6.0 *)
(* Reserved in 0.5.0 *)
OVERRIDE_KEYWORD = "override";

(* Reserved in 0.5.0 *)
PARTIAL_KEYWORD = "partial";

PAYABLE_KEYWORD = "payable";

PRAGMA_KEYWORD = "pragma";

PRIVATE_KEYWORD = "private";

(* Reserved in 0.5.0 *)
PROMISE_KEYWORD = "promise";

PUBLIC_KEYWORD = "public";

(* Introduced in 0.4.16 *)
PURE_KEYWORD = "pure";

(* Reserved in 0.6.0 *)
RECEIVE_KEYWORD = "receive";

(* Reserved in 0.5.0 *)
REFERENCE_KEYWORD = "reference";

RELOCATABLE_KEYWORD = "relocatable";

RETURN_KEYWORD = "return";

RETURNS_KEYWORD = "returns";

(* Introduced in 0.8.4 *)
(* Never reserved *)
REVERT_KEYWORD = "revert";

(* Reserved in 0.5.0 *)
SEALED_KEYWORD = "sealed";

SECONDS_KEYWORD = "seconds";

(* Reserved in 0.5.0 *)
SIZE_OF_KEYWORD = "sizeof";

(* Introduced in 0.4.16 *)
(* Never reserved *)
SMT_CHECKER_KEYWORD = "SMTChecker";

(* Never reserved *)
SOLIDITY_KEYWORD = "solidity";

STATIC_KEYWORD = "static";

STORAGE_KEYWORD = "storage";

STRING_KEYWORD = "string";

STRUCT_KEYWORD = "struct";

(* Reserved in 0.8.0 *)
SUPER_KEYWORD = "super";

(* Reserved in 0.5.0 *)
SUPPORTS_KEYWORD = "supports";

SWITCH_KEYWORD = "switch";

(* Deprecated in 0.7.0 *)
(* Reserved until 0.7.0 *)
SZABO_KEYWORD = "szabo";

(* Reserved in 0.8.0 *)
THIS_KEYWORD = "this";

(* Deprecated in 0.5.0 *)
THROW_KEYWORD = "throw";

(* Introduced in 0.8.27 *)
(* Never reserved *)
TRANSIENT_KEYWORD = "transient";

TRUE_KEYWORD = "true";

(* Introduced in 0.6.0 *)
TRY_KEYWORD = "try";

(* Reserved in 0.5.0 *)
TYPE_DEF_KEYWORD = "typedef";

(* Introduced in 0.5.3 *)
TYPE_KEYWORD = "type";

TYPE_OF_KEYWORD = "typeof";

UFIXED_KEYWORD = "ufixed";

UFIXED_KEYWORD = "ufixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176") "x" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80");

UFIXED_KEYWORD = "ufixed" ("184x8" | "184x16" | "184x24" | "184x32" | "184x40" | "184x48" | "184x56" | "184x64" | "184x72" | "192x8" | "192x16" | "192x24" | "192x32" | "192x40" | "192x48" | "192x56" | "192x64" | "200x8" | "200x16" | "200x24" | "200x32" | "200x40" | "200x48" | "200x56" | "208x8" | "208x16" | "208x24" | "208x32" | "208x40" | "208x48" | "216x8" | "216x16" | "216x24" | "216x32" | "216x40" | "224x8" | "224x16" | "224x24" | "224x32" | "232x8" | "232x16" | "232x24" | "240x8" | "240x16" | "248x8");

(* Reserved in 0.4.14 *)
UFIXED_KEYWORD = "ufixed" ("184x80" | "192x72" | "192x80" | "200x64" | "200x72" | "200x80" | "208x56" | "208x64" | "208x72" | "208x80" | "216x48" | "216x56" | "216x64" | "216x72" | "216x80" | "224x40" | "224x48" | "224x56" | "224x64" | "224x72" | "224x80" | "232x32" | "232x40" | "232x48" | "232x56" | "232x64" | "232x72" | "232x80" | "240x24" | "240x32" | "240x40" | "240x48" | "240x56" | "240x64" | "240x72" | "240x80" | "248x16" | "248x24" | "248x32" | "248x40" | "248x48" | "248x56" | "248x64" | "248x72" | "248x80" | "256x8" | "256x16" | "256x24" | "256x32" | "256x40" | "256x48" | "256x56" | "256x64" | "256x72" | "256x80");

(* Reserved in 0.4.14 *)
UFIXED_KEYWORD = "ufixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256") "x" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "41" | "42" | "43" | "44" | "45" | "46" | "47" | "49" | "50" | "51" | "52" | "53" | "54" | "55" | "57" | "58" | "59" | "60" | "61" | "62" | "63" | "65" | "66" | "67" | "68" | "69" | "70" | "71" | "73" | "74" | "75" | "76" | "77" | "78" | "79");

UINT_KEYWORD = "uint" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256")?;

(* Introduced in 0.8.0 *)
(* Reserved in 0.5.0 *)
UNCHECKED_KEYWORD = "unchecked";

USING_KEYWORD = "using";

(* Deprecated in 0.5.0 *)
VAR_KEYWORD = "var";

(* Introduced in 0.4.16 *)
VIEW_KEYWORD = "view";

(* Introduced in 0.6.0 *)
(* Reserved in 0.6.0 *)
VIRTUAL_KEYWORD = "virtual";

WEEKS_KEYWORD = "weeks";

WEI_KEYWORD = "wei";

WHILE_KEYWORD = "while";

(* Deprecated in 0.5.0 *)
YEARS_KEYWORD = "years";

(* 1.7. Punctuation: *)

OPEN_PAREN = "(";

CLOSE_PAREN = ")";

OPEN_BRACKET = "[";

CLOSE_BRACKET = "]";

OPEN_BRACE = "{";

CLOSE_BRACE = "}";

COMMA = ",";

PERIOD = ".";

QUESTION_MARK = "?";

SEMICOLON = ";";

COLON = ":";

COLON_EQUAL = ":=";

EQUAL = "=";

(* Deprecated in 0.5.0 *)
EQUAL_COLON = "=:";

EQUAL_EQUAL = "==";

EQUAL_GREATER_THAN = "=>";

ASTERISK = "*";

ASTERISK_EQUAL = "*=";

ASTERISK_ASTERISK = "**";

BAR = "|";

BAR_EQUAL = "|=";

BAR_BAR = "||";

AMPERSAND = "&";

AMPERSAND_EQUAL = "&=";

AMPERSAND_AMPERSAND = "&&";

LESS_THAN = "<";

LESS_THAN_EQUAL = "<=";

LESS_THAN_LESS_THAN = "<<";

LESS_THAN_LESS_THAN_EQUAL = "<<=";

GREATER_THAN = ">";

GREATER_THAN_EQUAL = ">=";

GREATER_THAN_GREATER_THAN = ">>";

GREATER_THAN_GREATER_THAN_EQUAL = ">>=";

GREATER_THAN_GREATER_THAN_GREATER_THAN = ">>>";

GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL = ">>>=";

PLUS = "+";

PLUS_EQUAL = "+=";

PLUS_PLUS = "++";

MINUS = "-";

MINUS_EQUAL = "-=";

MINUS_MINUS = "--";

MINUS_GREATER_THAN = "->";

SLASH = "/" (?!"*" | "/" | "=");

SLASH_EQUAL = "/=";

PERCENT = "%";

PERCENT_EQUAL = "%=";

BANG = "!";

BANG_EQUAL = "!=";

CARET = "^";

CARET_EQUAL = "^=";

TILDE = "~";

(*
 * 2. Definitions:
 *)

(* 2.1. Contracts: *)

ContractDefinition = (* abstract_keyword: *) ABSTRACT_KEYWORD? (* Introduced in 0.6.0 *)
                     (* contract_keyword: *) CONTRACT_KEYWORD
                     (* name: *) IDENTIFIER
                     (* specifiers: *) ContractSpecifiers
                     (* open_brace: *) OPEN_BRACE
                     (* members: *) ContractMembers
                     (* close_brace: *) CLOSE_BRACE;

ContractSpecifiers = (* item: *) ContractSpecifier*;

ContractSpecifier = (* variant: *) InheritanceSpecifier
                  | (* variant: *) StorageLayoutSpecifier; (* Introduced in 0.8.29 *)

InheritanceSpecifier = (* is_keyword: *) IS_KEYWORD
                       (* types: *) InheritanceTypes;

InheritanceTypes = (* item: *) InheritanceType ((* separator: *) COMMA (* item: *) InheritanceType)*;

InheritanceType = (* type_name: *) IdentifierPath
                  (* arguments: *) ArgumentsDeclaration?;

(* Introduced in 0.8.29 *)
StorageLayoutSpecifier = (* layout_keyword: *) LAYOUT_KEYWORD
                         (* at_keyword: *) AT_KEYWORD
                         (* expression: *) Expression;

ContractMembers = (* item: *) ContractMember*;

ContractMember = (* variant: *) UsingDirective
               | (* variant: *) FunctionDefinition
               | (* variant: *) ConstructorDefinition (* Introduced in 0.4.22 *)
               | (* variant: *) ReceiveFunctionDefinition (* Introduced in 0.6.0 *)
               | (* variant: *) FallbackFunctionDefinition (* Introduced in 0.6.0 *)
               | (* variant: *) UnnamedFunctionDefinition (* Deprecated in 0.6.0 *)
               | (* variant: *) ModifierDefinition
               | (* variant: *) StructDefinition
               | (* variant: *) EnumDefinition
               | (* variant: *) EventDefinition
               | (* variant: *) ErrorDefinition (* Introduced in 0.8.4 *)
               | (* variant: *) UserDefinedValueTypeDefinition (* Introduced in 0.8.8 *)
               | (* variant: *) StateVariableDefinition;

(* 2.2. Interfaces: *)

InterfaceDefinition = (* interface_keyword: *) INTERFACE_KEYWORD
                      (* name: *) IDENTIFIER
                      (* inheritance: *) InheritanceSpecifier?
                      (* open_brace: *) OPEN_BRACE
                      (* members: *) InterfaceMembers
                      (* close_brace: *) CLOSE_BRACE;

InterfaceMembers = (* item: *) ContractMember*;

(* 2.3. Libraries: *)

LibraryDefinition = (* library_keyword: *) LIBRARY_KEYWORD
                    (* name: *) IDENTIFIER
                    (* open_brace: *) OPEN_BRACE
                    (* members: *) LibraryMembers
                    (* close_brace: *) CLOSE_BRACE;

LibraryMembers = (* item: *) ContractMember*;

(* 2.4. Structs: *)

StructDefinition = (* struct_keyword: *) STRUCT_KEYWORD
                   (* name: *) IDENTIFIER
                   (* open_brace: *) OPEN_BRACE
                   (* members: *) StructMembers
                   (* close_brace: *) CLOSE_BRACE;

StructMembers = (* item: *) StructMember*;

StructMember = (* type_name: *) TypeName
               (* name: *) IDENTIFIER
               (* semicolon: *) SEMICOLON;

(* 2.5. Enums: *)

EnumDefinition = (* enum_keyword: *) ENUM_KEYWORD
                 (* name: *) IDENTIFIER
                 (* open_brace: *) OPEN_BRACE
                 (* members: *) EnumMembers
                 (* close_brace: *) CLOSE_BRACE;

EnumMembers = ((* item: *) IDENTIFIER ((* separator: *) COMMA (* item: *) IDENTIFIER)*)?;

(* 2.6. Constants: *)

(* Introduced in 0.7.4 *)
ConstantDefinition = (* type_name: *) TypeName
                     (* constant_keyword: *) CONSTANT_KEYWORD
                     (* name: *) IDENTIFIER
                     (* equal: *) EQUAL
                     (* value: *) Expression
                     (* semicolon: *) SEMICOLON;

(* 2.7. State Variables: *)

StateVariableDefinition = (* type_name: *) TypeName
                          (* attributes: *) StateVariableAttributes
                          (* name: *) IDENTIFIER
                          (* value: *) StateVariableDefinitionValue?
                          (* semicolon: *) SEMICOLON;

StateVariableDefinitionValue = (* equal: *) EQUAL
                               (* value: *) Expression;

StateVariableAttributes = (* item: *) StateVariableAttribute*;

StateVariableAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)
                       | (* variant: *) CONSTANT_KEYWORD
                       | (* variant: *) INTERNAL_KEYWORD
                       | (* variant: *) PRIVATE_KEYWORD
                       | (* variant: *) PUBLIC_KEYWORD
                       | (* variant: *) IMMUTABLE_KEYWORD (* Introduced in 0.6.5 *)
                       | (* variant: *) TRANSIENT_KEYWORD; (* Introduced in 0.8.27 *)

(* 2.8. Functions: *)

FunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD
                     (* name: *) FunctionName
                     (* parameters: *) ParametersDeclaration
                     (* attributes: *) FunctionAttributes
                     (* returns: *) ReturnsDeclaration?
                     (* body: *) FunctionBody;

FunctionName = (* variant: *) IDENTIFIER
             | (* variant: *) FALLBACK_KEYWORD
             | (* variant: *) RECEIVE_KEYWORD;

ParametersDeclaration = (* open_paren: *) OPEN_PAREN
                        (* parameters: *) Parameters
                        (* close_paren: *) CLOSE_PAREN;

Parameters = ((* item: *) Parameter ((* separator: *) COMMA (* item: *) Parameter)*)?;

Parameter = (* type_name: *) TypeName
            (* storage_location: *) StorageLocation?
            (* name: *) IDENTIFIER?;

FunctionAttributes = (* item: *) FunctionAttribute*;

FunctionAttribute = (* variant: *) ModifierInvocation
                  | (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)
                  | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)
                  | (* variant: *) EXTERNAL_KEYWORD
                  | (* variant: *) INTERNAL_KEYWORD
                  | (* variant: *) PAYABLE_KEYWORD
                  | (* variant: *) PRIVATE_KEYWORD
                  | (* variant: *) PUBLIC_KEYWORD
                  | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)
                  | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)
                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)

(* Introduced in 0.6.0 *)
OverrideSpecifier = (* override_keyword: *) OVERRIDE_KEYWORD
                    (* overridden: *) OverridePathsDeclaration?;

(* Introduced in 0.6.0 *)
OverridePathsDeclaration = (* open_paren: *) OPEN_PAREN
                           (* paths: *) OverridePaths
                           (* close_paren: *) CLOSE_PAREN;

(* Introduced in 0.6.0 *)
OverridePaths = (* item: *) IdentifierPath ((* separator: *) COMMA (* item: *) IdentifierPath)*;

ReturnsDeclaration = (* returns_keyword: *) RETURNS_KEYWORD
                     (* variables: *) ParametersDeclaration;

FunctionBody = (* variant: *) Block
             | (* variant: *) SEMICOLON;

(* Introduced in 0.4.22 *)
ConstructorDefinition = (* constructor_keyword: *) CONSTRUCTOR_KEYWORD
                        (* parameters: *) ParametersDeclaration
                        (* attributes: *) ConstructorAttributes
                        (* body: *) Block;

(* Introduced in 0.4.22 *)
ConstructorAttributes = (* item: *) ConstructorAttribute*;

(* Introduced in 0.4.22 *)
ConstructorAttribute = (* variant: *) ModifierInvocation
                     | (* variant: *) INTERNAL_KEYWORD
                     | (* variant: *) OVERRIDE_KEYWORD (* Introduced in 0.6.0 and deprecated in 0.6.7. *)
                     | (* variant: *) PAYABLE_KEYWORD
                     | (* variant: *) PUBLIC_KEYWORD
                     | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 and deprecated in 0.6.7. *)

(* Deprecated in 0.6.0 *)
UnnamedFunctionDefinition = (* function_keyword: *) FUNCTION_KEYWORD
                            (* parameters: *) ParametersDeclaration
                            (* attributes: *) UnnamedFunctionAttributes
                            (* body: *) FunctionBody;

(* Deprecated in 0.6.0 *)
UnnamedFunctionAttributes = (* item: *) UnnamedFunctionAttribute*;

(* Deprecated in 0.6.0 *)
UnnamedFunctionAttribute = (* variant: *) ModifierInvocation
                         | (* variant: *) EXTERNAL_KEYWORD
                         | (* variant: *) INTERNAL_KEYWORD (* Deprecated in 0.5.0 *)
                         | (* variant: *) PAYABLE_KEYWORD
                         | (* variant: *) PRIVATE_KEYWORD (* Deprecated in 0.5.0 *)
                         | (* variant: *) PUBLIC_KEYWORD; (* Deprecated in 0.5.0 *)

(* Introduced in 0.6.0 *)
FallbackFunctionDefinition = (* fallback_keyword: *) FALLBACK_KEYWORD
                             (* parameters: *) ParametersDeclaration
                             (* attributes: *) FallbackFunctionAttributes
                             (* returns: *) ReturnsDeclaration?
                             (* body: *) FunctionBody;

(* Introduced in 0.6.0 *)
FallbackFunctionAttributes = (* item: *) FallbackFunctionAttribute*;

(* Introduced in 0.6.0 *)
FallbackFunctionAttribute = (* variant: *) ModifierInvocation
                          | (* variant: *) OverrideSpecifier
                          | (* variant: *) EXTERNAL_KEYWORD
                          | (* variant: *) PAYABLE_KEYWORD
                          | (* variant: *) PURE_KEYWORD
                          | (* variant: *) VIEW_KEYWORD
                          | (* variant: *) VIRTUAL_KEYWORD;

(* Introduced in 0.6.0 *)
ReceiveFunctionDefinition = (* receive_keyword: *) RECEIVE_KEYWORD
                            (* parameters: *) ParametersDeclaration
                            (* attributes: *) ReceiveFunctionAttributes
                            (* body: *) FunctionBody;

(* Introduced in 0.6.0 *)
ReceiveFunctionAttributes = (* item: *) ReceiveFunctionAttribute*;

(* Introduced in 0.6.0 *)
ReceiveFunctionAttribute = (* variant: *) ModifierInvocation
                         | (* variant: *) OverrideSpecifier
                         | (* variant: *) EXTERNAL_KEYWORD
                         | (* variant: *) PAYABLE_KEYWORD
                         | (* variant: *) VIRTUAL_KEYWORD;

(* 2.9. Modifiers: *)

ModifierDefinition = (* modifier_keyword: *) MODIFIER_KEYWORD
                     (* name: *) IDENTIFIER
                     (* parameters: *) ParametersDeclaration?
                     (* attributes: *) ModifierAttributes
                     (* body: *) FunctionBody;

ModifierAttributes = (* item: *) ModifierAttribute*;

ModifierAttribute = (* variant: *) OverrideSpecifier (* Introduced in 0.6.0 *)
                  | (* variant: *) VIRTUAL_KEYWORD; (* Introduced in 0.6.0 *)

ModifierInvocation = (* name: *) IdentifierPath
                     (* arguments: *) ArgumentsDeclaration?;

(* 2.10. Events: *)

EventDefinition = (* event_keyword: *) EVENT_KEYWORD
                  (* name: *) IDENTIFIER
                  (* parameters: *) EventParametersDeclaration
                  (* anonymous_keyword: *) ANONYMOUS_KEYWORD?
                  (* semicolon: *) SEMICOLON;

EventParametersDeclaration = (* open_paren: *) OPEN_PAREN
                             (* parameters: *) EventParameters
                             (* close_paren: *) CLOSE_PAREN;

EventParameters = ((* item: *) EventParameter ((* separator: *) COMMA (* item: *) EventParameter)*)?;

EventParameter = (* type_name: *) TypeName
                 (* indexed_keyword: *) INDEXED_KEYWORD?
                 (* name: *) IDENTIFIER?;

(* 2.11. User Defined Value Types: *)

(* Introduced in 0.8.8 *)
UserDefinedValueTypeDefinition = (* type_keyword: *) TYPE_KEYWORD
                                 (* name: *) IDENTIFIER
                                 (* is_keyword: *) IS_KEYWORD
                                 (* value_type: *) ElementaryType
                                 (* semicolon: *) SEMICOLON;

(* 2.12. Errors: *)

(* Introduced in 0.8.4 *)
ErrorDefinition = (* error_keyword: *) ERROR_KEYWORD
                  (* name: *) IDENTIFIER
                  (* members: *) ErrorParametersDeclaration
                  (* semicolon: *) SEMICOLON;

(* Introduced in 0.8.4 *)
ErrorParametersDeclaration = (* open_paren: *) OPEN_PAREN
                             (* parameters: *) ErrorParameters
                             (* close_paren: *) CLOSE_PAREN;

(* Introduced in 0.8.4 *)
ErrorParameters = ((* item: *) ErrorParameter ((* separator: *) COMMA (* item: *) ErrorParameter)*)?;

(* Introduced in 0.8.4 *)
ErrorParameter = (* type_name: *) TypeName
                 (* name: *) IDENTIFIER?;

(*
 * 3. Types:
 *)

(* 3.1. Advanced Types: *)

TypeName = (* variant: *) ArrayTypeName
         | (* variant: *) FunctionType
         | (* variant: *) MappingType
         | (* variant: *) ElementaryType
         | (* variant: *) IdentifierPath;

(* Postfix unary operator *)
ArrayTypeName = (* operand: *) TypeName
                (* open_bracket: *) OPEN_BRACKET
                (* index: *) Expression?
                (* close_bracket: *) CLOSE_BRACKET;

FunctionType = (* function_keyword: *) FUNCTION_KEYWORD
               (* parameters: *) ParametersDeclaration
               (* attributes: *) FunctionTypeAttributes
               (* returns: *) ReturnsDeclaration?;

FunctionTypeAttributes = (* item: *) FunctionTypeAttribute*;

FunctionTypeAttribute = (* variant: *) INTERNAL_KEYWORD
                      | (* variant: *) EXTERNAL_KEYWORD
                      | (* variant: *) PRIVATE_KEYWORD
                      | (* variant: *) PUBLIC_KEYWORD
                      | (* variant: *) CONSTANT_KEYWORD (* Deprecated in 0.5.0 *)
                      | (* variant: *) PURE_KEYWORD (* Introduced in 0.4.16 *)
                      | (* variant: *) VIEW_KEYWORD (* Introduced in 0.4.16 *)
                      | (* variant: *) PAYABLE_KEYWORD;

MappingType = (* mapping_keyword: *) MAPPING_KEYWORD
              (* open_paren: *) OPEN_PAREN
              (* key_type: *) MappingKey
              (* equal_greater_than: *) EQUAL_GREATER_THAN
              (* value_type: *) MappingValue
              (* close_paren: *) CLOSE_PAREN;

MappingKey = (* key_type: *) MappingKeyType
             (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)

MappingKeyType = (* variant: *) ElementaryType
               | (* variant: *) IdentifierPath;

MappingValue = (* type_name: *) TypeName
               (* name: *) IDENTIFIER?; (* Introduced in 0.8.18 *)

(* 3.2. Elementary Types: *)

ElementaryType = (* variant: *) BOOL_KEYWORD
               | (* variant: *) BYTE_KEYWORD (* Deprecated in 0.8.0 *)
               | (* variant: *) STRING_KEYWORD
               | (* variant: *) AddressType
               | (* variant: *) BYTES_KEYWORD
               | (* variant: *) INT_KEYWORD
               | (* variant: *) UINT_KEYWORD
               | (* variant: *) FIXED_KEYWORD
               | (* variant: *) UFIXED_KEYWORD;

AddressType = (* address_keyword: *) ADDRESS_KEYWORD
              (* payable_keyword: *) PAYABLE_KEYWORD?; (* Introduced in 0.5.0 *)

(*
 * 4. Statements:
 *)

(* 4.1. Blocks: *)

Block = (* open_brace: *) OPEN_BRACE
        (* statements: *) Statements
        (* close_brace: *) CLOSE_BRACE;

Statements = (* item: *) Statement*;

Statement = (* variant: *) IfStatement
          | (* variant: *) ForStatement
          | (* variant: *) WhileStatement
          | (* variant: *) DoWhileStatement
          | (* variant: *) ContinueStatement
          | (* variant: *) BreakStatement
          | (* variant: *) ReturnStatement
          | (* variant: *) ThrowStatement (* Deprecated in 0.5.0 *)
          | (* variant: *) EmitStatement (* Introduced in 0.4.21 *)
          | (* variant: *) TryStatement (* Introduced in 0.6.0 *)
          | (* variant: *) RevertStatement (* Introduced in 0.8.4 *)
          | (* variant: *) AssemblyStatement
          | (* variant: *) Block
          | (* variant: *) UncheckedBlock (* Introduced in 0.8.0 *)
          | (* variant: *) TupleDeconstructionStatement
          | (* variant: *) VariableDeclarationStatement
          | (* variant: *) ExpressionStatement;

(* Introduced in 0.8.0 *)
UncheckedBlock = (* unchecked_keyword: *) UNCHECKED_KEYWORD
                 (* block: *) Block;

ExpressionStatement = (* expression: *) Expression
                      (* semicolon: *) SEMICOLON;

AssemblyStatement = (* assembly_keyword: *) ASSEMBLY_KEYWORD
                    (* label: *) StringLiteral?
                    (* flags: *) AssemblyFlagsDeclaration? (* Introduced in 0.8.13 *)
                    (* body: *) YulBlock;

(* Introduced in 0.8.13 *)
AssemblyFlagsDeclaration = (* open_paren: *) OPEN_PAREN
                           (* flags: *) AssemblyFlags
                           (* close_paren: *) CLOSE_PAREN;

(* Introduced in 0.8.13 *)
AssemblyFlags = (* item: *) StringLiteral ((* separator: *) COMMA (* item: *) StringLiteral)*;

(* 4.2. Declaration Statements: *)

TupleDeconstructionStatement = (* var_keyword: *) VAR_KEYWORD? (* Deprecated in 0.5.0 *)
                               (* open_paren: *) OPEN_PAREN
                               (* elements: *) TupleDeconstructionElements
                               (* close_paren: *) CLOSE_PAREN
                               (* equal: *) EQUAL
                               (* expression: *) Expression
                               (* semicolon: *) SEMICOLON;

TupleDeconstructionElements = (* item: *) TupleDeconstructionElement ((* separator: *) COMMA (* item: *) TupleDeconstructionElement)*;

TupleDeconstructionElement = (* member: *) TupleMember?;

TupleMember = (* variant: *) TypedTupleMember
            | (* variant: *) UntypedTupleMember;

TypedTupleMember = (* type_name: *) TypeName
                   (* storage_location: *) StorageLocation?
                   (* name: *) IDENTIFIER;

UntypedTupleMember = (* storage_location: *) StorageLocation?
                     (* name: *) IDENTIFIER;

VariableDeclarationStatement = (* variable_type: *) VariableDeclarationType
                               (* storage_location: *) StorageLocation?
                               (* name: *) IDENTIFIER
                               (* value: *) VariableDeclarationValue?
                               (* semicolon: *) SEMICOLON;

VariableDeclarationType = (* variant: *) TypeName
                        | (* variant: *) VAR_KEYWORD; (* Deprecated in 0.5.0 *)

VariableDeclarationValue = (* equal: *) EQUAL
                           (* expression: *) Expression;

StorageLocation = (* variant: *) MEMORY_KEYWORD
                | (* variant: *) STORAGE_KEYWORD
                | (* variant: *) CALL_DATA_KEYWORD; (* Introduced in 0.5.0 *)

(* 4.3. Control Statements: *)

IfStatement = (* if_keyword: *) IF_KEYWORD
              (* open_paren: *) OPEN_PAREN
              (* condition: *) Expression
              (* close_paren: *) CLOSE_PAREN
              (* body: *) Statement
              (* else_branch: *) ElseBranch?;

ElseBranch = (* else_keyword: *) ELSE_KEYWORD
             (* body: *) Statement;

ForStatement = (* for_keyword: *) FOR_KEYWORD
               (* open_paren: *) OPEN_PAREN
               (* initialization: *) ForStatementInitialization
               (* condition: *) ForStatementCondition
               (* iterator: *) Expression?
               (* close_paren: *) CLOSE_PAREN
               (* body: *) Statement;

ForStatementInitialization = (* variant: *) TupleDeconstructionStatement
                           | (* variant: *) VariableDeclarationStatement
                           | (* variant: *) ExpressionStatement
                           | (* variant: *) SEMICOLON;

ForStatementCondition = (* variant: *) ExpressionStatement
                      | (* variant: *) SEMICOLON;

WhileStatement = (* while_keyword: *) WHILE_KEYWORD
                 (* open_paren: *) OPEN_PAREN
                 (* condition: *) Expression
                 (* close_paren: *) CLOSE_PAREN
                 (* body: *) Statement;

DoWhileStatement = (* do_keyword: *) DO_KEYWORD
                   (* body: *) Statement
                   (* while_keyword: *) WHILE_KEYWORD
                   (* open_paren: *) OPEN_PAREN
                   (* condition: *) Expression
                   (* close_paren: *) CLOSE_PAREN
                   (* semicolon: *) SEMICOLON;

ContinueStatement = (* continue_keyword: *) CONTINUE_KEYWORD
                    (* semicolon: *) SEMICOLON;

BreakStatement = (* break_keyword: *) BREAK_KEYWORD
                 (* semicolon: *) SEMICOLON;

ReturnStatement = (* return_keyword: *) RETURN_KEYWORD
                  (* expression: *) Expression?
                  (* semicolon: *) SEMICOLON;

(* Introduced in 0.4.21 *)
EmitStatement = (* emit_keyword: *) EMIT_KEYWORD
                (* event: *) IdentifierPath
                (* arguments: *) ArgumentsDeclaration
                (* semicolon: *) SEMICOLON;

(* 4.4. Error Handling: *)

(* Introduced in 0.6.0 *)
TryStatement = (* try_keyword: *) TRY_KEYWORD
               (* expression: *) Expression
               (* returns: *) ReturnsDeclaration?
               (* body: *) Block
               (* catch_clauses: *) CatchClauses;

(* Introduced in 0.6.0 *)
CatchClauses = (* item: *) CatchClause+;

(* Introduced in 0.6.0 *)
CatchClause = (* catch_keyword: *) CATCH_KEYWORD
              (* error: *) CatchClauseError?
              (* body: *) Block;

(* Introduced in 0.6.0 *)
CatchClauseError = (* name: *) IDENTIFIER?
                   (* parameters: *) ParametersDeclaration;

(* Introduced in 0.8.4 *)
RevertStatement = (* revert_keyword: *) REVERT_KEYWORD
                  (* error: *) IdentifierPath
                  (* arguments: *) ArgumentsDeclaration
                  (* semicolon: *) SEMICOLON;

(* Deprecated in 0.5.0 *)
ThrowStatement = (* throw_keyword: *) THROW_KEYWORD
                 (* semicolon: *) SEMICOLON;

(*
 * 5. Expressions:
 *)

(* 5.1. Base Expressions: *)

Expression = (* variant: *) AssignmentExpression
           | (* variant: *) ConditionalExpression
           | (* variant: *) OrExpression
           | (* variant: *) AndExpression
           | (* variant: *) EqualityExpression
           | (* variant: *) InequalityExpression
           | (* variant: *) BitwiseOrExpression
           | (* variant: *) BitwiseXorExpression
           | (* variant: *) BitwiseAndExpression
           | (* variant: *) ShiftExpression
           | (* variant: *) AdditiveExpression
           | (* variant: *) MultiplicativeExpression
           | (* variant: *) ExponentiationExpression
           | (* variant: *) PostfixExpression
           | (* variant: *) PrefixExpression
           | (* variant: *) FunctionCallExpression
           | (* variant: *) CallOptionsExpression
           | (* variant: *) MemberAccessExpression
           | (* variant: *) IndexAccessExpression
           | (* variant: *) NewExpression
           | (* variant: *) TupleExpression
           | (* variant: *) TypeExpression (* Introduced in 0.5.3 *)
           | (* variant: *) ArrayExpression
           | (* variant: *) HexNumberExpression
           | (* variant: *) DecimalNumberExpression
           | (* variant: *) StringExpression
           | (* variant: *) ElementaryType
           | (* variant: *) PAYABLE_KEYWORD (* Introduced in 0.6.0 *)
           | (* variant: *) THIS_KEYWORD
           | (* variant: *) SUPER_KEYWORD
           | (* variant: *) TRUE_KEYWORD
           | (* variant: *) FALSE_KEYWORD
           | (* variant: *) IDENTIFIER;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) BAR_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) PLUS_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) MINUS_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) CARET_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) SLASH_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) PERCENT_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) ASTERISK_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) AMPERSAND_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) LESS_THAN_LESS_THAN_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) GREATER_THAN_GREATER_THAN_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
AssignmentExpression = (* left_operand: *) Expression
                       (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN_EQUAL
                       (* right_operand: *) Expression;

(* Postfix unary operator *)
ConditionalExpression = (* operand: *) Expression
                        (* question_mark: *) QUESTION_MARK
                        (* true_expression: *) Expression
                        (* colon: *) COLON
                        (* false_expression: *) Expression;

(* Left-associative binary operator *)
OrExpression = (* left_operand: *) Expression
               (* operator: *) BAR_BAR
               (* right_operand: *) Expression;

(* Left-associative binary operator *)
AndExpression = (* left_operand: *) Expression
                (* operator: *) AMPERSAND_AMPERSAND
                (* right_operand: *) Expression;

(* Left-associative binary operator *)
EqualityExpression = (* left_operand: *) Expression
                     (* operator: *) EQUAL_EQUAL
                     (* right_operand: *) Expression;

(* Left-associative binary operator *)
EqualityExpression = (* left_operand: *) Expression
                     (* operator: *) BANG_EQUAL
                     (* right_operand: *) Expression;

(* Left-associative binary operator *)
InequalityExpression = (* left_operand: *) Expression
                       (* operator: *) LESS_THAN
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
InequalityExpression = (* left_operand: *) Expression
                       (* operator: *) GREATER_THAN
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
InequalityExpression = (* left_operand: *) Expression
                       (* operator: *) LESS_THAN_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
InequalityExpression = (* left_operand: *) Expression
                       (* operator: *) GREATER_THAN_EQUAL
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
BitwiseOrExpression = (* left_operand: *) Expression
                      (* operator: *) BAR
                      (* right_operand: *) Expression;

(* Left-associative binary operator *)
BitwiseXorExpression = (* left_operand: *) Expression
                       (* operator: *) CARET
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
BitwiseAndExpression = (* left_operand: *) Expression
                       (* operator: *) AMPERSAND
                       (* right_operand: *) Expression;

(* Left-associative binary operator *)
ShiftExpression = (* left_operand: *) Expression
                  (* operator: *) LESS_THAN_LESS_THAN
                  (* right_operand: *) Expression;

(* Left-associative binary operator *)
ShiftExpression = (* left_operand: *) Expression
                  (* operator: *) GREATER_THAN_GREATER_THAN
                  (* right_operand: *) Expression;

(* Left-associative binary operator *)
ShiftExpression = (* left_operand: *) Expression
                  (* operator: *) GREATER_THAN_GREATER_THAN_GREATER_THAN
                  (* right_operand: *) Expression;

(* Left-associative binary operator *)
AdditiveExpression = (* left_operand: *) Expression
                     (* operator: *) PLUS
                     (* right_operand: *) Expression;

(* Left-associative binary operator *)
AdditiveExpression = (* left_operand: *) Expression
                     (* operator: *) MINUS
                     (* right_operand: *) Expression;

(* Left-associative binary operator *)
MultiplicativeExpression = (* left_operand: *) Expression
                           (* operator: *) ASTERISK
                           (* right_operand: *) Expression;

(* Left-associative binary operator *)
MultiplicativeExpression = (* left_operand: *) Expression
                           (* operator: *) SLASH
                           (* right_operand: *) Expression;

(* Left-associative binary operator *)
MultiplicativeExpression = (* left_operand: *) Expression
                           (* operator: *) PERCENT
                           (* right_operand: *) Expression;

(* Left-associative binary operator *)
(* Deprecated in 0.8.0 *)
ExponentiationExpression = (* left_operand: *) Expression
                           (* operator: *) ASTERISK_ASTERISK
                           (* right_operand: *) Expression;

(* Right-associative binary operator *)
(* Introduced in 0.8.0 *)
ExponentiationExpression = (* left_operand: *) Expression
                           (* operator: *) ASTERISK_ASTERISK
                           (* right_operand: *) Expression;

(* Postfix unary operator *)
PostfixExpression = (* operand: *) Expression
                    (* operator: *) PLUS_PLUS;

(* Postfix unary operator *)
PostfixExpression = (* operand: *) Expression
                    (* operator: *) MINUS_MINUS;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) PLUS_PLUS
                   (* operand: *) Expression;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) MINUS_MINUS
                   (* operand: *) Expression;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) TILDE
                   (* operand: *) Expression;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) BANG
                   (* operand: *) Expression;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) MINUS
                   (* operand: *) Expression;

(* Prefix unary operator *)
(* Deprecated in 0.5.0 *)
PrefixExpression = (* operator: *) PLUS
                   (* operand: *) Expression;

(* Prefix unary operator *)
PrefixExpression = (* operator: *) DELETE_KEYWORD
                   (* operand: *) Expression;

(* Postfix unary operator *)
FunctionCallExpression = (* operand: *) Expression
                         (* arguments: *) ArgumentsDeclaration;

(* Postfix unary operator *)
(* Introduced in 0.6.2 *)
CallOptionsExpression = (* operand: *) Expression
                        (* open_brace: *) OPEN_BRACE
                        (* options: *) CallOptions
                        (* close_brace: *) CLOSE_BRACE;

(* Postfix unary operator *)
MemberAccessExpression = (* operand: *) Expression
                         (* period: *) PERIOD
                         (* member: *) IDENTIFIER;

(* Postfix unary operator *)
IndexAccessExpression = (* operand: *) Expression
                        (* open_bracket: *) OPEN_BRACKET
                        (* start: *) Expression?
                        (* end: *) IndexAccessEnd?
                        (* close_bracket: *) CLOSE_BRACKET;

IndexAccessEnd = (* colon: *) COLON
                 (* end: *) Expression?;

(* 5.2. Function Calls: *)

ArgumentsDeclaration = (* variant: *) PositionalArgumentsDeclaration
                     | (* variant: *) NamedArgumentsDeclaration;

PositionalArgumentsDeclaration = (* open_paren: *) OPEN_PAREN
                                 (* arguments: *) PositionalArguments
                                 (* close_paren: *) CLOSE_PAREN;

PositionalArguments = ((* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*)?;

NamedArgumentsDeclaration = (* open_paren: *) OPEN_PAREN
                            (* arguments: *) NamedArgumentGroup?
                            (* close_paren: *) CLOSE_PAREN;

NamedArgumentGroup = (* open_brace: *) OPEN_BRACE
                     (* arguments: *) NamedArguments
                     (* close_brace: *) CLOSE_BRACE;

NamedArguments = ((* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*)?;

(* Introduced in 0.6.2 *)
CallOptions = (* item: *) NamedArgument ((* separator: *) COMMA (* item: *) NamedArgument)*;

NamedArgument = (* name: *) IDENTIFIER
                (* colon: *) COLON
                (* value: *) Expression;

(* 5.3. Primary Expressions: *)

(* Introduced in 0.5.3 *)
TypeExpression = (* type_keyword: *) TYPE_KEYWORD
                 (* open_paren: *) OPEN_PAREN
                 (* type_name: *) TypeName
                 (* close_paren: *) CLOSE_PAREN;

NewExpression = (* new_keyword: *) NEW_KEYWORD
                (* type_name: *) TypeName;

TupleExpression = (* open_paren: *) OPEN_PAREN
                  (* items: *) TupleValues
                  (* close_paren: *) CLOSE_PAREN;

TupleValues = (* item: *) TupleValue ((* separator: *) COMMA (* item: *) TupleValue)*;

TupleValue = (* expression: *) Expression?;

ArrayExpression = (* open_bracket: *) OPEN_BRACKET
                  (* items: *) ArrayValues
                  (* close_bracket: *) CLOSE_BRACKET;

ArrayValues = (* item: *) Expression ((* separator: *) COMMA (* item: *) Expression)*;

(* 5.4. Numbers: *)

HexNumberExpression = (* literal: *) HEX_LITERAL
                      (* unit: *) NumberUnit?; (* Deprecated in 0.5.0 *)

DecimalNumberExpression = (* literal: *) DECIMAL_LITERAL
                          (* unit: *) NumberUnit?;

HEX_LITERAL = "0x" «HEX_CHARACTER»+ ("_" «HEX_CHARACTER»+)* (?!«IDENTIFIER_START»);

(* Deprecated in 0.5.0 *)
HEX_LITERAL = "0X" «HEX_CHARACTER»+ ("_" «HEX_CHARACTER»+)* (?!«IDENTIFIER_START»);

DECIMAL_LITERAL = "." «DECIMAL_DIGITS» «DECIMAL_EXPONENT»? (?!«IDENTIFIER_START»);

DECIMAL_LITERAL = «DECIMAL_DIGITS» (?!".") «DECIMAL_EXPONENT»? (?!«IDENTIFIER_START»);

(* Deprecated in 0.5.0 *)
DECIMAL_LITERAL = «DECIMAL_DIGITS» "." (?!«DECIMAL_DIGITS») «DECIMAL_EXPONENT»? (?!«IDENTIFIER_START»);

(* Deprecated in 0.5.0 *)
DECIMAL_LITERAL = «DECIMAL_DIGITS» "." «DECIMAL_DIGITS» «DECIMAL_EXPONENT»? (?!«IDENTIFIER_START»);

(* Introduced in 0.5.0 *)
DECIMAL_LITERAL = «DECIMAL_DIGITS» ("." «DECIMAL_DIGITS»)? «DECIMAL_EXPONENT»? (?!«IDENTIFIER_START»);

«DECIMAL_DIGITS» = "0"…"9"+ ("_" "0"…"9"+)*;

«DECIMAL_EXPONENT» = ("e" | "E") "-"? «DECIMAL_DIGITS»;

NumberUnit = (* variant: *) WEI_KEYWORD
           | (* variant: *) GWEI_KEYWORD (* Introduced in 0.6.11 *)
           | (* variant: *) SZABO_KEYWORD (* Deprecated in 0.7.0 *)
           | (* variant: *) FINNEY_KEYWORD (* Deprecated in 0.7.0 *)
           | (* variant: *) ETHER_KEYWORD
           | (* variant: *) SECONDS_KEYWORD
           | (* variant: *) MINUTES_KEYWORD
           | (* variant: *) HOURS_KEYWORD
           | (* variant: *) DAYS_KEYWORD
           | (* variant: *) WEEKS_KEYWORD
           | (* variant: *) YEARS_KEYWORD; (* Deprecated in 0.5.0 *)

(* 5.5. Strings: *)

StringExpression = (* variant: *) StringLiteral (* Deprecated in 0.5.14 *)
                 | (* variant: *) StringLiterals (* Introduced in 0.5.14 *)
                 | (* variant: *) HexStringLiteral (* Deprecated in 0.5.14 *)
                 | (* variant: *) HexStringLiterals (* Introduced in 0.5.14 *)
                 | (* variant: *) UnicodeStringLiterals; (* Introduced in 0.7.0 *)

(* Introduced in 0.5.14 *)
StringLiterals = (* item: *) StringLiteral+;

StringLiteral = (* variant: *) SINGLE_QUOTED_STRING_LITERAL
              | (* variant: *) DOUBLE_QUOTED_STRING_LITERAL;

(* Deprecated in 0.4.25 *)
SINGLE_QUOTED_STRING_LITERAL = "'" («ESCAPE_SEQUENCE_ARBITRARY» | !("'" | "\\" | "\r" | "\n"))* "'";

(* Introduced in 0.4.25 and deprecated in 0.7.0. *)
SINGLE_QUOTED_STRING_LITERAL = "'" («ESCAPE_SEQUENCE» | !("'" | "\\" | "\r" | "\n"))* "'";

SINGLE_QUOTED_STRING_LITERAL = "'" («ESCAPE_SEQUENCE» | " "…"&" | "("…"[" | "]"…"~")* "'";

(* Deprecated in 0.4.25 *)
DOUBLE_QUOTED_STRING_LITERAL = '"' («ESCAPE_SEQUENCE_ARBITRARY» | !('"' | "\\" | "\r" | "\n"))* '"';

(* Introduced in 0.4.25 and deprecated in 0.7.0. *)
DOUBLE_QUOTED_STRING_LITERAL = '"' («ESCAPE_SEQUENCE» | !('"' | "\\" | "\r" | "\n"))* '"';

DOUBLE_QUOTED_STRING_LITERAL = '"' («ESCAPE_SEQUENCE» | " "…"!" | "#"…"[" | "]"…"~")* '"';

(* Introduced in 0.5.14 *)
HexStringLiterals = (* item: *) HexStringLiteral+;

HexStringLiteral = (* variant: *) SINGLE_QUOTED_HEX_STRING_LITERAL
                 | (* variant: *) DOUBLE_QUOTED_HEX_STRING_LITERAL;

SINGLE_QUOTED_HEX_STRING_LITERAL = "hex'" «HEX_STRING_CONTENTS»? "'";

DOUBLE_QUOTED_HEX_STRING_LITERAL = 'hex"' «HEX_STRING_CONTENTS»? '"';

«HEX_STRING_CONTENTS» = «HEX_CHARACTER» «HEX_CHARACTER» ("_"? «HEX_CHARACTER» «HEX_CHARACTER»)*;

«HEX_CHARACTER» = "0"…"9" | "a"…"f" | "A"…"F";

(* Introduced in 0.7.0 *)
UnicodeStringLiterals = (* item: *) UnicodeStringLiteral+;

(* Introduced in 0.7.0 *)
UnicodeStringLiteral = (* variant: *) SINGLE_QUOTED_UNICODE_STRING_LITERAL
                     | (* variant: *) DOUBLE_QUOTED_UNICODE_STRING_LITERAL;

(* Introduced in 0.7.0 *)
SINGLE_QUOTED_UNICODE_STRING_LITERAL = "unicode'" («ESCAPE_SEQUENCE» | !("'" | "\\" | "\r" | "\n"))* "'";

(* Introduced in 0.7.0 *)
DOUBLE_QUOTED_UNICODE_STRING_LITERAL = 'unicode"' («ESCAPE_SEQUENCE» | !('"' | "\\" | "\r" | "\n"))* '"';

«ESCAPE_SEQUENCE» = "\\" («ASCII_ESCAPE» | «HEX_BYTE_ESCAPE» | «UNICODE_ESCAPE»);

(* Deprecated in 0.4.25 *)
«ESCAPE_SEQUENCE_ARBITRARY» = "\\" (!("x" | "u") | «HEX_BYTE_ESCAPE» | «UNICODE_ESCAPE»);

«ASCII_ESCAPE» = "n" | "r" | "t" | "'" | '"' | "\\" | "\r\n" | "\r" | "\n";

«HEX_BYTE_ESCAPE» = "x" «HEX_CHARACTER» «HEX_CHARACTER»;

«UNICODE_ESCAPE» = "u" «HEX_CHARACTER» «HEX_CHARACTER» «HEX_CHARACTER» «HEX_CHARACTER»;

(* 5.6. Identifiers: *)

IdentifierPath = (* item: *) IDENTIFIER ((* separator: *) PERIOD (* item: *) IDENTIFIER)*;

IDENTIFIER = «IDENTIFIER_START» «IDENTIFIER_PART»*;

«IDENTIFIER_START» = "_" | "$" | "a"…"z" | "A"…"Z";

«IDENTIFIER_PART» = «IDENTIFIER_START» | "0"…"9";

(*
 * 6. Yul:
 *)

(* 6.1. Yul Statements: *)

YulBlock = (* open_brace: *) OPEN_BRACE
           (* statements: *) YulStatements
           (* close_brace: *) CLOSE_BRACE;

YulStatements = (* item: *) YulStatement*;

YulStatement = (* variant: *) YulBlock
             | (* variant: *) YulFunctionDefinition
             | (* variant: *) YulStackAssignmentStatement (* Deprecated in 0.5.0 *)
             | (* variant: *) YulIfStatement
             | (* variant: *) YulForStatement
             | (* variant: *) YulSwitchStatement
             | (* variant: *) YulLeaveStatement (* Introduced in 0.6.0 *)
             | (* variant: *) YulBreakStatement
             | (* variant: *) YulContinueStatement
             | (* variant: *) YulVariableAssignmentStatement
             | (* variant: *) YulLabel (* Deprecated in 0.5.0 *)
             | (* variant: *) YulVariableDeclarationStatement
             | (* variant: *) YulExpression;

YulFunctionDefinition = (* function_keyword: *) YUL_FUNCTION_KEYWORD
                        (* name: *) YUL_IDENTIFIER
                        (* parameters: *) YulParametersDeclaration
                        (* returns: *) YulReturnsDeclaration?
                        (* body: *) YulBlock;

YulParametersDeclaration = (* open_paren: *) OPEN_PAREN
                           (* parameters: *) YulParameters
                           (* close_paren: *) CLOSE_PAREN;

YulParameters = ((* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*)?;

YulReturnsDeclaration = (* minus_greater_than: *) MINUS_GREATER_THAN
                        (* variables: *) YulVariableNames;

YulVariableNames = (* item: *) YUL_IDENTIFIER ((* separator: *) COMMA (* item: *) YUL_IDENTIFIER)*;

YulVariableDeclarationStatement = (* let_keyword: *) YUL_LET_KEYWORD
                                  (* variables: *) YulVariableNames
                                  (* value: *) YulVariableDeclarationValue?;

YulVariableDeclarationValue = (* assignment: *) YulAssignmentOperator
                              (* expression: *) YulExpression;

YulVariableAssignmentStatement = (* variables: *) YulPaths
                                 (* assignment: *) YulAssignmentOperator
                                 (* expression: *) YulExpression;

YulAssignmentOperator = (* variant: *) COLON_EQUAL
                      | (* variant: *) YulColonAndEqual; (* Deprecated in 0.5.5 *)

(* Deprecated in 0.5.5 *)
YulColonAndEqual = (* colon: *) COLON
                   (* equal: *) EQUAL;

(* Deprecated in 0.5.0 *)
YulStackAssignmentStatement = (* assignment: *) YulStackAssignmentOperator
                              (* variable: *) YUL_IDENTIFIER;

(* Deprecated in 0.5.0 *)
YulStackAssignmentOperator = (* variant: *) EQUAL_COLON
                           | (* variant: *) YulEqualAndColon;

(* Deprecated in 0.5.0 *)
YulEqualAndColon = (* equal: *) EQUAL
                   (* colon: *) COLON;

YulIfStatement = (* if_keyword: *) YUL_IF_KEYWORD
                 (* condition: *) YulExpression
                 (* body: *) YulBlock;

YulForStatement = (* for_keyword: *) YUL_FOR_KEYWORD
                  (* initialization: *) YulBlock
                  (* condition: *) YulExpression
                  (* iterator: *) YulBlock
                  (* body: *) YulBlock;

YulSwitchStatement = (* switch_keyword: *) YUL_SWITCH_KEYWORD
                     (* expression: *) YulExpression
                     (* cases: *) YulSwitchCases;

YulSwitchCases = (* item: *) YulSwitchCase+;

YulSwitchCase = (* variant: *) YulDefaultCase
              | (* variant: *) YulValueCase;

YulDefaultCase = (* default_keyword: *) YUL_DEFAULT_KEYWORD
                 (* body: *) YulBlock;

YulValueCase = (* case_keyword: *) YUL_CASE_KEYWORD
               (* value: *) YulLiteral
               (* body: *) YulBlock;

(* Introduced in 0.6.0 *)
YulLeaveStatement = (* leave_keyword: *) YUL_LEAVE_KEYWORD;

YulBreakStatement = (* break_keyword: *) YUL_BREAK_KEYWORD;

YulContinueStatement = (* continue_keyword: *) YUL_CONTINUE_KEYWORD;

(* Deprecated in 0.5.0 *)
YulLabel = (* label: *) YUL_IDENTIFIER
           (* colon: *) COLON;

(* 6.2. Yul Expressions: *)

YulExpression = (* variant: *) YulFunctionCallExpression
              | (* variant: *) YulLiteral
              | (* variant: *) YulPath;

(* Postfix unary operator *)
YulFunctionCallExpression = (* operand: *) YulExpression
                            (* open_paren: *) OPEN_PAREN
                            (* arguments: *) YulArguments
                            (* close_paren: *) CLOSE_PAREN;

YulArguments = ((* item: *) YulExpression ((* separator: *) COMMA (* item: *) YulExpression)*)?;

YulPaths = (* item: *) YulPath ((* separator: *) COMMA (* item: *) YulPath)*;

YulPath = (* item: *) YUL_IDENTIFIER ((* separator: *) PERIOD (* item: *) YUL_IDENTIFIER)*;

(* Introduced in 0.5.8 and deprecated in 0.7.0. *)
YUL_IDENTIFIER = «IDENTIFIER_START» («IDENTIFIER_PART» | ".")*;

YUL_IDENTIFIER = «IDENTIFIER_START» «IDENTIFIER_PART»*;

YulLiteral = (* variant: *) YUL_TRUE_KEYWORD (* Introduced in 0.6.2 *)
           | (* variant: *) YUL_FALSE_KEYWORD (* Introduced in 0.6.2 *)
           | (* variant: *) YUL_DECIMAL_LITERAL
           | (* variant: *) YUL_HEX_LITERAL
           | (* variant: *) HexStringLiteral
           | (* variant: *) StringLiteral;

YUL_DECIMAL_LITERAL = ("0" | ("1"…"9" "0"…"9"*)) (?!«IDENTIFIER_START»);

YUL_HEX_LITERAL = "0x" «HEX_CHARACTER»+ (?!«IDENTIFIER_START»);

(* 6.3. Yul Keywords: *)

(* Reserved until 0.7.1 *)
YUL_ABSTRACT_KEYWORD = "abstract";

(* Reserved until 0.7.1 *)
YUL_AFTER_KEYWORD = "after";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_ALIAS_KEYWORD = "alias";

(* Reserved until 0.7.1 *)
YUL_ANONYMOUS_KEYWORD = "anonymous";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_APPLY_KEYWORD = "apply";

(* Reserved until 0.7.1 *)
YUL_AS_KEYWORD = "as";

(* Reserved until 0.7.1 *)
YUL_ASSEMBLY_KEYWORD = "assembly";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_AUTO_KEYWORD = "auto";

(* Reserved until 0.5.10 *)
YUL_BOOL_KEYWORD = "bool";

YUL_BREAK_KEYWORD = "break";

(* Reserved until 0.7.1 *)
YUL_BYTES_KEYWORD = "bytes" ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "32")?;

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_CALL_DATA_KEYWORD = "calldata";

YUL_CASE_KEYWORD = "case";

(* Reserved until 0.7.1 *)
YUL_CATCH_KEYWORD = "catch";

(* Reserved until 0.7.1 *)
YUL_CONSTANT_KEYWORD = "constant";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_CONSTRUCTOR_KEYWORD = "constructor";

YUL_CONTINUE_KEYWORD = "continue";

(* Reserved until 0.7.1 *)
YUL_CONTRACT_KEYWORD = "contract";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_COPY_OF_KEYWORD = "copyof";

(* Reserved until 0.7.1 *)
YUL_DAYS_KEYWORD = "days";

YUL_DEFAULT_KEYWORD = "default";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_DEFINE_KEYWORD = "define";

(* Reserved until 0.7.1 *)
YUL_DELETE_KEYWORD = "delete";

(* Reserved until 0.7.1 *)
YUL_DO_KEYWORD = "do";

(* Reserved until 0.7.1 *)
YUL_ELSE_KEYWORD = "else";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_EMIT_KEYWORD = "emit";

(* Reserved until 0.7.1 *)
YUL_ENUM_KEYWORD = "enum";

(* Reserved until 0.7.1 *)
YUL_ETHER_KEYWORD = "ether";

(* Reserved until 0.7.1 *)
YUL_EVENT_KEYWORD = "event";

(* Reserved until 0.7.1 *)
YUL_EXTERNAL_KEYWORD = "external";

(* Reserved from 0.6.0 until 0.7.1 *)
YUL_FALLBACK_KEYWORD = "fallback";

(* Introduced in 0.6.2 *)
YUL_FALSE_KEYWORD = "false";

(* Reserved until 0.7.1 *)
YUL_FINAL_KEYWORD = "final";

(* Reserved until 0.7.0 *)
YUL_FINNEY_KEYWORD = "finney";

(* Reserved until 0.7.1 *)
YUL_FIXED_KEYWORD = "fixed";

(* Reserved until 0.7.1 *)
YUL_FIXED_KEYWORD = "fixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176") "x" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80");

(* Reserved until 0.7.1 *)
YUL_FIXED_KEYWORD = "fixed" ("184x8" | "184x16" | "184x24" | "184x32" | "184x40" | "184x48" | "184x56" | "184x64" | "184x72" | "192x8" | "192x16" | "192x24" | "192x32" | "192x40" | "192x48" | "192x56" | "192x64" | "200x8" | "200x16" | "200x24" | "200x32" | "200x40" | "200x48" | "200x56" | "208x8" | "208x16" | "208x24" | "208x32" | "208x40" | "208x48" | "216x8" | "216x16" | "216x24" | "216x32" | "216x40" | "224x8" | "224x16" | "224x24" | "224x32" | "232x8" | "232x16" | "232x24" | "240x8" | "240x16" | "248x8");

(* Reserved from 0.4.14 until 0.7.1 *)
YUL_FIXED_KEYWORD = "fixed" ("184x80" | "192x72" | "192x80" | "200x64" | "200x72" | "200x80" | "208x56" | "208x64" | "208x72" | "208x80" | "216x48" | "216x56" | "216x64" | "216x72" | "216x80" | "224x40" | "224x48" | "224x56" | "224x64" | "224x72" | "224x80" | "232x32" | "232x40" | "232x48" | "232x56" | "232x64" | "232x72" | "232x80" | "240x24" | "240x32" | "240x40" | "240x48" | "240x56" | "240x64" | "240x72" | "240x80" | "248x16" | "248x24" | "248x32" | "248x40" | "248x48" | "248x56" | "248x64" | "248x72" | "248x80" | "256x8" | "256x16" | "256x24" | "256x32" | "256x40" | "256x48" | "256x56" | "256x64" | "256x72" | "256x80");

(* Reserved from 0.4.14 until 0.7.1 *)
YUL_FIXED_KEYWORD = "fixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256") "x" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "41" | "42" | "43" | "44" | "45" | "46" | "47" | "49" | "50" | "51" | "52" | "53" | "54" | "55" | "57" | "58" | "59" | "60" | "61" | "62" | "63" | "65" | "66" | "67" | "68" | "69" | "70" | "71" | "73" | "74" | "75" | "76" | "77" | "78" | "79");

YUL_FOR_KEYWORD = "for";

YUL_FUNCTION_KEYWORD = "function";

(* Reserved from 0.7.0 until 0.7.1 *)
YUL_GWEI_KEYWORD = "gwei";

YUL_HEX_KEYWORD = "hex";

(* Reserved until 0.7.1 *)
YUL_HOURS_KEYWORD = "hours";

YUL_IF_KEYWORD = "if";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_IMMUTABLE_KEYWORD = "immutable";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_IMPLEMENTS_KEYWORD = "implements";

(* Reserved until 0.7.1 *)
YUL_IMPORT_KEYWORD = "import";

(* Reserved until 0.7.1 *)
YUL_INDEXED_KEYWORD = "indexed";

(* Reserved until 0.6.8 *)
YUL_IN_KEYWORD = "in";

(* Reserved until 0.7.1 *)
YUL_INLINE_KEYWORD = "inline";

(* Reserved until 0.7.1 *)
YUL_INTERFACE_KEYWORD = "interface";

(* Reserved until 0.7.1 *)
YUL_INTERNAL_KEYWORD = "internal";

(* Reserved until 0.7.1 *)
YUL_INT_KEYWORD = "int" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256")?;

(* Reserved until 0.7.1 *)
YUL_IS_KEYWORD = "is";

(* Introduced in 0.6.0 *)
(* Reserved in 0.7.1 *)
YUL_LEAVE_KEYWORD = "leave";

YUL_LET_KEYWORD = "let";

(* Reserved until 0.7.1 *)
YUL_LIBRARY_KEYWORD = "library";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_MACRO_KEYWORD = "macro";

(* Reserved until 0.7.1 *)
YUL_MAPPING_KEYWORD = "mapping";

(* Reserved until 0.7.1 *)
YUL_MATCH_KEYWORD = "match";

(* Reserved until 0.7.1 *)
YUL_MEMORY_KEYWORD = "memory";

(* Reserved until 0.7.1 *)
YUL_MINUTES_KEYWORD = "minutes";

(* Reserved until 0.7.1 *)
YUL_MODIFIER_KEYWORD = "modifier";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_MUTABLE_KEYWORD = "mutable";

(* Reserved until 0.7.1 *)
YUL_NEW_KEYWORD = "new";

(* Reserved until 0.7.1 *)
YUL_NULL_KEYWORD = "null";

(* Reserved until 0.7.1 *)
YUL_OF_KEYWORD = "of";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_OVERRIDE_KEYWORD = "override";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_PARTIAL_KEYWORD = "partial";

(* Reserved until 0.7.1 *)
YUL_PAYABLE_KEYWORD = "payable";

(* Reserved until 0.7.1 *)
YUL_PRAGMA_KEYWORD = "pragma";

(* Reserved until 0.7.1 *)
YUL_PRIVATE_KEYWORD = "private";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_PROMISE_KEYWORD = "promise";

(* Reserved until 0.7.1 *)
YUL_PUBLIC_KEYWORD = "public";

(* Reserved until 0.7.1 *)
YUL_PURE_KEYWORD = "pure";

(* Reserved from 0.6.0 until 0.7.1 *)
YUL_RECEIVE_KEYWORD = "receive";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_REFERENCE_KEYWORD = "reference";

(* Reserved until 0.7.1 *)
YUL_RELOCATABLE_KEYWORD = "relocatable";

(* Reserved until 0.7.1 *)
YUL_RETURNS_KEYWORD = "returns";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_SEALED_KEYWORD = "sealed";

(* Reserved until 0.7.1 *)
YUL_SECONDS_KEYWORD = "seconds";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_SIZE_OF_KEYWORD = "sizeof";

(* Reserved until 0.7.1 *)
YUL_STATIC_KEYWORD = "static";

(* Reserved until 0.7.1 *)
YUL_STORAGE_KEYWORD = "storage";

(* Reserved until 0.7.1 *)
YUL_STRING_KEYWORD = "string";

(* Reserved until 0.7.1 *)
YUL_STRUCT_KEYWORD = "struct";

(* Reserved in 0.8.0 *)
YUL_SUPER_KEYWORD = "super";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_SUPPORTS_KEYWORD = "supports";

YUL_SWITCH_KEYWORD = "switch";

(* Reserved until 0.7.0 *)
YUL_SZABO_KEYWORD = "szabo";

(* Reserved in 0.8.0 *)
YUL_THIS_KEYWORD = "this";

(* Reserved until 0.7.1 *)
YUL_THROW_KEYWORD = "throw";

(* Introduced in 0.6.2 *)
YUL_TRUE_KEYWORD = "true";

(* Reserved until 0.7.1 *)
YUL_TRY_KEYWORD = "try";

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_TYPE_DEF_KEYWORD = "typedef";

(* Reserved until 0.7.1 *)
YUL_TYPE_KEYWORD = "type";

(* Reserved until 0.7.1 *)
YUL_TYPE_OF_KEYWORD = "typeof";

(* Reserved until 0.7.1 *)
YUL_UFIXED_KEYWORD = "ufixed";

(* Reserved until 0.7.1 *)
YUL_UFIXED_KEYWORD = "ufixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176") "x" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80");

(* Reserved until 0.7.1 *)
YUL_UFIXED_KEYWORD = "ufixed" ("184x8" | "184x16" | "184x24" | "184x32" | "184x40" | "184x48" | "184x56" | "184x64" | "184x72" | "192x8" | "192x16" | "192x24" | "192x32" | "192x40" | "192x48" | "192x56" | "192x64" | "200x8" | "200x16" | "200x24" | "200x32" | "200x40" | "200x48" | "200x56" | "208x8" | "208x16" | "208x24" | "208x32" | "208x40" | "208x48" | "216x8" | "216x16" | "216x24" | "216x32" | "216x40" | "224x8" | "224x16" | "224x24" | "224x32" | "232x8" | "232x16" | "232x24" | "240x8" | "240x16" | "248x8");

(* Reserved from 0.4.14 until 0.7.1 *)
YUL_UFIXED_KEYWORD = "ufixed" ("184x80" | "192x72" | "192x80" | "200x64" | "200x72" | "200x80" | "208x56" | "208x64" | "208x72" | "208x80" | "216x48" | "216x56" | "216x64" | "216x72" | "216x80" | "224x40" | "224x48" | "224x56" | "224x64" | "224x72" | "224x80" | "232x32" | "232x40" | "232x48" | "232x56" | "232x64" | "232x72" | "232x80" | "240x24" | "240x32" | "240x40" | "240x48" | "240x56" | "240x64" | "240x72" | "240x80" | "248x16" | "248x24" | "248x32" | "248x40" | "248x48" | "248x56" | "248x64" | "248x72" | "248x80" | "256x8" | "256x16" | "256x24" | "256x32" | "256x40" | "256x48" | "256x56" | "256x64" | "256x72" | "256x80");

(* Reserved from 0.4.14 until 0.7.1 *)
YUL_UFIXED_KEYWORD = "ufixed" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256") "x" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "9" | "10" | "11" | "12" | "13" | "14" | "15" | "17" | "18" | "19" | "20" | "21" | "22" | "23" | "25" | "26" | "27" | "28" | "29" | "30" | "31" | "33" | "34" | "35" | "36" | "37" | "38" | "39" | "41" | "42" | "43" | "44" | "45" | "46" | "47" | "49" | "50" | "51" | "52" | "53" | "54" | "55" | "57" | "58" | "59" | "60" | "61" | "62" | "63" | "65" | "66" | "67" | "68" | "69" | "70" | "71" | "73" | "74" | "75" | "76" | "77" | "78" | "79");

(* Reserved until 0.7.1 *)
YUL_UINT_KEYWORD = "uint" ("8" | "16" | "24" | "32" | "40" | "48" | "56" | "64" | "72" | "80" | "88" | "96" | "104" | "112" | "120" | "128" | "136" | "144" | "152" | "160" | "168" | "176" | "184" | "192" | "200" | "208" | "216" | "224" | "232" | "240" | "248" | "256")?;

(* Reserved from 0.5.0 until 0.7.1 *)
YUL_UNCHECKED_KEYWORD = "unchecked";

(* Reserved until 0.7.1 *)
YUL_USING_KEYWORD = "using";

(* Reserved until 0.6.5 *)
YUL_VAR_KEYWORD = "var";

(* Reserved until 0.7.1 *)
YUL_VIEW_KEYWORD = "view";

(* Reserved from 0.6.0 until 0.7.1 *)
YUL_VIRTUAL_KEYWORD = "virtual";

(* Reserved until 0.7.1 *)
YUL_WEEKS_KEYWORD = "weeks";

(* Reserved until 0.7.1 *)
YUL_WEI_KEYWORD = "wei";

(* Reserved until 0.7.1 *)
YUL_WHILE_KEYWORD = "while";

(* Reserved until 0.7.1 *)
YUL_YEARS_KEYWORD = "years";

