// Slang License: https://github.com/NomicFoundation/slang/blob/main/LICENSE
// NAPI-RS License: https://github.com/napi-rs/napi-rs/blob/main/LICENSE

// @ts-nocheck

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export enum NodeType {
  Rule = 0,
  Token = 1,
}
export enum TokenKind {
  AbicoderKeyword = 0,
  AbstractKeyword = 1,
  AddressKeyword = 2,
  Ampersand = 3,
  AmpersandAmpersand = 4,
  AmpersandEqual = 5,
  AnonymousKeyword = 6,
  AsKeyword = 7,
  AsciiEscape = 8,
  AsciiStringLiteral = 9,
  AssemblyKeyword = 10,
  Asterisk = 11,
  AsteriskAsterisk = 12,
  AsteriskEqual = 13,
  Bang = 14,
  BangEqual = 15,
  Bar = 16,
  BarBar = 17,
  BarEqual = 18,
  BoolKeyword = 19,
  BreakKeyword = 20,
  ByteType = 21,
  CalldataKeyword = 22,
  Caret = 23,
  CaretEqual = 24,
  CaseKeyword = 25,
  CatchKeyword = 26,
  CloseBrace = 27,
  CloseBracket = 28,
  CloseParen = 29,
  Colon = 30,
  ColonEqual = 31,
  Comma = 32,
  ConstantKeyword = 33,
  ConstructorKeyword = 34,
  ContinueKeyword = 35,
  ContractKeyword = 36,
  DaysKeyword = 37,
  DecimalExponent = 38,
  DecimalLiteral = 39,
  DecimalNumber = 40,
  DefaultKeyword = 41,
  DeleteKeyword = 42,
  DoKeyword = 43,
  DoubleQuotedAsciiStringLiteral = 44,
  DoubleQuotedUnicodeStringLiteral = 45,
  ElseKeyword = 46,
  EmitKeyword = 47,
  EndOfLine = 48,
  EnumKeyword = 49,
  Equal = 50,
  EqualEqual = 51,
  EqualGreaterThan = 52,
  ErrorKeyword = 53,
  EscapeSequence = 54,
  EtherKeyword = 55,
  EventKeyword = 56,
  Evmasm = 57,
  ExperimentalKeyword = 58,
  ExternalKeyword = 59,
  FallbackKeyword = 60,
  FalseKeyword = 61,
  FinneyKeyword = 62,
  FixedBytesType = 63,
  ForKeyword = 64,
  FromKeyword = 65,
  FunctionKeyword = 66,
  GlobalKeyword = 67,
  GreaterThan = 68,
  GreaterThanEqual = 69,
  GreaterThanGreaterThan = 70,
  GreaterThanGreaterThanEqual = 71,
  GreaterThanGreaterThanGreaterThan = 72,
  GreaterThanGreaterThanGreaterThanEqual = 73,
  GweiKeyword = 74,
  HexByteEscape = 75,
  HexLiteral = 76,
  HexStringLiteral = 77,
  HoursKeyword = 78,
  Identifier = 79,
  IdentifierPart = 80,
  IdentifierStart = 81,
  IfKeyword = 82,
  ImmutableKeyword = 83,
  ImportKeyword = 84,
  IndexedKeyword = 85,
  InterfaceKeyword = 86,
  InternalKeyword = 87,
  IsKeyword = 88,
  LeaveKeyword = 89,
  LessThan = 90,
  LessThanEqual = 91,
  LessThanLessThan = 92,
  LessThanLessThanEqual = 93,
  LetKeyword = 94,
  LibraryKeyword = 95,
  MappingKeyword = 96,
  MemoryKeyword = 97,
  Minus = 98,
  MinusEqual = 99,
  MinusGreaterThan = 100,
  MinusMinus = 101,
  MinutesKeyword = 102,
  ModifierKeyword = 103,
  MultilineComment = 104,
  NewKeyword = 105,
  NotAnIdentifierInAnyVersion = 106,
  NotAnIdentifierInSomeVersions = 107,
  OpenBrace = 108,
  OpenBracket = 109,
  OpenParen = 110,
  OverrideKeyword = 111,
  PayableKeyword = 112,
  Percent = 113,
  PercentEqual = 114,
  Period = 115,
  Plus = 116,
  PlusEqual = 117,
  PlusPlus = 118,
  PossiblySeparatedPairsOfHexDigits = 119,
  PragmaKeyword = 120,
  PrivateKeyword = 121,
  PublicKeyword = 122,
  PureKeyword = 123,
  QuestionMark = 124,
  RawIdentifier = 125,
  ReceiveKeyword = 126,
  ReturnKeyword = 127,
  ReturnsKeyword = 128,
  RevertKeyword = 129,
  SecondsKeyword = 130,
  Semicolon = 131,
  SignedFixedType = 132,
  SignedIntegerType = 133,
  SingleLineComment = 134,
  SingleQuotedAsciiStringLiteral = 135,
  SingleQuotedUnicodeStringLiteral = 136,
  Slash = 137,
  SlashEqual = 138,
  SolidityKeyword = 139,
  StorageKeyword = 140,
  StringKeyword = 141,
  StructKeyword = 142,
  SwitchKeyword = 143,
  SzaboKeyword = 144,
  ThrowKeyword = 145,
  Tilde = 146,
  TrueKeyword = 147,
  TryKeyword = 148,
  TypeKeyword = 149,
  UncheckedKeyword = 150,
  UnicodeEscape = 151,
  UnicodeStringLiteral = 152,
  UnsignedFixedType = 153,
  UnsignedIntegerType = 154,
  UsingKeyword = 155,
  VarKeyword = 156,
  VersionPragmaValue = 157,
  ViewKeyword = 158,
  VirtualKeyword = 159,
  WeeksKeyword = 160,
  WeiKeyword = 161,
  WhileKeyword = 162,
  Whitespace = 163,
  YearsKeyword = 164,
  YulDecimalLiteral = 165,
  YulHexLiteral = 166,
  YulIdentifier = 167,
  YulKeyword = 168,
  YulReservedKeyword = 169,
}
export enum RuleKind {
  ABICoderPragma = 0,
  AddSubExpression = 1,
  AddSubOperator = 2,
  AddressType = 3,
  AndExpression = 4,
  AndOperator = 5,
  ArgumentList = 6,
  Arguments = 7,
  ArrayLiteral = 8,
  ArrayTypeName = 9,
  AssemblyFlags = 10,
  AssemblyStatement = 11,
  AssignmentExpression = 12,
  AssignmentOperator = 13,
  AsteriskImport = 14,
  BitAndExpression = 15,
  BitAndOperator = 16,
  BitOrExpression = 17,
  BitOrOperator = 18,
  BitXOrExpression = 19,
  BitXOrOperator = 20,
  Block = 21,
  BooleanLiteral = 22,
  BreakStatement = 23,
  CatchClause = 24,
  ConditionalExpression = 25,
  ConditionalOperator = 26,
  ConstantDefinition = 27,
  ConstructorAttribute = 28,
  ConstructorDefinition = 29,
  ContinueStatement = 30,
  ContractBodyElements = 31,
  ContractDefinition = 32,
  DataLocation = 33,
  Definition = 34,
  DeleteStatement = 35,
  Directive = 36,
  DoWhileStatement = 37,
  ElementaryType = 38,
  EmitStatement = 39,
  EndOfFileTrivia = 40,
  EnumDefinition = 41,
  EqualityComparisonExpression = 42,
  EqualityComparisonOperator = 43,
  ErrorDefinition = 44,
  ErrorParameter = 45,
  EventDefinition = 46,
  EventParameter = 47,
  ExperimentalPragma = 48,
  ExponentiationExpression = 49,
  ExponentiationOperator = 50,
  Expression = 51,
  ExpressionStatement = 52,
  FallbackFunctionAttribute = 53,
  FallbackFunctionDefinition = 54,
  ForStatement = 55,
  FunctionAttribute = 56,
  FunctionCallExpression = 57,
  FunctionCallOperator = 58,
  FunctionCallOptions = 59,
  FunctionDefinition = 60,
  FunctionType = 61,
  IdentifierPath = 62,
  IfStatement = 63,
  ImportAlias = 64,
  ImportDirective = 65,
  ImportPath = 66,
  IndexAccessExpression = 67,
  IndexAccessOperator = 68,
  InheritanceSpecifier = 69,
  InheritanceSpecifierList = 70,
  InterfaceDefinition = 71,
  LeadingTrivia = 72,
  LibraryDefinition = 73,
  MappingKeyType = 74,
  MappingType = 75,
  MappingValueType = 76,
  MemberAccessExpression = 77,
  MemberAccessOperator = 78,
  ModifierAttribute = 79,
  ModifierDefinition = 80,
  ModifierInvocation = 81,
  MulDivModExpression = 82,
  MulDivModOperator = 83,
  NamedArgument = 84,
  NamedArgumentList = 85,
  NewExpression = 86,
  NumberUnit = 87,
  NumericExpression = 88,
  OrExpression = 89,
  OrOperator = 90,
  OrderComparisonExpression = 91,
  OrderComparisonOperator = 92,
  OverrideSpecifier = 93,
  ParameterDeclaration = 94,
  ParameterList = 95,
  PayableType = 96,
  PositionalArgumentList = 97,
  PragmaDirective = 98,
  PrimaryExpression = 99,
  ReceiveFunctionAttribute = 100,
  ReceiveFunctionDefinition = 101,
  Results = 102,
  ReturnStatement = 103,
  RevertStatement = 104,
  SelectiveImport = 105,
  ShiftExpression = 106,
  ShiftOperator = 107,
  SimpleImport = 108,
  SimpleStatement = 109,
  SourceUnit = 110,
  StateVariableAttribute = 111,
  StateVariableDeclaration = 112,
  Statement = 113,
  StringExpression = 114,
  StructDefinition = 115,
  StructMember = 116,
  ThrowStatement = 117,
  TrailingTrivia = 118,
  TryStatement = 119,
  TupleDeconstructionStatement = 120,
  TupleExpression = 121,
  TypeExpression = 122,
  TypeName = 123,
  UnaryPostfixExpression = 124,
  UnaryPostfixOperator = 125,
  UnaryPrefixExpression = 126,
  UnaryPrefixOperator = 127,
  UncheckedBlock = 128,
  UnnamedFunctionAttribute = 129,
  UnnamedFunctionDefinition = 130,
  UserDefinedOperator = 131,
  UserDefinedValueTypeDefinition = 132,
  UsingDirective = 133,
  VariableDeclarationStatement = 134,
  VersionPragma = 135,
  VersionPragmaAlternatives = 136,
  VersionPragmaComparator = 137,
  VersionPragmaExpressionList = 138,
  VersionPragmaRange = 139,
  VersionPragmaSpecifier = 140,
  WhileStatement = 141,
  YulAssignmentStatement = 142,
  YulBlock = 143,
  YulBreakStatement = 144,
  YulContinueStatement = 145,
  YulDeclarationStatement = 146,
  YulExpression = 147,
  YulForStatement = 148,
  YulFunctionCallExpression = 149,
  YulFunctionDefinition = 150,
  YulIdentifierPath = 151,
  YulIfStatement = 152,
  YulLeaveStatement = 153,
  YulLiteral = 154,
  YulStatement = 155,
  YulSwitchStatement = 156,
}
export enum ProductionKind {
  ABICoderPragma = 0,
  AbicoderKeyword = 1,
  AbstractKeyword = 2,
  AddSubOperator = 3,
  AddressKeyword = 4,
  AddressType = 5,
  Ampersand = 6,
  AmpersandAmpersand = 7,
  AmpersandEqual = 8,
  AndOperator = 9,
  AnonymousKeyword = 10,
  ArgumentList = 11,
  ArrayLiteral = 12,
  AsKeyword = 13,
  AsciiEscape = 14,
  AsciiStringLiteral = 15,
  AssemblyFlags = 16,
  AssemblyKeyword = 17,
  AssemblyStatement = 18,
  AssignmentOperator = 19,
  Asterisk = 20,
  AsteriskAsterisk = 21,
  AsteriskEqual = 22,
  AsteriskImport = 23,
  Bang = 24,
  BangEqual = 25,
  Bar = 26,
  BarBar = 27,
  BarEqual = 28,
  BitAndOperator = 29,
  BitOrOperator = 30,
  BitXOrOperator = 31,
  Block = 32,
  BoolKeyword = 33,
  BooleanLiteral = 34,
  BreakKeyword = 35,
  BreakStatement = 36,
  ByteType = 37,
  CalldataKeyword = 38,
  Caret = 39,
  CaretEqual = 40,
  CaseKeyword = 41,
  CatchClause = 42,
  CatchKeyword = 43,
  CloseBrace = 44,
  CloseBracket = 45,
  CloseParen = 46,
  Colon = 47,
  ColonEqual = 48,
  Comma = 49,
  ConditionalOperator = 50,
  ConstantDefinition = 51,
  ConstantKeyword = 52,
  ConstructorAttribute = 53,
  ConstructorDefinition = 54,
  ConstructorKeyword = 55,
  ContinueKeyword = 56,
  ContinueStatement = 57,
  ContractDefinition = 58,
  ContractKeyword = 59,
  DataLocation = 60,
  DaysKeyword = 61,
  DecimalExponent = 62,
  DecimalLiteral = 63,
  DecimalNumber = 64,
  DefaultKeyword = 65,
  Definition = 66,
  DeleteKeyword = 67,
  DeleteStatement = 68,
  Directive = 69,
  DoKeyword = 70,
  DoWhileStatement = 71,
  DoubleQuotedAsciiStringLiteral = 72,
  DoubleQuotedUnicodeStringLiteral = 73,
  ElementaryType = 74,
  ElseKeyword = 75,
  EmitKeyword = 76,
  EmitStatement = 77,
  EndOfFileTrivia = 78,
  EndOfLine = 79,
  EnumDefinition = 80,
  EnumKeyword = 81,
  Equal = 82,
  EqualEqual = 83,
  EqualGreaterThan = 84,
  EqualityComparisonOperator = 85,
  ErrorDefinition = 86,
  ErrorKeyword = 87,
  ErrorParameter = 88,
  EscapeSequence = 89,
  EtherKeyword = 90,
  EventDefinition = 91,
  EventKeyword = 92,
  EventParameter = 93,
  Evmasm = 94,
  ExperimentalKeyword = 95,
  ExperimentalPragma = 96,
  ExponentiationOperator = 97,
  Expression = 98,
  ExpressionStatement = 99,
  ExternalKeyword = 100,
  FallbackFunctionAttribute = 101,
  FallbackFunctionDefinition = 102,
  FallbackKeyword = 103,
  FalseKeyword = 104,
  FinneyKeyword = 105,
  FixedBytesType = 106,
  ForKeyword = 107,
  ForStatement = 108,
  FromKeyword = 109,
  FunctionAttribute = 110,
  FunctionCallOperator = 111,
  FunctionCallOptions = 112,
  FunctionDefinition = 113,
  FunctionKeyword = 114,
  FunctionType = 115,
  GlobalKeyword = 116,
  GreaterThan = 117,
  GreaterThanEqual = 118,
  GreaterThanGreaterThan = 119,
  GreaterThanGreaterThanEqual = 120,
  GreaterThanGreaterThanGreaterThan = 121,
  GreaterThanGreaterThanGreaterThanEqual = 122,
  GweiKeyword = 123,
  HexByteEscape = 124,
  HexLiteral = 125,
  HexStringLiteral = 126,
  HoursKeyword = 127,
  Identifier = 128,
  IdentifierPart = 129,
  IdentifierPath = 130,
  IdentifierStart = 131,
  IfKeyword = 132,
  IfStatement = 133,
  ImmutableKeyword = 134,
  ImportAlias = 135,
  ImportDirective = 136,
  ImportKeyword = 137,
  ImportPath = 138,
  IndexAccessOperator = 139,
  IndexedKeyword = 140,
  InheritanceSpecifier = 141,
  InheritanceSpecifierList = 142,
  InterfaceDefinition = 143,
  InterfaceKeyword = 144,
  InternalKeyword = 145,
  IsKeyword = 146,
  LeadingTrivia = 147,
  LeaveKeyword = 148,
  LessThan = 149,
  LessThanEqual = 150,
  LessThanLessThan = 151,
  LessThanLessThanEqual = 152,
  LetKeyword = 153,
  LibraryDefinition = 154,
  LibraryKeyword = 155,
  MappingKeyType = 156,
  MappingKeyword = 157,
  MappingType = 158,
  MappingValueType = 159,
  MemberAccessOperator = 160,
  MemoryKeyword = 161,
  Minus = 162,
  MinusEqual = 163,
  MinusGreaterThan = 164,
  MinusMinus = 165,
  MinutesKeyword = 166,
  ModifierAttribute = 167,
  ModifierDefinition = 168,
  ModifierInvocation = 169,
  ModifierKeyword = 170,
  MulDivModOperator = 171,
  MultilineComment = 172,
  NamedArgument = 173,
  NamedArgumentList = 174,
  NewExpression = 175,
  NewKeyword = 176,
  NotAnIdentifierInAnyVersion = 177,
  NotAnIdentifierInSomeVersions = 178,
  NumberUnit = 179,
  NumericExpression = 180,
  OpenBrace = 181,
  OpenBracket = 182,
  OpenParen = 183,
  OrOperator = 184,
  OrderComparisonOperator = 185,
  OverrideKeyword = 186,
  OverrideSpecifier = 187,
  ParameterDeclaration = 188,
  ParameterList = 189,
  PayableKeyword = 190,
  PayableType = 191,
  Percent = 192,
  PercentEqual = 193,
  Period = 194,
  Plus = 195,
  PlusEqual = 196,
  PlusPlus = 197,
  PositionalArgumentList = 198,
  PossiblySeparatedPairsOfHexDigits = 199,
  PragmaDirective = 200,
  PragmaKeyword = 201,
  PrimaryExpression = 202,
  PrivateKeyword = 203,
  PublicKeyword = 204,
  PureKeyword = 205,
  QuestionMark = 206,
  RawIdentifier = 207,
  ReceiveFunctionAttribute = 208,
  ReceiveFunctionDefinition = 209,
  ReceiveKeyword = 210,
  ReturnKeyword = 211,
  ReturnStatement = 212,
  ReturnsKeyword = 213,
  RevertKeyword = 214,
  RevertStatement = 215,
  SecondsKeyword = 216,
  SelectiveImport = 217,
  Semicolon = 218,
  ShiftOperator = 219,
  SignedFixedType = 220,
  SignedIntegerType = 221,
  SimpleImport = 222,
  SimpleStatement = 223,
  SingleLineComment = 224,
  SingleQuotedAsciiStringLiteral = 225,
  SingleQuotedUnicodeStringLiteral = 226,
  Slash = 227,
  SlashEqual = 228,
  SolidityKeyword = 229,
  SourceUnit = 230,
  StateVariableAttribute = 231,
  StateVariableDeclaration = 232,
  Statement = 233,
  StorageKeyword = 234,
  StringExpression = 235,
  StringKeyword = 236,
  StructDefinition = 237,
  StructKeyword = 238,
  StructMember = 239,
  SwitchKeyword = 240,
  SzaboKeyword = 241,
  ThrowKeyword = 242,
  ThrowStatement = 243,
  Tilde = 244,
  TrailingTrivia = 245,
  TrueKeyword = 246,
  TryKeyword = 247,
  TryStatement = 248,
  TupleDeconstructionStatement = 249,
  TupleExpression = 250,
  TypeExpression = 251,
  TypeKeyword = 252,
  TypeName = 253,
  UnaryPostfixOperator = 254,
  UnaryPrefixOperator = 255,
  UncheckedBlock = 256,
  UncheckedKeyword = 257,
  UnicodeEscape = 258,
  UnicodeStringLiteral = 259,
  UnnamedFunctionAttribute = 260,
  UnnamedFunctionDefinition = 261,
  UnsignedFixedType = 262,
  UnsignedIntegerType = 263,
  UserDefinedOperator = 264,
  UserDefinedValueTypeDefinition = 265,
  UsingDirective = 266,
  UsingKeyword = 267,
  VarKeyword = 268,
  VariableDeclarationStatement = 269,
  VersionPragma = 270,
  VersionPragmaSpecifier = 271,
  VersionPragmaValue = 272,
  ViewKeyword = 273,
  VirtualKeyword = 274,
  WeeksKeyword = 275,
  WeiKeyword = 276,
  WhileKeyword = 277,
  WhileStatement = 278,
  Whitespace = 279,
  YearsKeyword = 280,
  YulAssignmentStatement = 281,
  YulBlock = 282,
  YulBreakStatement = 283,
  YulContinueStatement = 284,
  YulDecimalLiteral = 285,
  YulDeclarationStatement = 286,
  YulExpression = 287,
  YulForStatement = 288,
  YulFunctionDefinition = 289,
  YulHexLiteral = 290,
  YulIdentifier = 291,
  YulIdentifierPath = 292,
  YulIfStatement = 293,
  YulKeyword = 294,
  YulLeaveStatement = 295,
  YulLiteral = 296,
  YulReservedKeyword = 297,
  YulStatement = 298,
  YulSwitchStatement = 299,
}
export class RuleNode {
  get type(): NodeType.Rule;
  get kind(): RuleKind;
  get byteRange(): [start: number, end: number];
  get charRange(): [start: number, end: number];
  get byteRangeIncludingTrivia(): [start: number, end: number];
  get charRangeIncludingTrivia(): [start: number, end: number];
  get children(): (RuleNode | TokenNode)[];
}
export class TokenNode {
  get type(): NodeType.Token;
  get kind(): TokenKind;
  get byteRange(): [start: number, end: number];
  get charRange(): [start: number, end: number];
  get byteRangeIncludingTrivia(): [start: number, end: number];
  get charRangeIncludingTrivia(): [start: number, end: number];
  get trivia(): (RuleNode | TokenNode)[];
}
export class Language {
  constructor(version: string);
  get version(): string;
  static supportedVersions(): Array<string>;
  parse(productionKind: ProductionKind, input: string): ParseOutput;
}
export class ParseOutput {
  get parseTree(): RuleNode | TokenNode | null;
  get errors(): Array<ParseError>;
  get isValid(): boolean;
}
export class ParseError {
  get bytePosition(): number;
  get charPosition(): number;
  get expected(): Array<string>;
  toErrorReport(sourceId: string, source: string, withColour: boolean): string;
}
