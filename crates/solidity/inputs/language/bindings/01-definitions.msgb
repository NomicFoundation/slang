;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Contracts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@contract [ContractDefinition @name name: [Identifier]] {
  node @contract.lexical_scope
  node @contract.extensions
  node @contract.def
  node @contract.members
  node @contract.ns
  node @contract.modifiers
  node @contract.instance

  attr (@contract.def) node_definition = @name
  attr (@contract.def) definiens_node = @contract
  ; The .extensions node is where `using` directives will hook the definitions
  attr (@contract.def) extension_scope = @contract.extensions

  edge @contract.lexical_scope -> @contract.instance

  ; Instance scope can also see members and our namespace definitions
  edge @contract.instance -> @contract.members
  edge @contract.instance -> @contract.ns

  let @contract.enclosing_def = @contract.def

  ;; External "instance" scope access: either member access through a variable
  ;; of the contract's type, or through calling (which happens on `new`
  ;; invocations or casting). These should access only externally accessible
  ;; members, such as functions and public variables.
  node member
  attr (member) pop_symbol = "."
  edge member -> @contract.instance

  node type_def
  attr (type_def) pop_symbol = "@typeof"
  edge @contract.def -> type_def
  edge type_def -> member

  node call
  attr (call) pop_symbol = "()"
  edge @contract.def -> call
  edge call -> member

  ;; "namespace" scope access
  node ns_member
  attr (ns_member) pop_symbol = "."
  edge @contract.def -> ns_member
  edge ns_member -> @contract.ns

  ; Finally there's an @instance guarded path used by derived contracts to
  ; access instance accessible members
  node instance
  attr (instance) pop_symbol = "@instance"
  edge @contract.def -> instance
  edge instance -> @contract.instance

  ; "this" keyword is available in our lexical scope and can access any
  ; externally available member
  node this
  attr (this) pop_symbol = "this"
  edge @contract.lexical_scope -> this
  edge this -> member

  ;; Modifiers are available as a contract type members through a special '@modifier' guard
  node modifier
  attr (modifier) pop_symbol = "@modifier"
  edge @contract.ns -> modifier
  edge modifier -> @contract.modifiers

  ; There may be attached functions to our type. For the general case of
  ; variables of our type, that's already handled via normal lexical scope
  ; resolution. But for casting/`new` invocations that we resolve through the
  ; `()` guard above, we need to explicitly jump to the extension scope from
  ; here to attempt resolving the attached function. We cannot jump back to the
  ; parent scope because that would create a cycle in the graph.
  node push_typeof
  attr (push_typeof) push_symbol = "@typeof"
  node push_name
  attr (push_name) push_symbol = (source-text @name)
  node hook
  attr (hook) extension_hook

  edge call -> push_typeof
  edge push_typeof -> push_name
  edge push_name -> hook

  if (version-matches "< 0.5.0") {
    ; For Solidity < 0.5.0 `this` also acts like an `address`
    node address_ref
    attr (address_ref) push_symbol = "%address"
    node address_typeof
    attr (address_typeof) push_symbol = "@typeof"
    edge this -> address_typeof
    edge address_typeof -> address_ref
    edge address_ref -> @contract.lexical_scope
  }

  ; This is the connection point to resolve attached functions by `using for *`
  node @contract.star_extension
  attr (@contract.star_extension) push_symbol = "@*"

  if (version-matches "< 0.7.0") {
    ; For Solidity < 0.7.0 using directives are inherited, so we need to connect
    ; always For newer versions, this connection only happens when there is a
    ; `using for *` directive in the contract (see rule below)
    edge @contract.star_extension -> @contract.lexical_scope
  }

  ; Path to resolve the built-in type for type() expressions
  node type
  attr (type) pop_symbol = "@type"
  node type_contract_type
  attr (type_contract_type) push_symbol = "%ContractTypeType"
  edge @contract.def -> type
  edge type -> type_contract_type
  edge type_contract_type -> @contract.parent_scope

  ; The following defines the connection nodes the resolution algorithm uses
  ; *only when setting a compilation context/target*.

  ; This attribute defines the sink of edges added from base contracts when
  ; setting this contract as the compilation context, and should provide access
  ; to anything that can be reached through `super`. The instance scope is a bit
  ; too broad, but `.members` is too narrow as it doesn't allow navigation to
  ; parent contracts (and from the base we need to be able to reach all
  ; contracts in the hierarchy).
  attr (@contract.def) export_node = @contract.instance

  ; This node will eventually connect to the contract's members being compiled
  ; and grants access to definitions in that contract and all its parents
  ; (recursively). It only makes sense if `super` is defined (ie. if we have
  ; parents), but we define it here to be able to use it in the declaration of
  ; import nodes. This is the dual of the export_node above.
  node @contract.super_import
  attr (@contract.super_import) pop_symbol = "."

  ; This defines the source side of edges added to base contracts when setting
  ; a contract as compilation context; this allows this contract (a base) to
  ; access virtual methods in any sub-contract defined in the hierarchy (both
  ; with and without `super`, hence the two connection points).
  attr (@contract.def) import_nodes = [@contract.lexical_scope, @contract.super_import]
}

@contract [ContractDefinition @specifier [InheritanceSpecifier]] {
  ; The `.heir` scoped variable allows the rules for `InheritanceSpecifier`
  ; above to connect the instance scope of this contract to the parents.
  let @specifier.heir = @contract
  attr (@contract.def) parents = @specifier.parent_refs
  if (version-matches "< 0.7.0") {
    attr (@contract.def) inherit_extensions
  }

  ; The rest of these statements deal with defining and connecting the `super`
  ; keyword path.

  ; `super_scope` is where we hook all references to our parent contracts
  node @contract.super_scope

  ; Define "super" in the lexical scope
  node @contract.super
  attr (@contract.super) pop_symbol = "super"
  edge @contract.lexical_scope -> @contract.super

  ; This connects `super` to exported scopes from all contracts in the hierarchy
  ; when setting a contract compilation target (see more detailed description
  ; above on the definition of the `super_import` node).
  edge @contract.super -> @contract.super_import

  ; Then connect it through an `@instance` guard to the parent contracts through
  ; `super_scope`. This allows "instance"-like access to members of parents
  ; through `super`.
  node super_instance
  attr (super_instance) push_symbol = "@instance"
  edge @contract.super_import -> super_instance
  edge super_instance -> @contract.super_scope
}

@contract [ContractDefinition [InheritanceSpecifier [InheritanceTypes
    [InheritanceType @type_name [IdentifierPath]]
]]] {
  ;; The base contract defs are directly accesible through our super scope
  edge @contract.super_scope -> @type_name.push_begin
}

; Pure definitions that cannot contain expressions
@contract [ContractDefinition [ContractMembers
    [ContractMember @member (
          [EnumDefinition]
        | [StructDefinition]
        | [EventDefinition]
        | [ErrorDefinition]
        | [UserDefinedValueTypeDefinition]
    )]
]] {
  edge @member.lexical_scope -> @contract.lexical_scope
}

; Definitions that can contain expressions need two scopes:
; - normal lexical scope for resolving types
; - extended scope (extended by using directives) for resolving expressions
@contract [ContractDefinition [ContractMembers
    [ContractMember @member (
          [FunctionDefinition]
        | [ConstructorDefinition]
        | [ModifierDefinition]
        | [FallbackFunctionDefinition]
        | [ReceiveFunctionDefinition]
        | [UnnamedFunctionDefinition]
        | [StateVariableDefinition]
    )]
]] {
  edge @member.lexical_scope -> @contract.lexical_scope
}

@contract [ContractDefinition [ContractMembers
    [ContractMember @using [UsingDirective]]
]] {
  ; Hook the using definition in the extensions scope
  edge @contract.extensions -> @using.def
}

@contract [ContractDefinition [ContractMembers
    [ContractMember @member (
          [EnumDefinition]
        | [StructDefinition]
        | [EventDefinition]
        | [ErrorDefinition]
        | [UserDefinedValueTypeDefinition]
    )]
]] {
  ; These definition go into the "namespace" scope and are accessible externally
  ; via qualified naming (eg. `Contract.MyStruct`)
  edge @contract.ns -> @member.def
}

@contract [ContractDefinition [ContractMembers
    [ContractMember @state_var [StateVariableDefinition]]
]] {
  ; State variables are available to derived contracts.
  ; TODO: this also exposes private state variables to derived contracts, but we
  ; can't easily filter them because we don't have negative assertions in our
  ; query language (we would need to modify this query for anything *not*
  ; containing a `PrivateKeyword` node)
  edge @contract.instance -> @state_var.def
}

;; Public state variables are also exposed as external member functions
@contract [ContractDefinition [ContractMembers
    [ContractMember @state_var [StateVariableDefinition
        [StateVariableAttributes [StateVariableAttribute [PublicKeyword]]]
    ]]
]] {
  edge @contract.members -> @state_var.def
}

@contract [ContractDefinition [ContractMembers
    [ContractMember @function [FunctionDefinition]]
]] {
  ;; Contract functions are also accessible for an instance of the contract
  edge @contract.members -> @function.def

  ;; This may prioritize this definition (when there are multiple options)
  ;; according to the C3 linerisation ordering
  attr (@function.def) tag = "c3"
  attr (@function.def) parents = [@contract.def]
}

@contract [ContractDefinition [ContractMembers
    [ContractMember @function [FunctionDefinition
        [FunctionAttributes [FunctionAttribute ([ExternalKeyword] | [PublicKeyword])]]
    ]]
]] {
  ; Public or external functions are also accessible through the contract type
  ; (to retrieve their `.selector` for example)
  edge @contract.ns -> @function.def
}

@contract [ContractDefinition members: [ContractMembers
    [ContractMember @modifier [ModifierDefinition]]
]] {
  ; Modifiers live in their own special scope
  edge @contract.modifiers -> @modifier.def

  ;; This may prioritize this definition (when there are multiple options)
  ;; according to the C3 linerisation ordering
  attr (@modifier.def) tag = "c3"
  attr (@modifier.def) parents = [@contract.def]
}

@contract [ContractDefinition [ContractMembers [ContractMember
    [UsingDirective [UsingTarget [Asterisk]]]
]]] {
  ; Connect the star extension node to the resolution extended scope if there is
  ; a `using for *` directive in the contract
  edge @contract.star_extension -> @contract.lexical_scope
}

; This applies to both state variables and function definitions
@override [OverrideSpecifier [OverridePathsDeclaration [OverridePaths
    @base_ident [IdentifierPath]
]]] {
  ;; Resolve overriden bases when listed in the function or modifiers modifiers
  edge @base_ident.push_end -> @override.parent_scope
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Interfaces
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@interface [InterfaceDefinition @name name: [Identifier]] {
  node @interface.lexical_scope
  node @interface.def
  node @interface.members
  node @interface.ns
  node @interface.instance

  attr (@interface.def) node_definition = @name
  attr (@interface.def) definiens_node = @interface

  edge @interface.lexical_scope -> @interface.instance

  ; The extensions node is required for the inheritance rules, but not used in interfaces
  let @interface.extensions = (node)

  edge @interface.instance -> @interface.members
  edge @interface.instance -> @interface.ns

  ;; External "instance" like access path, to access members of a variable of
  ;; the interface's type or through a casting call.
  node member
  attr (member) pop_symbol = "."
  edge member -> @interface.instance

  node typeof
  attr (typeof) pop_symbol = "@typeof"
  edge @interface.def -> typeof
  edge typeof -> member

  node call
  attr (call) pop_symbol = "()"
  edge @interface.def -> call
  edge call -> member

  ; From a call we may need to resolve using the extensions scope, in case there's
  ; a `using` directive on our type. This path ends up jumping to scope just to
  ; handle that case.
  node push_typeof
  attr (push_typeof) push_symbol = "@typeof"
  node push_name
  attr (push_name) push_symbol = (source-text @name)
  edge call -> push_typeof
  edge push_typeof -> push_name
  node hook
  attr (hook) extension_hook
  edge push_name -> hook
  ; edge push_name -> JUMP_TO_SCOPE_NODE

  ;; "namespace" like access path
  node ns_member
  attr (ns_member) pop_symbol = "."
  edge @interface.def -> ns_member
  edge ns_member -> @interface.ns

  ; Finally there's guarded `@instance` path used by derived contracts to access
  ; instance accessible members
  node instance
  attr (instance) pop_symbol = "@instance"
  edge @interface.def -> instance
  edge instance -> @interface.instance

  ; Path to resolve the built-in type for type() expressions
  node type
  attr (type) pop_symbol = "@type"
  node type_interface_type
  attr (type_interface_type) push_symbol = "%InterfaceTypeType"
  edge @interface.def -> type
  edge type -> type_interface_type
  edge type_interface_type -> @interface.parent_scope
}

@interface [InterfaceDefinition @specifier [InheritanceSpecifier]] {
  let @specifier.heir = @interface
  attr (@interface.def) parents = @specifier.parent_refs
}

@interface [InterfaceDefinition [InterfaceMembers
    [ContractMember @member (
          [EnumDefinition]
        | [FunctionDefinition]
        | [StructDefinition]
        | [EventDefinition]
        | [ErrorDefinition]
        | [UserDefinedValueTypeDefinition]
    )]
]] {
  edge @member.lexical_scope -> @interface.lexical_scope
  edge @interface.ns -> @member.def
}

;; Allow references (eg. variables of the interface type) to the interface to
;; access functions
@interface [InterfaceDefinition members: [InterfaceMembers
    item: [ContractMember @function variant: [FunctionDefinition]]
]] {
  edge @interface.members -> @function.def
}

[InterfaceDefinition [InterfaceMembers [ContractMember @using [UsingDirective]]]] {
  ; using directives are not allowed in interfaces, but the grammar allows them
  ; so we need to create an artificial node here to connect to created edges from
  ; the instance nodes
  let @using.lexical_scope = (node)
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Common inheritance rules (apply to contracts and interfaces)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@specifier [InheritanceSpecifier [InheritanceTypes
    [InheritanceType @type_name [IdentifierPath]]
]] {
  ;; This should point to the enclosing contract or interface definition
  let heir = @specifier.heir

  ;; Resolve base names through the parent scope of our heir (contract or
  ;; interface), aka the source unit
  edge @type_name.push_end -> heir.parent_scope

  ; Access instance members of the inherited contract/interface, from the
  ; instance scope of the inheriting contract/interface
  node instance
  attr (instance) push_symbol = "@instance"
  edge heir.instance -> instance
  edge instance -> @type_name.push_begin

  ; Base members can also be accessed (from the instance scope) qualified with
  ; the base name (eg. `Base.something`)
  node member_pop
  attr (member_pop) pop_symbol = "."
  edge heir.instance -> @type_name.pop_begin
  edge @type_name.pop_end -> member_pop
  edge member_pop -> instance

  ; Base namespace-like members (ie. enums, structs, etc) are also accessible as
  ; our own namespace members
  node ns_member
  attr (ns_member) push_symbol = "."
  edge heir.ns -> ns_member
  edge ns_member -> @type_name.push_begin
}

;; The next couple of rules setup a `.parent_refs` attribute to use in the
;; resolution algorithm to perform linearisation of a contract hierarchy.

;; NOTE: we use anchors here to prevent the query engine from returning all the
;; sublists of possible parents
@specifier [InheritanceSpecifier [InheritanceTypes . @parents [_]+ .]] {
  var parent_refs = []
  for parent in @parents {
    if (eq (node-type parent) "InheritanceType") {
      ;; this is intentionally reversed because of how Solidity linearised the contract bases
      set parent_refs = (concat [parent.ref] parent_refs)
    }
  }
  let @specifier.parent_refs = parent_refs
}

@parent [InheritanceType @type_name [IdentifierPath]] {
  let @parent.ref = @type_name.push_begin
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Libraries
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@library [LibraryDefinition @name name: [Identifier]] {
  node @library.lexical_scope
  node @library.extensions
  node @library.def
  node @library.ns
  node @library.modifiers

  attr (@library.def) node_definition = @name
  attr (@library.def) definiens_node = @library
  ; The .extensions node is where `using` directives will hook the definitions
  attr (@library.def) extension_scope = @library.extensions

  edge @library.lexical_scope -> @library.ns

  let @library.enclosing_def = @library.def

  node member
  attr (member) pop_symbol = "."
  edge @library.def -> member
  edge member -> @library.ns

  ; Access to modifiers is guarded by a @modifier symbol
  node modifier
  attr (modifier) pop_symbol = "@modifier"
  edge @library.ns -> modifier
  edge modifier -> @library.modifiers

  ; Path to resolve the built-in type for type() expressions (same as contracts)
  node type
  attr (type) pop_symbol = "@type"
  node type_library_type
  attr (type_library_type) push_symbol = "%ContractTypeType"
  edge @library.def -> type
  edge type -> type_library_type
  edge type_library_type -> @library.lexical_scope

  ; This is the connection point to resolve attached functions by `using for *`
  node @library.star_extension
  attr (@library.star_extension) push_symbol = "@*"
}

@library [LibraryDefinition [LibraryMembers
    [ContractMember @member (
          [EnumDefinition]
        | [StructDefinition]
        | [EventDefinition]
        | [ErrorDefinition]
        | [UserDefinedValueTypeDefinition]
    )]
]] {
  edge @member.lexical_scope -> @library.lexical_scope
  edge @library.ns -> @member.def
}

@library [LibraryDefinition [LibraryMembers
    [ContractMember @member (
          [FunctionDefinition]
        | [StateVariableDefinition [StateVariableAttributes [StateVariableAttribute [ConstantKeyword]]]]
    )]
]] {
  edge @member.lexical_scope -> @library.lexical_scope
  edge @library.ns -> @member.def
}

@library [LibraryDefinition [LibraryMembers
    [ContractMember @modifier [ModifierDefinition]]
]] {
  edge @library.modifiers -> @modifier.def
  edge @modifier.lexical_scope -> @library.lexical_scope
}

@library [LibraryDefinition [LibraryMembers
    [ContractMember @using [UsingDirective]]
]] {
  ; Expose the using directive from the extensions scope
  edge @library.extensions -> @using.def
}

@library [LibraryDefinition [LibraryMembers [ContractMember
    [UsingDirective [UsingTarget [Asterisk]]]
]]] {
  ; Connect the star extension node to the resolution extended scope if there is
  ; a `using for *` directive in the library
  edge @library.star_extension -> @library.lexical_scope
}



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Function, parameter declarations and modifiers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@param [Parameter @type_name [TypeName]] {
  node @param.lexical_scope
  node @param.def

  edge @type_name.type_ref -> @param.lexical_scope

  node @param.typeof
  attr (@param.typeof) push_symbol = "@typeof"
  edge @param.typeof -> @type_name.output
}

@param [Parameter @name [Identifier]] {
  attr (@param.def) node_definition = @name
  attr (@param.def) definiens_node = @param

  edge @param.def -> @param.typeof
}

@params [ParametersDeclaration] {
  node @params.lexical_scope
  node @params.defs

  ;; This scope can be used to resolve named argument calls
  node @params.names
  attr (@params.names) pop_symbol = "@param_names"
  edge @params.names -> @params.defs
}

@params [ParametersDeclaration [Parameters @param item: [Parameter]]] {
  edge @param.lexical_scope -> @params.lexical_scope
  edge @params.defs -> @param.def
}

@function [FunctionDefinition @attrs [FunctionAttributes]] {
  var type_symbol = "%Function"
  scan (source-text @attrs) {
    "\\b(public|external)\\b" {
      set type_symbol = "%ExternalFunction"
    }
  }

  node @function.lexical_scope
  node @function.def

  ; this path from the function definition to the scope allows attaching
  ; functions to this function's type
  node typeof
  attr (typeof) push_symbol = "@typeof"
  node type_function
  attr (type_function) push_symbol = type_symbol
  edge @function.def -> typeof
  edge typeof -> type_function
  edge type_function -> @function.lexical_scope
}

@function [FunctionDefinition name: [FunctionName @name [Identifier]]] {
  attr (@function.def) node_definition = @name
  attr (@function.def) definiens_node = @function
}

@function [FunctionDefinition @params parameters: [ParametersDeclaration]] {
  edge @params.lexical_scope -> @function.lexical_scope

  ;; Input parameters are available in the function scope
  edge @function.lexical_scope -> @params.defs
  ;; ... and shadow other declarations
  attr (@function.lexical_scope -> @params.defs) precedence = 1

  ;; Connect to paramaters for named argument resolution
  edge @function.def -> @params.names
}

@function [FunctionDefinition returns: [ReturnsDeclaration
    @return_params [ParametersDeclaration]
]] {
  edge @return_params.lexical_scope -> @function.lexical_scope

  ;; Return parameters are available in the function scope
  edge @function.lexical_scope -> @return_params.defs
  ;; ... and shadow other declarations
  attr (@function.lexical_scope -> @return_params.defs) precedence = 1
}

;; Only functions that return a single value have an actual return type
;; since tuples are not actual types in Solidity
@function [FunctionDefinition returns: [ReturnsDeclaration
    [ParametersDeclaration [Parameters . @param [Parameter] .]]
]] {
  node call
  attr (call) pop_symbol = "()"

  edge @function.def -> call
  edge call -> @param.typeof
}

;; Connect the function body's block lexical scope to the function
@function [FunctionDefinition [FunctionBody @block [Block]]] {
  edge @block.lexical_scope -> @function.lexical_scope
}

@function [FunctionDefinition [FunctionAttributes item: [FunctionAttribute
    @modifier [ModifierInvocation]
]]] {
  edge @modifier.lexical_scope -> @function.lexical_scope
}

@modifier [ModifierInvocation @name [IdentifierPath]] {
  node @modifier.lexical_scope

  node modifier
  attr (modifier) push_symbol = "@modifier"

  edge @name.push_end -> modifier
  edge modifier -> @modifier.lexical_scope

  ; This allows resolving @name in the more general scope in constructors (since
  ; calling a parent constructor is parsed as a modifier invocation)
  let @modifier.identifier = @name.push_end
}

@modifier [ModifierInvocation @args [ArgumentsDeclaration]] {
  edge @args.lexical_scope -> @modifier.lexical_scope
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; State Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@state_var [StateVariableDefinition] {
  node @state_var.lexical_scope
  node @state_var.def
}

@state_var [StateVariableDefinition
    @type_name type_name: [TypeName]
    @name name: [Identifier]
] {
  attr (@state_var.def) node_definition = @name
  attr (@state_var.def) definiens_node = @state_var

  edge @type_name.type_ref -> @state_var.lexical_scope

  node @state_var.typeof
  attr (@state_var.typeof) push_symbol = "@typeof"

  edge @state_var.def -> @state_var.typeof
  edge @state_var.typeof -> @type_name.output
}

@state_var [StateVariableDefinition
    [StateVariableAttributes [StateVariableAttribute [PublicKeyword]]]
] {
  ; Public state variables are used as functions when invoked from an external contract
  node call
  attr (call) pop_symbol = "()"

  ; In the general case using the getter can bind to the state variable's type
  edge @state_var.def -> call
  edge call -> @state_var.typeof

  ; Some complex types generate special getters (ie. arrays and mappings index
  ; their contents, structs flatten most of their fields and return a tuple)
  node getter
  attr (getter) push_symbol = "@as_getter"
  edge call -> getter
  edge getter -> @state_var.typeof
}

@state_var [StateVariableDefinition
    [StateVariableDefinitionValue @value [Expression]]
] {
  let @value.lexical_scope = @state_var.lexical_scope
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Structure definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@struct [StructDefinition @name name: [Identifier]] {
  node @struct.lexical_scope
  node @struct.def
  node @struct.members

  attr (@struct.def) node_definition = @name
  attr (@struct.def) definiens_node = @struct

  ; Now connect normally to the struct members
  node @struct.typeof
  attr (@struct.typeof) pop_symbol = "@typeof"
  node member
  attr (member) pop_symbol = "."
  edge @struct.def -> @struct.typeof
  edge @struct.typeof -> member
  edge member -> @struct.members

  ; Bind member names when using construction with named arguments
  node param_names
  attr (param_names) pop_symbol = "@param_names"
  edge @struct.def -> param_names
  edge param_names -> @struct.members

  ; Used as a function call (ie. casting), should bind to itself
  node call
  attr (call) pop_symbol = "()"
  edge @struct.def -> call
  edge call -> member
}

@struct [StructDefinition [StructMembers
    @member item: [StructMember @type_name [TypeName] @name name: [Identifier]]
]] {
  node @member.def
  attr (@member.def) node_definition = @name
  attr (@member.def) definiens_node = @member

  edge @struct.members -> @member.def

  edge @type_name.type_ref -> @struct.lexical_scope

  node @member.typeof
  attr (@member.typeof) push_symbol = "@typeof"

  edge @member.def -> @member.typeof
  edge @member.typeof -> @type_name.output
}

@struct [StructDefinition [StructMembers . @first_member [StructMember]]] {
  ; As a public getter result, the value returned is a tuple with all our fields flattened
  ; We only care about the first member for name binding, since tuples are not real types
  node getter_call
  attr (getter_call) pop_symbol = "@as_getter"
  edge @struct.typeof -> getter_call
  edge getter_call -> @first_member.typeof
}
