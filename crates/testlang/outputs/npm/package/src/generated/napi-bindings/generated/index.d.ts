// This file is generated automatically by infrastructure scripts. Please don't edit by hand.

// Slang License: https://github.com/NomicFoundation/slang/blob/main/LICENSE
// NAPI-RS License: https://github.com/napi-rs/napi-rs/blob/main/LICENSE

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare namespace cst {
  export enum NonterminalKind {
    AdditionExpression = "AdditionExpression",
    Expression = "Expression",
    Literal = "Literal",
    MemberAccessExpression = "MemberAccessExpression",
    NegationExpression = "NegationExpression",
    SeparatedIdentifiers = "SeparatedIdentifiers",
    SourceUnit = "SourceUnit",
    SourceUnitMember = "SourceUnitMember",
    SourceUnitMembers = "SourceUnitMembers",
    Tree = "Tree",
    TreeNode = "TreeNode",
    TreeNodeChild = "TreeNodeChild",
    TreeNodeChildren = "TreeNodeChildren",
  }
  export enum EdgeLabel {
    Item = "Item",
    Variant = "Variant",
    Separator = "Separator",
    Operand = "Operand",
    LeftOperand = "LeftOperand",
    RightOperand = "RightOperand",
    LeadingTrivia = "LeadingTrivia",
    TrailingTrivia = "TrailingTrivia",
    CloseBracket = "CloseBracket",
    Keyword = "Keyword",
    Member = "Member",
    Members = "Members",
    Name = "Name",
    Node = "Node",
    OpenBracket = "OpenBracket",
    Operator = "Operator",
    Period = "Period",
    Semicolon = "Semicolon",
  }
  export enum TerminalKind {
    UNRECOGNIZED = "UNRECOGNIZED",
    MISSING = "MISSING",
    Bang = "Bang",
    CloseBracket = "CloseBracket",
    DelimitedIdentifier = "DelimitedIdentifier",
    EndOfLine = "EndOfLine",
    Identifier = "Identifier",
    MultiLineComment = "MultiLineComment",
    OpenBracket = "OpenBracket",
    Period = "Period",
    Plus = "Plus",
    Semicolon = "Semicolon",
    SingleLineComment = "SingleLineComment",
    StringLiteral = "StringLiteral",
    TreeKeyword = "TreeKeyword",
    Whitespace = "Whitespace",
  }
  export enum NodeType {
    Nonterminal = "Nonterminal",
    Terminal = "Terminal",
  }
  export interface QueryMatch {
    queryNumber: number;
    captures: { [key: string]: cst.Cursor[] };
  }
  export interface TextIndex {
    utf8: number;
    utf16: number;
    line: number;
    column: number;
  }
  export interface TextRange {
    start: TextIndex;
    end: TextIndex;
  }
  export class NonterminalNode {
    get type(): cst.NodeType.Nonterminal;
    get kind(): cst.NonterminalKind;
    get textLength(): cst.TextIndex;
    children(): Array<cst.Node>;
    createCursor(textOffset: cst.TextIndex): cst.Cursor;
    /** Serialize the node to JSON. */
    toJSON(): string;
    unparse(): string;
  }
  export class TerminalNode {
    get type(): cst.NodeType.Terminal;
    get kind(): cst.TerminalKind;
    get textLength(): cst.TextIndex;
    get text(): string;
    /** Serialize the node to JSON. */
    toJSON(): string;
    createCursor(textOffset: cst.TextIndex): cst.Cursor;
  }
  export class Cursor {
    reset(): void;
    complete(): void;
    clone(): Cursor;
    spawn(): Cursor;
    get isCompleted(): boolean;
    node(): cst.Node;
    get label(): cst.EdgeLabel;
    get textOffset(): cst.TextIndex;
    get textRange(): cst.TextRange;
    get depth(): number;
    ancestors(): Array<cst.NonterminalNode>;
    goToNext(): boolean;
    goToNextNonDescendent(): boolean;
    goToPrevious(): boolean;
    goToParent(): boolean;
    goToFirstChild(): boolean;
    goToLastChild(): boolean;
    goToNthChild(childNumber: number): boolean;
    goToNextSibling(): boolean;
    goToPreviousSibling(): boolean;
    goToNextTerminal(): boolean;
    goToNextTerminalWithKind(kind: cst.TerminalKind): boolean;
    goToNextTerminalWithKinds(kinds: Array<cst.TerminalKind>): boolean;
    goToNextNonterminal(): boolean;
    goToNextNonterminalWithKind(kind: cst.NonterminalKind): boolean;
    goToNextNonterminalWithKinds(kinds: Array<cst.NonterminalKind>): boolean;
    query(queries: Array<cst.Query>): cst.QueryMatchIterator;
  }
  export class Query {
    static parse(text: string): Query;
  }
  export class QueryMatchIterator {
    next(): QueryMatch | null;
  }
}
export declare namespace parser {
  export class Language {
    constructor(version: string);
    get version(): string;
    static supportedVersions(): Array<string>;
    static rootKind(): cst.NonterminalKind;
    parse(kind: cst.NonterminalKind, input: string): parser.ParseOutput;
  }
  export class ParseError {
    severity(): diagnostic.Severity;
    textRange(): cst.TextRange;
    message(): string;
  }
  export class ParseOutput {
    tree(): cst.Node;
    errors(): Array<parser.ParseError>;
    get isValid(): boolean;
    /** Creates a cursor that starts at the root of the parse tree. */
    createTreeCursor(): cst.Cursor;
  }
}
export declare namespace diagnostic {
  /**
   * Severity of the compiler diagnostic.
   *
   * Explicitly compatible with the LSP protocol.
   */
  export enum Severity {
    Error = 1,
    Warning = 2,
    Information = 3,
    Hint = 4,
  }
  /** A compiler diagnostic that can be rendered to a user. */
  export class Diagnostic {
    /** The severity of this diagnostic. */
    severity(): Severity;
    /** The character range of the source that this diagnostic applies to. */
    textRange(): cst.TextRange;
    /** The primary message associated with this diagnostic. */
    message(): string;
  }
}
export declare namespace ast_internal {
  export function selectSequence(node: cst.NonterminalNode): Array<cst.Node | null>;
  export function selectChoice(node: cst.NonterminalNode): cst.Node;
  export function selectRepeated(node: cst.NonterminalNode): Array<cst.Node>;
  export function selectSeparated(node: cst.NonterminalNode): [Array<cst.Node>, Array<cst.Node>];
}

export namespace cst {
  export type Node = TerminalNode | NonterminalNode;
}
