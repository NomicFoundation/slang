// This file is generated automatically by infrastructure scripts. Please don't edit by hand.

package nomic-foundation:slang@0.16.0;

world slang {
    export cst;
    export cursor;
    export diagnostic;
    export kinds;
    export language;
    export parse-error;
    export parse-output;
    export query;
    export text-index;
}

interface cst {
    use kinds.{nonterminal-kind, terminal-kind};
    use text-index.{text-index};

    variant node {
        nonterminal(nonterminal-node),
        terminal(terminal-node)
    }

    resource nonterminal-node {
        kind: func() -> nonterminal-kind;
        text-len: func() -> text-index;
        children: func() -> list<node>;
        // TODO: re-enable once we solve circular references:
        // create-cursor: func(text-offset: text-index) -> cursor;
        unparse: func() -> string;
    }

    resource terminal-node {
        kind: func() -> terminal-kind;
        text-len: func() -> text-index;
        text: func() -> string;
    }
}

interface cursor {
    use cst.{node, nonterminal-node};
    use kinds.{edge-label, nonterminal-kind, terminal-kind};
    use text-index.{text-index, text-range};

    resource cursor {
        reset: func();
        complete: func();
        is-completed: func() -> bool;

        clone: func() -> cursor;
        spawn: func() -> cursor;

        node: func() -> node;
        label: func() -> option<edge-label>;

        text-offset: func() -> text-index;
        text-range: func() -> text-range;

        depth: func() -> u32;

        ancestors: func() -> list<nonterminal-node>;

        go-to-next: func() -> bool;
        go-to-next-non-descendent: func() -> bool;
        go-to-previous: func() -> bool;

        go-to-parent: func() -> bool;

        go-to-first-child: func() -> bool;
        go-to-last-child: func() -> bool;
        go-to-nth-child: func(child-number: u32) -> bool;

        go-to-next-sibling: func() -> bool;
        go-to-previous-sibling: func() -> bool;

        go-to-next-terminal: func() -> bool;
        go-to-next-terminal-with-kind: func(kind: terminal-kind) -> bool;
        go-to-next-terminal-with-kinds: func(kinds: list<terminal-kind>) -> bool;

        go-to-next-nonterminal: func() -> bool;
        go-to-next-nonterminal-with-kind: func(kind: nonterminal-kind) -> bool;
        go-to-next-nonterminal-with-kinds: func(kinds: list<nonterminal-kind>) -> bool;

        // TODO: re-enable once we solve circular references:
        // query: func(queries: list<borrow<query>>) -> query-match-iterator;
    }
}

interface kinds {
    enum nonterminal-kind {
                %addition-expression,
                %expression,
                %literal,
                %member-access-expression,
                %negation-expression,
                %separated-identifiers,
                %source-unit,
                %source-unit-member,
                %source-unit-members,
                %tree,
                %tree-node,
                %tree-node-child,
                %tree-node-children,
    }

    enum edge-label {
        // Built-in:
            %item,
            %variant,
            %separator,
            %operand,
            %left-operand,
            %right-operand,
            %leading-trivia,
            %trailing-trivia,

        // Generated:
                %close-bracket,
                %keyword,
                %member,
                %members,
                %name,
                %node,
                %open-bracket,
                %operator,
                %period,
                %semicolon,
    }

    enum terminal-kind {
        // Built-in:
        skipped,

        // Generated:
                %bang,
                %close-bracket,
                %delimited-identifier,
                %end-of-line,
                %identifier,
                %multi-line-comment,
                %open-bracket,
                %period,
                %plus,
                %semicolon,
                %single-line-comment,
                %string-literal,
                %tree-keyword,
                %whitespace,
    }
}

interface language {
    use kinds.{nonterminal-kind};
    use parse-output.{parse-output};

    resource language {
        supported-versions: static func() -> list<string>;
        new: static func(version: string) -> result<language, string>;
        version: func() -> string;
        parse: func(kind: nonterminal-kind, input: string) -> parse-output;
    }
}

interface parse-error {
    use diagnostic.{severity};
    use text-index.{text-range};

    resource parse-error {
        severity: func() -> severity;
        text-range: func() -> text-range;
        message: func() -> string;
    }
}

interface parse-output {
    use cst.{node};
    use cursor.{cursor};
    use parse-error.{parse-error};

    resource parse-output {
        tree: func() -> node;
        errors: func() -> list<parse-error>;
        is-valid: func() -> bool;
        create-tree-cursor: func() -> cursor;
    }
}

interface query {
    use cursor.{cursor};

    resource query {
        parse: static func(text: string) -> result<query, query-error>;
    }

    record query-error {
        message: string,
        row: u32,
        column: u32,
    }

    record query-match {
        query-number: u32,
        captures: list<tuple<string, list<cursor>>>,
    }

    resource query-match-iterator {
        next: func() -> option<query-match>;
    }
}

interface diagnostic {
    enum severity {
        error,
        warning,
        information,
        hint,
    }
}

interface text-index {
    record text-index {
        utf8: u32,
        utf16: u32,
        line: u32,
        column: u32,
    }

    record text-range {
        start: text-index,
        end: text-index,
    }
}
