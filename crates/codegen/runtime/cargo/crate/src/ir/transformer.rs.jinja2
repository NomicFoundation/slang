{%- if rendering_in_stubs -%}
  // No Intermediate Representation transformer functions in stubs...
{%- elif not source -%}
  // Not rendering transformer for first Intermediate Language
{%- else -%}
  // Transformer from previous language implementation `{{ source.name }}`
  #![allow(clippy::too_many_lines)]

  use std::rc::Rc;
  use super::{input, nodes as output};

  pub trait Transformer {
    //
    // Sequences:
    //
    {% for parent_type, sequence in target.sequences %}
      fn mutate_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
        {% for field in sequence.fields %}
          {%- if field.is_optional -%}
            let {{ field.label }} = source.{{ field.label }}.as_ref().map(
              {%- if field.is_terminal -%}
                Rc::clone
              {%- else -%}
                |value| self.mutate_{{ field.type | snake_case }}(value)
              {%- endif -%}
            );
          {%- elif not field.is_terminal or not target.unique_terminals is containing(field.type) -%}
            let {{ field.label }} =
            {%- if field.is_terminal -%}
              Rc::clone(&source.{{ field.label }})
            {%- else -%}
              self.mutate_{{ field.type | snake_case }}(&source.{{ field.label }})
            {%- endif -%}
            ;
          {%- endif -%}
        {%- endfor %}

        Rc::new(output::{{ parent_type }}Struct {
          node_id: source.node_id,
          {%- for field in sequence.fields -%}
            {%- if field.is_optional
                   or not field.is_terminal
                   or not target.unique_terminals is containing(field.type) -%}
              {{ field.label }},
            {%- endif -%}
          {%- endfor %}
        })
      }
    {% endfor %}

    //
    // Choices:
    //
    {% for parent_type, choice in target.choices %}
      fn default_mutate_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
        match source {
          {% for nonterminal in choice.nonterminal_types -%}
            input::{{ parent_type }}::{{ nonterminal }}(ref {{ nonterminal | snake_case }}) => {
              output::{{ parent_type }}::{{ nonterminal }}(self.mutate_{{ nonterminal | snake_case }}({{ nonterminal | snake_case }}))
            }
          {%- endfor %}
          {%- for terminal in choice.terminal_types -%}
            {%- if target.unique_terminals is containing(terminal) -%}
              input::{{ parent_type }}::{{ terminal }} => output::{{ parent_type }}::{{ terminal }},
            {%- else -%}
              input::{{ parent_type }}::{{ terminal }}(node) => output::{{ parent_type }}::{{ terminal }}(Rc::clone(node)),
            {%- endif -%}
          {%- endfor -%}
        }
      }
      fn mutate_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
        self.default_mutate_{{ parent_type | snake_case }}(source)
      }
    {% endfor %}

    //
    // Repeated:
    //
    {% for parent_type, repeated in target.repeated %}
      fn mutate_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
        source.iter().map(
          {%- if repeated.is_terminal -%}
            Rc::clone
          {%- else -%}
            |item| self.mutate_{{ repeated.item_type | snake_case }}(item)
          {%- endif -%}
        ).collect()
      }
    {% endfor %}

    //
    // Separated:
    //
    {% for parent_type, separated in target.separated %}
      fn mutate_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
        source.iter().map(
          {%- if separated.is_terminal -%}
            Rc::clone
          {%- else -%}
            |item| self.mutate_{{ separated.item_type | snake_case }}(item)
          {%- endif -%}
        ).collect()
      }
    {% endfor %}
  }
{%- endif -%}
