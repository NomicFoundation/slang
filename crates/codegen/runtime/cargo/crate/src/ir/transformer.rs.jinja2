{%- if rendering_in_stubs -%}
  // No Intermediate Representation transformer functions in stubs...
{%- elif not source -%}
  // Not rendering transformer for first Intermediate Language
{%- else -%}
  // Transformer from previous language implementation `{{ source.name }}`
  #![allow(clippy::too_many_lines)]

  use std::rc::Rc;
  use super::{input, nodes as output};

  pub trait Transformer {
    //
    // Sequences:
    //
    {% for parent_type, source_sequence in source.sequences %}
      {% if target.sequences is containing(parent_type) %}
        {% set sequence = target.sequences[parent_type] %}
        fn transform_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }}
        {% if sequence.can_build_from_source %}
          {
            {% for field in sequence.fields %}
              {%- if field.is_optional -%}
                let {{ field.label }} = source.{{ field.label }}.as_ref().map(
                  {%- if field.is_terminal -%}
                    Rc::clone
                  {%- else -%}
                    |value| self.transform_{{ field.type | snake_case }}(value)
                  {%- endif -%}
                );
              {%- elif not field.is_terminal or not target.unique_terminals is containing(field.type) -%}
                let {{ field.label }} =
                {%- if field.is_terminal -%}
                  Rc::clone(&source.{{ field.label }})
                {%- else -%}
                  self.transform_{{ field.type | snake_case }}(&source.{{ field.label }})
                {%- endif -%}
                ;
              {%- endif -%}
            {%- endfor %}

            Rc::new(output::{{ parent_type }}Struct {
              node_id: source.node_id,
              {%- for field in sequence.fields -%}
                {%- if field.is_optional
                       or not field.is_terminal
                       or not target.unique_terminals is containing(field.type) -%}
                  {{ field.label }},
                {%- endif -%}
              {%- endfor %}
            })
          }
        {% else %}
          ;
        {% endif %}
      {% endif %}
    {% endfor %}

    //
    // Choices:
    //
    {% for parent_type, source_choice in source.choices %}
      {% if target.choices is containing(parent_type) %}
        {% set choice = target.choices[parent_type] %}
        fn default_transform_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
          #[allow(clippy::match_wildcard_for_single_variants)]
          match source {
            {% for nonterminal in choice.nonterminal_types -%}
              input::{{ parent_type }}::{{ nonterminal }}(ref {{ nonterminal | snake_case }}) => {
                output::{{ parent_type }}::{{ nonterminal }}(self.transform_{{ nonterminal | snake_case }}({{ nonterminal | snake_case }}))
              }
            {%- endfor %}
            {%- for terminal in choice.terminal_types -%}
              {%- if target.unique_terminals is containing(terminal) -%}
                input::{{ parent_type }}::{{ terminal }} => output::{{ parent_type }}::{{ terminal }},
              {%- else -%}
                input::{{ parent_type }}::{{ terminal }}(node) => output::{{ parent_type }}::{{ terminal }}(Rc::clone(node)),
              {%- endif -%}
            {%- endfor -%}
            {% if choice.has_removed_variants %}
              _ => panic!("Unexpected variant {source:?}"),
            {% endif %}
          }
        }
        fn transform_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
          self.default_transform_{{ parent_type | snake_case }}(source)
        }
      {% endif %}
    {% endfor %}

    //
    // Repeated:
    //
    {% for parent_type, source_repeated in source.repeated %}
      {% if target.repeated is containing(parent_type) %}
        {% set repeated = target.repeated[parent_type] %}
        fn transform_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
          source.iter().map(
            {%- if repeated.is_terminal -%}
              Rc::clone
            {%- else -%}
              |item| self.transform_{{ repeated.item_type | snake_case }}(item)
            {%- endif -%}
          ).collect()
        }
      {% endif %}
    {% endfor %}

    //
    // Separated:
    //
    {% for parent_type, source_separated in source.separated %}
      {% if target.separated is containing(parent_type) %}
        {% set separated = target.separated[parent_type] %}
        fn transform_{{ parent_type | snake_case }}(&mut self, source: &input::{{ parent_type }}) -> output::{{ parent_type }} {
          source.iter().map(
            {%- if separated.is_terminal -%}
              Rc::clone
            {%- else -%}
              |item| self.transform_{{ separated.item_type | snake_case }}(item)
            {%- endif -%}
          ).collect()
        }
      {% endif %}
    {% endfor %}
  }
{%- endif -%}
