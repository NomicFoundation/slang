interface bindings {
    use cst.{cursor};

    /// A graph that contains name binding information for all source files within the compilation unit.
    /// It stores cursors to all definitions and references, and can resolve the edges between them.
    ///
    /// Most cursors pointing to identifier terminals will resolve to either a definition or a reference.
    /// For example, in `contract A is B {}`, the cursor to identifier `A` will resolve to a definition,
    /// and the cursor to identifier `B` will resolve to a reference.
    ///
    /// However, in some cases, cursors to identifiers can resolve to both at the same time.
    /// For example, in `import {X} from "library"`, the cursor to identifier `X` will resolve to a
    /// definition (the local import), and also to a reference (to the symbol exported from `"library"`).
    ///
    /// This graph is error-tolerant, and will return `undefined` for any identifiers that cannot be resolved.
    /// For example, when there are syntactic/semantic errors, or missing source files.
    ///
    /// For more information on identifier terminals, see the `TerminalKindExtensions.isIdentifier()` API.
    resource binding-graph {
        /// Tries to resolve the identifier terminal pointed at by the provided cursor to a definition.
        /// If successful, returns the definition. Otherwise, returns `undefined`.
        ///
        /// For more information on identifier terminals, see the `TerminalKindExtensions.isIdentifier()` API.
        definition-at: func(cursor: borrow<cursor>) -> option<definition>;

        /// Tries to resolve the identifier terminal pointed at by the provided cursor to a reference.
        /// If successful, returns the reference. Otherwise, returns `undefined`.
        ///
        /// For more information on identifier terminals, see the `TerminalKindExtensions.isIdentifier()` API.
        reference-at: func(cursor: borrow<cursor>) -> option<reference>;
    }

    /// A `Definition` represents the location where a symbol is originally defined. From this you
    /// can find more information about the location of this definition in the parse tree, or navigate to
    /// references to this defintion.
    resource definition {
        /// Returns a unique numerical identifier of the definition.
        /// It is only valid for the lifetime of the binding graph.
        /// It can change between multiple graphs, even for the same source code input.
        id: func() -> u32;

        /// Returns the location of the definition's name.
        /// For `contract X {}`, that is the location of the `X` `Identifier` node.
        name-location: func() -> binding-location;

        /// Returns the location of the definition's definiens.
        /// For `contract X {}`, that is the location of the parent `ContractDefinition` node.
        definiens-location: func() -> binding-location;

        /// Returns a list of all references that bind to this definition.
        references: func() -> list<reference>;
    }

    /// A `Reference` represents a location where a symbol definition is referenced, i.e. anywhere
    /// a symbol is 'used' in a piece of code. From this you can find more information about the location
    /// of the reference in the parse tree, or you can navigate to the `Definition` this
    /// references.
    ///
    /// Note that most references have a single definition, but some have multiple, such as when a symbol
    /// is imported from another file, and renamed (re-defined) in the current file.
    resource reference {
        /// Returns a unique numerical identifier of the reference.
        /// It is only valid for the lifetime of the binding graph.
        /// It can change between multiple graphs, even for the same source code input.
        id: func() -> u32;

        /// Returns the location of the reference.
        /// For `new X()`, that is the location of the `X` `Identifier` node.
        location: func() -> binding-location;

        /// Returns a list of all definitions related to this reference.
        /// Most references have a single definition, but some have multiple, such as when a symbol
        /// is imported from another file, and renamed (re-defined) in the current file.
        definitions: func() -> list<definition>;
    }

    /// A `BindingLocation` is used to point the user to a definition or reference in the parse tree.
    /// A `BindingLocation` can either be a `UserFile` or a `BuiltIn`. Only `UserFile`'s give the user 
    /// a `Cursor` into a location in the parse tree.
    variant binding-location {
        /// Represents a location of a user-defined symbol in a user file.
        user-file(user-file-location),
        /// Represents a location of a built-in symbol in the language.
        built-in(built-in-location)
    }

    /// `UserFileLocation` provides a `Cursor` pointing to a `Node` in the
    /// parse tree where the referenced `Definition` or `Reference` is located.
    resource user-file-location {
        /// Returns the ID of the file that contains the symbol.
        file-id: func() -> string;
        
        /// Returns a cursor to the CST node that contains the symbol.
        cursor: func() -> cursor;
    }

    /// Represents a location of a built-in symbol in the language.
    resource built-in-location {
    }
}
