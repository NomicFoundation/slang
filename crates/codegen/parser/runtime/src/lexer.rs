use crate::{
    cst,
    kinds::{LexicalContext, TokenKind},
    support::{ParserContext, ParserResult},
};

// Ensure that the `LexicalContext` enum is `repr(u8)`.
// Workaround until repr(u8) enums can be used as const params.
const _ASSERT_CONTEXT_IS_REPR_U8: fn() = || {
    let _ = core::mem::transmute::<u8, LexicalContext>;
};

pub trait Lexer {
    #[doc(hidden)]
    // Morphs a token into a contextual keyword if possible.
    fn as_contextual_keyword(&self, value: &str, kind: TokenKind) -> Option<TokenKind>;
    // Generated by the templating engine
    #[doc(hidden)]
    fn next_token<const LEX_CTX: u8>(&self, input: &mut ParserContext) -> Option<TokenKind>;
    // NOTE: These are context-insensitive
    #[doc(hidden)]
    fn leading_trivia(&self, input: &mut ParserContext) -> ParserResult;
    #[doc(hidden)]
    fn trailing_trivia(&self, input: &mut ParserContext) -> ParserResult;

    fn parse_token<const LEX_CTX: u8>(
        &self,
        input: &mut ParserContext,
        expected: TokenKind,
    ) -> ParserResult {
        let start = input.position();
        let (next_token, value) = (
            self.next_token::<LEX_CTX>(input),
            input.content(start.utf8..input.position().utf8),
        );

        let Some(kind) = next_token.and_then(|next| {
            if next == expected {
                Some(next)
            } else {
                // Expected token may be a contextual keyword, e.g. `emit`.
                // Morph into one if possible and see if it's the expected token.
                self.as_contextual_keyword(&value, next)
                    .filter(|&kw| kw == expected)
            }
        }) else {
            input.set_position(start);
            return ParserResult::no_match(vec![expected]);
        };

        let end = input.position();

        ParserResult::r#match(
            vec![cst::Node::token(kind, input.content(start.utf8..end.utf8))],
            vec![],
        )
    }

    fn parse_token_with_trivia<const LEX_CTX: u8>(
        &self,
        input: &mut ParserContext,
        kind: TokenKind,
    ) -> ParserResult {
        let mut children = vec![];

        let restore = input.position();
        if let ParserResult::Match(r#match) = self.leading_trivia(input) {
            children.extend(r#match.nodes);
        } else {
            input.set_position(restore);
        }

        if let ParserResult::Match(r#match) = self.parse_token::<LEX_CTX>(input, kind) {
            children.extend(r#match.nodes);
        } else {
            input.set_position(restore);
            return ParserResult::no_match(vec![kind]);
        }

        let restore = input.position();
        if let ParserResult::Match(r#match) = self.trailing_trivia(input) {
            children.extend(r#match.nodes);
        } else {
            input.set_position(restore);
        }

        ParserResult::r#match(children, vec![])
    }
}
