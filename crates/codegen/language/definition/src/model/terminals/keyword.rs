use crate::model::{Identifier, Spanned, VersionSpecifier};
use codegen_language_internal_macros::{ParseInputTokens, WriteOutputTokens};
use itertools::Itertools;
use serde::Serialize;

#[derive(Debug, Eq, ParseInputTokens, PartialEq, Serialize, WriteOutputTokens)]
pub struct KeywordItem {
    pub name: Spanned<Identifier>,
    pub identifier: Spanned<Identifier>,

    pub definitions: Vec<KeywordDefinition>,
}

#[derive(Debug, Eq, ParseInputTokens, PartialEq, Serialize, WriteOutputTokens)]
pub struct KeywordDefinition {
    pub enabled: Option<Spanned<VersionSpecifier>>,
    pub reserved: Option<Spanned<VersionSpecifier>>,

    pub value: KeywordValue,
}

#[derive(Debug, Eq, ParseInputTokens, PartialEq, Serialize, WriteOutputTokens)]
pub enum KeywordValue {
    Sequence { values: Vec<KeywordValue> },
    Optional { value: Box<KeywordValue> },
    Choice { values: Vec<KeywordValue> },
    Atom { atom: Spanned<String> },
}

impl KeywordValue {
    /// Collects all possible variations generated by this value.
    pub fn collect_variations(&self) -> Vec<String> {
        match self {
            KeywordValue::Atom { atom } => {
                return vec![atom.to_string()];
            }
            KeywordValue::Optional { value } => {
                let mut results = value.collect_variations();
                results.insert(0, String::new());
                return results;
            }
            KeywordValue::Choice { values } => {
                return values
                    .iter()
                    .flat_map(|value| value.collect_variations())
                    .collect_vec();
            }
            KeywordValue::Sequence { values } => {
                let matrix = values
                    .iter()
                    .map(|value| value.collect_variations())
                    .collect_vec();

                let results_len = matrix.iter().map(|values| values.len()).product();
                let mut results = (0..results_len).map(|_| String::new()).collect_vec();

                let mut span = results_len;

                for variations in matrix {
                    span /= variations.len();

                    for j in 0..results_len {
                        results[j].push_str(&variations[j / span % variations.len()]);
                    }
                }

                return results;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::model::{KeywordValue, Spanned};

    #[test]
    fn test_atom() {
        let value = KeywordValue::Atom {
            atom: Spanned::without_span("foo".to_string()),
        };

        assert_eq!(value.collect_variations(), vec!["foo"]);
    }

    #[test]
    fn test_optional() {
        let value = KeywordValue::Optional {
            value: KeywordValue::Atom {
                atom: Spanned::without_span("foo".to_string()),
            }
            .into(),
        };

        assert_eq!(value.collect_variations(), vec!["", "foo"]);
    }

    #[test]
    fn test_choice() {
        let value = KeywordValue::Choice {
            values: vec![
                KeywordValue::Atom {
                    atom: Spanned::without_span("foo".into()),
                },
                KeywordValue::Atom {
                    atom: Spanned::without_span("bar".into()),
                },
            ],
        };

        assert_eq!(value.collect_variations(), vec!["foo", "bar"]);
    }

    #[test]
    fn test_sequence() {
        let value = KeywordValue::Sequence {
            values: vec![
                KeywordValue::Atom {
                    atom: Spanned::without_span("foo".into()),
                },
                KeywordValue::Atom {
                    atom: Spanned::without_span("bar".into()),
                },
            ],
        };

        assert_eq!(value.collect_variations(), vec!["foobar"]);
    }

    #[test]
    fn test_all() {
        let value = KeywordValue::Sequence {
            values: vec![
                KeywordValue::Atom {
                    atom: Spanned::without_span("foo".into()),
                },
                KeywordValue::Optional {
                    value: KeywordValue::Sequence {
                        values: vec![
                            KeywordValue::Atom {
                                atom: Spanned::without_span("_".into()),
                            },
                            KeywordValue::Choice {
                                values: vec![
                                    KeywordValue::Atom {
                                        atom: Spanned::without_span("1".into()),
                                    },
                                    KeywordValue::Atom {
                                        atom: Spanned::without_span("2".into()),
                                    },
                                    KeywordValue::Atom {
                                        atom: Spanned::without_span("3".into()),
                                    },
                                    KeywordValue::Atom {
                                        atom: Spanned::without_span("4".into()),
                                    },
                                    KeywordValue::Atom {
                                        atom: Spanned::without_span("5".into()),
                                    },
                                ],
                            },
                        ],
                    }
                    .into(),
                },
            ],
        };

        assert_eq!(
            value.collect_variations(),
            vec!["foo", "foo_1", "foo_2", "foo_3", "foo_4", "foo_5",]
        );
    }
}
