use crate::model::KeywordValue;
use itertools::Itertools;

impl KeywordValue {
    /// Collects all possible variations generated by this value.
    pub fn collect_variations(&self) -> Vec<String> {
        match self {
            KeywordValue::Atom { atom } => {
                return vec![atom.to_owned()];
            }
            KeywordValue::Optional { value } => {
                let mut results = value.collect_variations();
                results.insert(0, String::new());
                return results;
            }
            KeywordValue::Choice { values } => {
                return values
                    .iter()
                    .flat_map(|value| value.collect_variations())
                    .collect_vec();
            }
            KeywordValue::Sequence { values } => {
                let matrix = values
                    .iter()
                    .map(|value| value.collect_variations())
                    .collect_vec();

                let results_len = matrix.iter().map(|values| values.len()).product();
                let mut results = (0..results_len).map(|_| String::new()).collect_vec();

                let mut span = results_len;

                for variations in matrix {
                    span /= variations.len();

                    for j in 0..results_len {
                        results[j].push_str(&variations[j / span % variations.len()]);
                    }
                }

                return results;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_atom() {
        let value = KeywordValue::Atom { atom: "foo".into() };

        assert_eq!(value.collect_variations(), vec!["foo"]);
    }

    #[test]
    fn test_optional() {
        let value = KeywordValue::Optional {
            value: KeywordValue::Atom { atom: "foo".into() }.into(),
        };

        assert_eq!(value.collect_variations(), vec!["", "foo"]);
    }

    #[test]
    fn test_choice() {
        let value = KeywordValue::Choice {
            values: vec![
                KeywordValue::Atom { atom: "foo".into() },
                KeywordValue::Atom { atom: "bar".into() },
            ],
        };

        assert_eq!(value.collect_variations(), vec!["foo", "bar"]);
    }

    #[test]
    fn test_sequence() {
        let value = KeywordValue::Sequence {
            values: vec![
                KeywordValue::Atom { atom: "foo".into() },
                KeywordValue::Atom { atom: "bar".into() },
            ],
        };

        assert_eq!(value.collect_variations(), vec!["foobar"]);
    }

    #[test]
    fn test_all() {
        let value = KeywordValue::Sequence {
            values: vec![
                KeywordValue::Atom { atom: "foo".into() },
                KeywordValue::Optional {
                    value: KeywordValue::Sequence {
                        values: vec![
                            KeywordValue::Atom { atom: "_".into() },
                            KeywordValue::Choice {
                                values: vec![
                                    KeywordValue::Atom { atom: "1".into() },
                                    KeywordValue::Atom { atom: "2".into() },
                                    KeywordValue::Atom { atom: "3".into() },
                                    KeywordValue::Atom { atom: "4".into() },
                                    KeywordValue::Atom { atom: "5".into() },
                                ],
                            },
                        ],
                    }
                    .into(),
                },
            ],
        };

        assert_eq!(
            value.collect_variations(),
            vec!["foo", "foo_1", "foo_2", "foo_3", "foo_4", "foo_5",]
        );
    }
}
