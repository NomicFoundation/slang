{%- set target = model.ir_model -%}

#![allow(clippy::too_many_lines)]

#[allow(clippy::wildcard_imports)]
use slang_solidity_v2_cst::structured_cst::nodes::*;
use slang_solidity::cst::{NonterminalKind, NodeKind, Node, EdgeLabel, Edge, TextRange, TextIndex};
use slang_solidity::diagnostic::{Diagnostic, Severity};
use std::marker::PhantomData;

/// An error found when checking a node
#[derive(Clone, Debug)]
pub struct NodeCheckerError {
    pub err: String,
    pub text_range: TextRange,

}

impl Diagnostic for NodeCheckerError {
    fn text_range(&self) -> TextRange {
        self.text_range.clone()
    }

    fn severity(&self) -> Severity {
        Severity::Error
    }

    fn message(&self) -> String {
        self.err.clone()
    }
}

impl NodeCheckerError {
    pub(crate) fn new(err: String, text_range: TextRange) -> NodeCheckerError {
        NodeCheckerError { err, text_range }
    }
}

/// A trait that checks whether a CST node (V1) matches the structure of the AST node (V2).
pub trait NodeChecker {
    /// Check whether self matches the given CST node, tracking text offset.
    ///
    /// Returns a vector of errors found, empty if no errors.
    ///
    /// Note: The text offset calculating and tracking seems to reinvent a lot of the logic behind the Cursor,
    /// but it's simple enough that we can do it here. Using a cursor makes it more difficult to compare both
    /// trees, since we'd need to keep track of which children we've seen.
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError>;

    /// Check whether self matches the given CST node.
    ///
    /// Returns a vector of errors found, empty if no errors.
    fn check_node(&self, node: &Node) -> Vec<NodeCheckerError> {
        self.check_node_with_offset(node, TextIndex::ZERO)
    }
}

/// Extract the first element that satisfies the predicate, and remove it from the vector.
fn extract_first<T>(v: &mut Vec<T>, finder: impl Fn(&T) -> bool) -> Option<T> {
    if let Some(idx) = v.iter().position(finder) {
        return Some(v.remove(idx));
    }
    None
}

/// Extract the first edge with the given label, and remove it from the vector.
fn extract_first_with_label(v: &mut Vec<(Edge, TextIndex)>, label: EdgeLabel) -> Option<(Edge, TextIndex)> {
    extract_first(v, |(child, _): &(Edge, TextIndex)| child.label == label)
}

/// Compute children with their text offsets, filtering out trivia and separators.
///
/// This computes offsets BEFORE filtering so that offsets remain accurate.
///
/// TODO: At some point we may need to check the trivia as well
fn children_with_offsets(node: &Node, text_offset: TextIndex) -> Vec<(Edge, TextIndex)> {
    let mut result = vec![];
    let mut current_offset = text_offset;

    for child in node.children() {
        let child_offset = current_offset;
        current_offset += child.node.text_len();

        // Skip trivia and separators (V2 doesn't parse them)
        if child.node.is_trivia() || child.label == EdgeLabel::Separator {
            continue;
        }

        result.push((child.clone(), child_offset));
    }

    result
}

//
// Sequences:
//


{% for parent_type, sequence in target.sequences %}
{% if parent_type == "PragmaDirective" %}
// TODO(v2): PragmaDirective ignores the pragma value for now until the Lexer can
// perform a context switch, therefore the checker ignores that edge
impl<'arena> NodeChecker for PragmaDirective<'arena> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::PragmaDirective) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::PragmaDirective,
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);

        let mut errors = vec![];

        // pragma_keyword

        {
            let pragma_keyword = &self.pragma_keyword;

            // Prepare edge label

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::PragmaKeyword) {
                let child_errors = pragma_keyword.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected pragma_keyword to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // pragma

        {
            // Prepare edge label

            if let Some(_) = extract_first_with_label(&mut children, EdgeLabel::Pragma) {
                // We don't check, since V2 can't parse these yet
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected pragma to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // semicolon

        {
            let semicolon = &self.semicolon;

            // Prepare edge label

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Semicolon) {
                let child_errors = semicolon.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected semicolon to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(format!(
                "Expected 0 children left, but there's some left {:#?}",
                children
            ), node_range));
        }

        errors
    }
}

{% elif parent_type == "YulBlock" %}
// TODO(v2): YulBlock ignores the statements for now until the Lexer can
// perform a context switch, therefore the checker ignores that edge
impl<'arena> NodeChecker for YulBlock<'arena> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::YulBlock) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::YulBlock,
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);

        let mut errors = vec![];

        // open_brace

        {
            let open_brace = &self.open_brace;

            // Prepare edge label

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::OpenBrace) {
                let child_errors = open_brace.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected open_brace to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // statements

        {
            // Prepare edge label

            if let Some(_) = extract_first_with_label(&mut children, EdgeLabel::Statements) {
                // We don't check statements, since V2 can't parse them yet
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected statements to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // close_brace

        {
            let close_brace = &self.close_brace;

            // Prepare edge label

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::CloseBrace) {
                let child_errors = close_brace.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected close_brace to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(format!(
                "Expected 0 children left, but there's some left {:#?}",
                children
            ), node_range));
        }

        errors
    }
}

{% elif parent_type == "IdentifierPath" %}

/// NodeChecker for IdentifierPath is done by hand, since the V2 representation is a bit different
impl<'arena> NodeChecker for IdentifierPath<'arena> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::IdentifierPath) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::IdentifierPath,
                node.kind()
            ), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        let tail_len = self.tail.as_ref().map_or(0, |tail| tail.elements.elements.len());

        if children.len() != 1 + tail_len {
            return vec![NodeCheckerError::new(format!(
                "Expected {} elements, but got: {:#?}",
                1 + tail_len,
                children
            ), node_range)];
        }


        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {

            if i == 0 {
                // head
                let head = &self.head;
                let child_errors = head.check_node_with_offset(&child.node, *child_offset);
                errors.extend(child_errors);
                continue;
            }
            // tail elements

            let element = &self.tail.as_ref().unwrap().elements.elements[i - 1];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}

{% elif parent_type == "IdentifierPathTail" %}
// We skip NodeChecker for IdentifierPathTail, it's handled by IdentifierPath

{% elif parent_type == "CallOptionsNew" %}
// We skip NodeChecker for CallOptionsNew, it's handled by NewExpression

{% elif parent_type == "NewExpression" %}

/// Helper to check a V2 CallOptionsNew against a V1 CallOptionsExpression
///
/// It extracts the braces and the options from v1_children, leaving the operand to the outer scope
fn check_call_options_new(
    v2_options: &CallOptionsNew<'_>,
    v1_node: &Node,
    v1_children: &mut Vec<(Edge, TextIndex)>,
    v1_offset: TextIndex,
) -> Vec<NodeCheckerError> {
    let node_range = v1_offset..(v1_offset + v1_node.text_len());
    let mut errors = vec![];

    // V1 CallOptionsExpression has: open_brace, options (CallOptions), close_brace
    // V2 CallOptionsNew has the same structure

    // open_brace
    {
        let open_brace = &v2_options.open_brace;
        if let Some((child, child_offset)) = extract_first_with_label(v1_children, EdgeLabel::OpenBrace) {
            errors.extend(open_brace.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected open_brace to be present in CallOptionsExpression".to_string(),
                node_range.clone(),
            ));
        }
    }

    // options (CallOptions)
    {
        let options = &v2_options.options;
        if let Some((child, child_offset)) = extract_first_with_label(v1_children, EdgeLabel::Options) {
            errors.extend(options.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected options to be present in CallOptionsExpression".to_string(),
                node_range.clone(),
            ));
        }
    }

    // close_brace
    {
        let close_brace = &v2_options.close_brace;
        if let Some((child, child_offset)) = extract_first_with_label(v1_children, EdgeLabel::CloseBrace) {
            errors.extend(close_brace.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected close_brace to be present in CallOptionsExpression".to_string(),
                node_range.clone(),
            ));
        }
    }

    errors
}

/// Helper to unwrap an Expression node and get its inner variant node
fn unwrap_expression(node: &Node, offset: TextIndex) -> Result<(Node, TextIndex), NodeCheckerError> {
    let node_range = offset..(offset + node.text_len());

    if node.kind() != NodeKind::Nonterminal(NonterminalKind::Expression) {
        return Err(NodeCheckerError::new(
            format!("Expected Expression, but got {}", node.kind()),
            node_range,
        ));
    }

    let children = children_with_offsets(node, offset);
    if children.len() != 1 {
        return Err(NodeCheckerError::new(
            format!("Expected exactly one child for Expression, but got: {children:#?}"),
            node_range,
        ));
    }

    let (child, child_offset) = &children[0];
    if child.label != EdgeLabel::Variant {
        let child_range = *child_offset..(*child_offset + child.node.text_len());
        return Err(NodeCheckerError::new(
            format!("Expected child to be of variant type, but it was {}", child.label),
            child_range,
        ));
    }

    Ok((child.node.clone(), *child_offset))
}

/// NodeChecker for NewExpression is done by hand, since in V2 it includes the call options and arguments
///
/// In V1: FunctionCallExpression -> (CallOptionsExpression)* -> NewExpression
/// In V2: NewExpression contains new_keyword, type_name, options (MultipleCallOptionsNew), arguments
impl<'arena> NodeChecker for NewExpression<'arena> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        // What we parse as a NewExpression in V2 is parsed as a FunctionCallExpression in V1,
        // with optional CallOptionsExpression nodes in between, and a V1 NewExpression at the core
        if node.kind() != NodeKind::Nonterminal(NonterminalKind::FunctionCallExpression) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::FunctionCallExpression,
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // Extract operand from FunctionCallExpression
        let (operand_node, operand_offset) = if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Operand) {
            (child.node, child_offset)
        } else {
            errors.push(NodeCheckerError::new(
                "Expected operand to be present in FunctionCallExpression".to_string(),
                node_range,
            ));
            return errors;
        };

        // Unwrap the Expression to get the variant
        let (mut current_node, mut current_offset) = match unwrap_expression(&operand_node, operand_offset) {
            Ok(result) => result,
            Err(e) => {
                errors.push(e);
                return errors;
            }
        };

        // Traverse through CallOptionsExpression nodes to find the NewExpression,
        // checking each one against V2's options as we go.
        //
        // V1 traversal order: outermost first (closest to the function call)
        // V2 storage order: source order (innermost first, closest to `new`)
        // So we iterate V2's options in reverse to match V1's traversal order.
        let mut v2_options_iter = self.options.as_ref()
            .map(|opts| opts.elements.iter().rev().peekable());
        let mut v1_call_options_count = 0usize;

        while current_node.kind() == NodeKind::Nonterminal(NonterminalKind::CallOptionsExpression) {
            v1_call_options_count += 1;
            let call_opts_range = current_offset..(current_offset + current_node.text_len());

            // Get the operand of this CallOptionsExpression
            let mut call_opts_children = children_with_offsets(&current_node, current_offset);

            // Check this V1 CallOptionsExpression against the corresponding V2 CallOptionsNew
            if let Some(ref mut iter) = v2_options_iter {
                if let Some(v2_opt) = iter.next() {
                    errors.extend(check_call_options_new(v2_opt, &current_node, &mut call_opts_children, current_offset));
                } else {
                    // V1 has more options than V2
                    errors.push(NodeCheckerError::new(
                        "Found CallOptionsExpression in V1, but no corresponding option in V2".to_string(),
                        call_opts_range.clone(),
                    ));
                }
            } else {
                // V2 has no options at all, but V1 has some
                errors.push(NodeCheckerError::new(
                    "Found CallOptionsExpression in V1, but V2 has no options".to_string(),
                    call_opts_range.clone(),
                ));
            }


            if let Some((operand, op_offset)) = extract_first_with_label(&mut call_opts_children, EdgeLabel::Operand) {
                // Unwrap the operand Expression
                match unwrap_expression(&operand.node, op_offset) {
                    Ok((inner_node, inner_offset)) => {
                        current_node = inner_node;
                        current_offset = inner_offset;
                    }
                    Err(e) => {
                        errors.push(e);
                        // Continue to try to check the rest
                        break;
                    }
                }
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected operand in CallOptionsExpression".to_string(),
                    call_opts_range,
                ));
                // Continue to try to check the rest
                break;
            }

            if !call_opts_children.is_empty() {
                errors.push(NodeCheckerError::new(
                    format!("Expected 0 children left in CallOptionsExpression, but there's some left {call_opts_children:#?}"),
                    node_range.clone(),
                ));
            }

        }

        // Check if V2 has more options than V1
        if let Some(ref mut iter) = v2_options_iter {
            let remaining: Vec<_> = iter.collect();
            if !remaining.is_empty() {
                errors.push(NodeCheckerError::new(format!(
                    "V2 has {} more call options than V1 (V1 had {}, V2 has {})",
                    remaining.len(),
                    v1_call_options_count,
                    v1_call_options_count + remaining.len()
                ), node_range.clone()));
            }
        }

        // Now current_node should be the V1 NewExpression
        let new_expression_node = current_node;
        let new_expression_offset = current_offset;
        let new_expression_range = new_expression_offset..(new_expression_offset + new_expression_node.text_len());

        if new_expression_node.kind() != NodeKind::Nonterminal(NonterminalKind::NewExpression) {
            errors.push(NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::NewExpression,
                new_expression_node.kind()
            ), new_expression_range.clone()));
            // Don't return early, continue checking what we can
        }

        let mut new_expression_children = children_with_offsets(&new_expression_node, new_expression_offset);

        // new_keyword
        {
            let new_keyword = &self.new_keyword;
            if let Some((child, child_offset)) = extract_first_with_label(&mut new_expression_children, EdgeLabel::NewKeyword) {
                errors.extend(new_keyword.check_node_with_offset(&child.node, child_offset));
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected new_keyword to be present in NewExpression".to_string(),
                    new_expression_range.clone(),
                ));
            }
        }

        // type_name
        {
            let type_name = &self.type_name;
            if let Some((child, child_offset)) = extract_first_with_label(&mut new_expression_children, EdgeLabel::TypeName) {
                errors.extend(type_name.check_node_with_offset(&child.node, child_offset));
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected type_name to be present in NewExpression".to_string(),
                    new_expression_range.clone(),
                ));
            }
        }

        // arguments
        {
            let arguments = &self.arguments;
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Arguments) {
                errors.extend(arguments.check_node_with_offset(&child.node, child_offset));
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected arguments to be present in FunctionCallExpression".to_string(),
                    node_range.clone(),
                ));
            }
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(format!(
                "Expected 0 children left in FunctionCallExpression, but there's some left {children:#?}",
            ), node_range.clone()));
        }

        if !new_expression_children.is_empty() {
            errors.push(NodeCheckerError::new(format!(
                "Expected 0 children left in NewExpression, but there's some left {new_expression_children:#?}",
            ), new_expression_range));
        }

        errors
    }
}

{% elif parent_type == "VariableDeclaration" %}
// We skip NodeChecker for VariableDeclaration, it's handled by VariableDeclarationStatement

{% elif parent_type == "VariableDeclarationStatement" %}

/// NodeChecker for VariableDeclarationStatement is done by hand, since in V2 is represented differently
impl NodeChecker for VariableDeclarationStatement<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::VariableDeclarationStatement) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::VariableDeclarationStatement,
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // variable_declaration


        // variable_type
        {
            let variable_type = &self.variable_declaration.variable_type;
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::VariableType) {
                let child_errors = variable_type.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected variable_type to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // storage_location
        if let Some(storage_location) = &self.variable_declaration.storage_location {
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::StorageLocation) {
                let child_errors = storage_location.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected storage_location to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        } else {
            // If it's not there on the AST, it shouldn't be in the CST
            if let Some(_) = extract_first_with_label(&mut children, EdgeLabel::StorageLocation) {
                errors.push(NodeCheckerError::new(format!(
                    "Expected storage_location to not be present in the CST, but it was there"
                ), node_range.clone()));
            }
        }

        // name

        {
            let name = &self.variable_declaration.name;
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Name) {
                let child_errors = name.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected name to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        // value
        if let Some(value) = &self.value {
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Value) {
                let child_errors = value.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected value to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        } else {
            // If it's not there on the AST, it shouldn't be in the CST
            if let Some(_) = extract_first_with_label(&mut children, EdgeLabel::Value) {
                errors.push(NodeCheckerError::new(format!(
                    "Expected value to not be present in the CST, but it was there"
                ), node_range.clone()));
            }
        }

        // semicolon

        {
            let semicolon = &self.semicolon;
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Semicolon) {
                let child_errors = semicolon.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new(format!(
                    "Expected semicolon to be present in the CST, but it was not"
                ), node_range.clone()));
            }
        }

        errors
    }
}


{% else %}

/// Generic `NodeChecker` for sequences
impl NodeChecker for {{ parent_type }}<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);

        let mut errors = vec![];

        {% for field in sequence.fields %}
        // {{ field.label }}
        {% if field.is_optional -%}
        if let Some({{ field.label | snake_case }}) = &self.{{ field.label | snake_case }}
        {
        {% else %}
        {
            let {{ field.label | snake_case }} = &self.{{ field.label | snake_case }};
            {%- endif %}

            // Prepare edge label
            {% if field.label == "Expression_InequalityExpression_Operator"
            or field.label == "Expression_EqualityExpression_Operator"
            or field.label == "Expression_ShiftExpression_Operator"
            or field.label == "Expression_AdditiveExpression_Operator"
            or field.label == "Expression_MultiplicativeExpression_Operator"
            or field.label == "Expression_AssignmentExpression_Operator"
            or field.label == "Expression_ExponentiationExpression_Operator"
            or field.label == "Expression_PrefixExpression_Operator"
            or field.label == "Expression_PostfixExpression_Operator" %}
            // Special case for operator fields that are merged together
                {% set edge_label = "Operator" %}
            {% else %}
                {% set edge_label = field.label | pascal_case %}
            {% endif %}

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::{{ edge_label }}) {
                let child_errors = {{ field.label | snake_case }}.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new("Expected {{ field.label }} to be present in the CST, but it was not".to_string(), node_range.clone()));
            }
        } {% if field.is_optional -%}
        else {
            // If it's not there on the AST, it shouldn't be in the CST
            if let Some((child, _)) = extract_first_with_label(&mut children, EdgeLabel::{{ edge_label }}) {
                errors.push(NodeCheckerError::new(format!("Expected {{ field.label }} to not be present in the CST, but it was there: {child:#?}"), node_range.clone()));
            }
        }
        {%- endif %}
        {% endfor %}

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(format!("Expected 0 children left, but there's some left {children:#?}"), node_range));
        }

        errors
    }
}
{% endif %}
{% endfor %}


//
// Choices:
//


{% for parent_type, choice in target.choices %}
{% if parent_type == "Expression_InequalityExpression_Operator"
or parent_type == "Expression_EqualityExpression_Operator"
or parent_type == "Expression_ShiftExpression_Operator"
or parent_type == "Expression_AdditiveExpression_Operator"
or parent_type == "Expression_MultiplicativeExpression_Operator"
or parent_type == "Expression_AssignmentExpression_Operator"
or parent_type == "Expression_ExponentiationExpression_Operator"
or parent_type == "Expression_PrefixExpression_Operator"
or parent_type == "Expression_PostfixExpression_Operator" %}
// Special case for operator choices that are merged together
impl NodeChecker for {{ parent_type }}<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        match self {
            {% for variant in choice.variants %}
            Self::{{ variant.name }}(element) => element.check_node_with_offset(node, text_offset),
            {% endfor %}
        }
    }
}


{% elif parent_type == "MemberAccessIdentifier" %}
/// `NodeChecker` for MemberAccessIdentifier is done by hand since it's not present in V1
impl NodeChecker for MemberAccessIdentifier<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        match self {
            Self::Identifier(element) => element.check_node_with_offset(node, text_offset),
            Self::AddressKeyword(element) => {
                let ident = Identifier {
                    l: element.l,
                    r: element.r,
                    phantom: PhantomData,
                };
                ident.check_node_with_offset(node, text_offset)
            },
        }
    }
}

{% else %}
/// Generic `NodeChecker` for choices
impl NodeChecker for {{ parent_type }}<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != 1 {
            return vec![NodeCheckerError::new(format!("Expected exactly one child for {}, but got: {children:#?}", NonterminalKind::{{ parent_type }}), node_range)];
        }

        let (child, child_offset) = &children[0];

        if child.label != EdgeLabel::Variant {
            let child_range = *child_offset..(*child_offset + child.node.text_len());
            return vec![NodeCheckerError::new(format!("Expected child to be of variant type, but it was {}", child.label), child_range)];
        }

        let mut errors = vec![];

        match self {
            {% for variant in choice.variants %}
            Self::{{ variant.name }}(element) => {
                errors.extend(element.check_node_with_offset(&child.node, *child_offset));
            }
            {% endfor %}
        }

        errors
    }
}
{% endif %}
{% endfor %}

//
// Repeated & Separated
//

{% for parent_type, collection in target.collections %}
{% if parent_type == "IdentifierPathTailElements" %}
// Skip NodeChecker for IdentifierPathTailElements

{% elif parent_type == "MultipleCallOptionsNew" %}
// We skip NodeChecker for MultipleCallOptionsNew, it's handled by NewExpression

{% else %}
/// Generic `NodeChecker` for repeated and separated
impl NodeChecker for {{ parent_type }}<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != self.elements.len() {
            return vec![NodeCheckerError::new(format!("Expected {} elements, but got: {:#?}", self.elements.len(), children), node_range)];
        }

        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {
            let element = &self.elements[i];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}
{% endif %}
{% endfor %}


// Terminals

{% for parent_type, unique in target.terminals %}
/// Generic `NodeChecker` for terminals
impl NodeChecker for {{ parent_type }}<'_> {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());
        let mut errors = vec![];
        if let NodeKind::Terminal(terminal_kind) = node.kind() {
            let v1_kind = terminal_kind.as_ref();
            let v2_kind = "{{ parent_type }}";

            if v1_kind != v2_kind {
                errors.push(NodeCheckerError::new(format!("Expected node kind to be {v2_kind}, but it was {v1_kind}"), node_range));
            }
        } else {
            errors.push(NodeCheckerError::new(format!("Expected node kind to be a terminal, but it was {}", node.kind()), node_range));
        }
        errors
    }
}
{% endfor %}
