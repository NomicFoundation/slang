{%- set target = model.structured_cst_model -%}

#![allow(clippy::too_many_lines)]

#[allow(clippy::wildcard_imports)]
use slang_solidity_v2_cst::structured_cst::nodes::*;
use slang_solidity::cst::{NonterminalKind, NodeKind, Node, EdgeLabel, Edge, TextRange, TextIndex};
use slang_solidity::diagnostic::{Diagnostic, Severity};

/// An error found when checking a node
#[derive(Clone, Debug)]
pub struct NodeCheckerError {
    pub err: String,
    pub text_range: TextRange,

}

impl Diagnostic for NodeCheckerError {
    fn text_range(&self) -> TextRange {
        self.text_range.clone()
    }

    fn severity(&self) -> Severity {
        Severity::Error
    }

    fn message(&self) -> String {
        self.err.clone()
    }
}

impl NodeCheckerError {
    pub(crate) fn new(err: String, text_range: TextRange) -> NodeCheckerError {
        NodeCheckerError { err, text_range }
    }
}

/// A trait that checks whether a CST node (V1) matches the structure of the AST node (V2).
pub trait NodeChecker {
    /// Check whether self matches the given CST node, tracking text offset.
    ///
    /// Returns a vector of errors found, empty if no errors.
    ///
    /// Note: The text offset calculating and tracking seems to reinvent a lot of the logic behind the Cursor,
    /// but it's simple enough that we can do it here. Using a cursor makes it more difficult to compare both
    /// trees, since we'd need to keep track of which children we've seen.
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError>;

    /// Check whether self matches the given CST node.
    ///
    /// Returns a vector of errors found, empty if no errors.
    #[allow(dead_code)]
    fn check_node(&self, node: &Node) -> Vec<NodeCheckerError> {
        self.check_node_with_offset(node, TextIndex::ZERO)
    }
}

/// Extract the first element that satisfies the predicate, and remove it from the vector.
fn extract_first<T>(v: &mut Vec<T>, finder: impl Fn(&T) -> bool) -> Option<T> {
    if let Some(idx) = v.iter().position(finder) {
        return Some(v.remove(idx));
    }
    None
}

/// Extract the first edge with the given label, and remove it from the vector.
fn extract_first_with_label(v: &mut Vec<(Edge, TextIndex)>, label: EdgeLabel) -> Option<(Edge, TextIndex)> {
    extract_first(v, |(child, _): &(Edge, TextIndex)| child.label == label)
}

/// Compute children with their text offsets, filtering out trivia and separators.
///
/// This computes offsets BEFORE filtering so that offsets remain accurate.
///
/// TODO: At some point we may need to check the trivia as well
fn children_with_offsets(node: &Node, text_offset: TextIndex) -> Vec<(Edge, TextIndex)> {
    let mut result = vec![];
    let mut current_offset = text_offset;

    for child in node.children() {
        let child_offset = current_offset;
        current_offset += child.node.text_len();

        // Skip trivia and separators (V2 doesn't parse them)
        if child.node.is_trivia() || child.label == EdgeLabel::Separator {
            continue;
        }

        result.push((child.clone(), child_offset));
    }

    result
}

//
// Sequences:
//


{% for parent_type, sequence in target.sequences %}
{% if parent_type == "IdentifierPath" %}

/// NodeChecker for IdentifierPath is done by hand, since the V2 representation is a bit different
impl NodeChecker for IdentifierPath {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::IdentifierPath) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be {}, but it was {}",
                NonterminalKind::IdentifierPath,
                node.kind()
            ), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        let tail_len = self.tail.as_ref().map_or(0, |tail| tail.elements.elements.len());

        if children.len() != 1 + tail_len {
            return vec![NodeCheckerError::new(format!(
                "Expected {} elements, but got: {:#?}",
                1 + tail_len,
                children
            ), node_range)];
        }


        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {

            if i == 0 {
                // head
                let head = &self.head;
                let child_errors = head.check_node_with_offset(&child.node, *child_offset);
                errors.extend(child_errors);
                continue;
            }
            // tail elements

            let element = &self.tail.as_ref().unwrap().elements.elements[i - 1];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}

{% elif parent_type == "IdentifierPathTail" %}
// We skip NodeChecker for IdentifierPathTail, it's handled by IdentifierPath

{% elif parent_type == "TupleDeconstructionStatement" %}
/// NodeChecker for TupleDeconstructionStatement - v2 has `target` field that wraps v1's direct fields
impl NodeChecker for TupleDeconstructionStatement {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TupleDeconstructionStatement) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TupleDeconstructionStatement, but it was {}",
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // v2's `target` field maps to v1's var_keyword?, open_paren, elements, close_paren
        // We pass the whole node to the target checker which will extract the relevant fields
        errors.extend(self.target.check_node_with_offset(node, text_offset));

        // Remove the fields that target already checked
        extract_first_with_label(&mut children, EdgeLabel::VarKeyword);
        extract_first_with_label(&mut children, EdgeLabel::OpenParen);
        extract_first_with_label(&mut children, EdgeLabel::Elements);
        extract_first_with_label(&mut children, EdgeLabel::CloseParen);

        // equal
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Equal) {
            errors.extend(self.equal.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected equal to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // expression
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Expression) {
            errors.extend(self.expression.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected expression to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // semicolon
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Semicolon) {
            errors.extend(self.semicolon.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected semicolon to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(
                format!("Expected 0 children left, but there's some left {children:#?}"),
                node_range,
            ));
        }

        errors
    }
}

{% elif parent_type == "TypedTupleDeconstructionElement" %}
/// NodeChecker for TypedTupleDeconstructionElement maps to v1's TupleDeconstructionElement
impl NodeChecker for TypedTupleDeconstructionElement {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TupleDeconstructionElement) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TupleDeconstructionElement, but it was {}",
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        if let Some(member) = &self.member {
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Member) {
                errors.extend(member.check_node_with_offset(&child.node, child_offset));
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected member to be present in the CST, but it was not".to_string(),
                    node_range.clone(),
                ));
            }
        } else if let Some((child, _)) = extract_first_with_label(&mut children, EdgeLabel::Member) {
            errors.push(NodeCheckerError::new(
                format!("Expected member to not be present in the CST, but it was there: {child:#?}"),
                node_range.clone(),
            ));
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(
                format!("Expected 0 children left, but there's some left {children:#?}"),
                node_range,
            ));
        }

        errors
    }
}

{% elif parent_type == "UntypedTupleDeconstructionElement" %}
/// NodeChecker for UntypedTupleDeconstructionElement maps to v1's TupleDeconstructionElement
impl NodeChecker for UntypedTupleDeconstructionElement {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TupleDeconstructionElement) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TupleDeconstructionElement, but it was {}",
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // v2's UntypedTupleDeconstructionElement has `name: Identifier?`
        // v1's TupleDeconstructionElement has `member: TupleMember?` where TupleMember can be UntypedTupleMember
        if let Some(name) = &self.name {
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Member) {
                // The child should be a TupleMember -> UntypedTupleMember -> name
                // We need to navigate through TupleMember to get to UntypedTupleMember
                let member_children = children_with_offsets(&child.node, child_offset);
                if let Some((variant_child, variant_offset)) = member_children.first() {
                    // This should be the UntypedTupleMember
                    let untyped_children = children_with_offsets(&variant_child.node, *variant_offset);
                    // Find the Name edge in UntypedTupleMember
                    for (untyped_child, untyped_child_offset) in untyped_children {
                        if untyped_child.label == EdgeLabel::Name {
                            errors.extend(name.check_node_with_offset(&untyped_child.node, untyped_child_offset));
                        }
                    }
                }
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected member to be present in the CST, but it was not".to_string(),
                    node_range.clone(),
                ));
            }
        } else if let Some((child, _)) = extract_first_with_label(&mut children, EdgeLabel::Member) {
            errors.push(NodeCheckerError::new(
                format!("Expected member to not be present in the CST, but it was there: {child:#?}"),
                node_range.clone(),
            ));
        }

        errors
    }
}

{% elif parent_type == "TypedTupleDeconstructionMember" %}
/// NodeChecker for TypedTupleDeconstructionMember maps to v1's TypedTupleMember
impl NodeChecker for TypedTupleDeconstructionMember {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        // v1 has TupleMember -> TypedTupleMember, so we need to check if this is a TupleMember first
        // and then check the variant
        if node.kind() == NodeKind::Nonterminal(NonterminalKind::TupleMember) {
            let children = children_with_offsets(node, text_offset);
            if let Some((variant_child, variant_offset)) = children.first() {
                return self.check_node_with_offset(&variant_child.node, *variant_offset);
            }
        }

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TypedTupleMember) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TypedTupleMember, but it was {}",
                node.kind()
            ), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // type_name
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::TypeName) {
            errors.extend(self.type_name.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected type_name to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // storage_location (optional)
        if let Some(storage_location) = &self.storage_location {
            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::StorageLocation) {
                errors.extend(storage_location.check_node_with_offset(&child.node, child_offset));
            } else {
                errors.push(NodeCheckerError::new(
                    "Expected storage_location to be present in the CST, but it was not".to_string(),
                    node_range.clone(),
                ));
            }
        } else if let Some((child, _)) = extract_first_with_label(&mut children, EdgeLabel::StorageLocation) {
            errors.push(NodeCheckerError::new(
                format!("Expected storage_location to not be present in the CST, but it was there: {child:#?}"),
                node_range.clone(),
            ));
        }

        // name
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Name) {
            errors.extend(self.name.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected name to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(
                format!("Expected 0 children left, but there's some left {children:#?}"),
                node_range,
            ));
        }

        errors
    }
}

{% elif parent_type == "TypedTupleDeconstructionTarget" %}
/// NodeChecker for TypedTupleDeconstructionTarget - no direct v1 equivalent, check children directly
impl NodeChecker for TypedTupleDeconstructionTarget {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());
        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // open_paren
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::OpenParen) {
            errors.extend(self.open_paren.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected open_paren to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // elements
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Elements) {
            errors.extend(self.elements.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected elements to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // close_paren
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::CloseParen) {
            errors.extend(self.close_paren.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected close_paren to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // Remove fields that belong to TupleDeconstructionStatement (checked by parent)
        extract_first_with_label(&mut children, EdgeLabel::Equal);
        extract_first_with_label(&mut children, EdgeLabel::Expression);
        extract_first_with_label(&mut children, EdgeLabel::Semicolon);

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(
                format!("Expected 0 children left, but there's some left {children:#?}"),
                node_range,
            ));
        }

        errors
    }
}

{% elif parent_type == "VarTupleDeconstructionTarget" %}
/// NodeChecker for VarTupleDeconstructionTarget - no direct v1 equivalent, check children directly
impl NodeChecker for VarTupleDeconstructionTarget {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());
        let mut children = children_with_offsets(node, text_offset);
        let mut errors = vec![];

        // var_keyword
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::VarKeyword) {
            errors.extend(self.var_keyword.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected var_keyword to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // open_paren
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::OpenParen) {
            errors.extend(self.open_paren.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected open_paren to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // elements
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::Elements) {
            errors.extend(self.elements.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected elements to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // close_paren
        if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::CloseParen) {
            errors.extend(self.close_paren.check_node_with_offset(&child.node, child_offset));
        } else {
            errors.push(NodeCheckerError::new(
                "Expected close_paren to be present in the CST, but it was not".to_string(),
                node_range.clone(),
            ));
        }

        // Remove fields that belong to TupleDeconstructionStatement (checked by parent)
        extract_first_with_label(&mut children, EdgeLabel::Equal);
        extract_first_with_label(&mut children, EdgeLabel::Expression);
        extract_first_with_label(&mut children, EdgeLabel::Semicolon);

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(
                format!("Expected 0 children left, but there's some left {children:#?}"),
                node_range,
            ));
        }

        errors
    }
}

{% else %}

/// Generic `NodeChecker` for sequences
impl NodeChecker for {{ parent_type }} {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let mut children = children_with_offsets(node, text_offset);

        let mut errors = vec![];

        {% for field in sequence.fields %}
        // {{ field.label }}
        {% if field.is_optional -%}
        if let Some({{ field.label | snake_case }}) = &self.{{ field.label | snake_case }}
        {
        {% else %}
        {
            let {{ field.label | snake_case }} = &self.{{ field.label | snake_case }};
            {%- endif %}

            // Prepare edge label
            {% if field.label == "Expression_InequalityExpression_Operator"
            or field.label == "Expression_EqualityExpression_Operator"
            or field.label == "Expression_ShiftExpression_Operator"
            or field.label == "Expression_AdditiveExpression_Operator"
            or field.label == "Expression_MultiplicativeExpression_Operator"
            or field.label == "Expression_AssignmentExpression_Operator"
            or field.label == "Expression_ExponentiationExpression_Operator"
            or field.label == "Expression_PrefixExpression_Operator"
            or field.label == "Expression_PostfixExpression_Operator" %}
            // Special case for operator fields that are merged together
                {% set edge_label = "Operator" %}
            {% else %}
                {% set edge_label = field.label | pascal_case %}
            {% endif %}

            if let Some((child, child_offset)) = extract_first_with_label(&mut children, EdgeLabel::{{ edge_label }}) {
                let child_errors = {{ field.label | snake_case }}.check_node_with_offset(&child.node, child_offset);
                errors.extend(child_errors);
            } else {
                errors.push(NodeCheckerError::new("Expected {{ field.label }} to be present in the CST, but it was not".to_string(), node_range.clone()));
            }
        } {% if field.is_optional -%}
        else {
            // If it's not there on the AST, it shouldn't be in the CST
            if let Some((child, _)) = extract_first_with_label(&mut children, EdgeLabel::{{ edge_label }}) {
                errors.push(NodeCheckerError::new(format!("Expected {{ field.label }} to not be present in the CST, but it was there: {child:#?}"), node_range.clone()));
            }
        }
        {%- endif %}
        {% endfor %}

        if !children.is_empty() {
            errors.push(NodeCheckerError::new(format!("Expected 0 children left, but there's some left {children:#?}"), node_range));
        }

        errors
    }
}
{% endif %}
{% endfor %}


//
// Choices:
//


{% for parent_type, choice in target.choices %}
{% if parent_type == "Expression_InequalityExpression_Operator"
or parent_type == "Expression_EqualityExpression_Operator"
or parent_type == "Expression_ShiftExpression_Operator"
or parent_type == "Expression_AdditiveExpression_Operator"
or parent_type == "Expression_MultiplicativeExpression_Operator"
or parent_type == "Expression_AssignmentExpression_Operator"
or parent_type == "Expression_ExponentiationExpression_Operator"
or parent_type == "Expression_PrefixExpression_Operator"
or parent_type == "Expression_PostfixExpression_Operator" %}
// Special case for operator choices that are merged together
impl NodeChecker for {{ parent_type }} {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        match self {
            {% for variant in choice.variants %}
            Self::{{ variant.name }}(element) => element.check_node_with_offset(node, text_offset),
            {% endfor %}
        }
    }
}


{% elif parent_type == "MemberAccessIdentifier" %}
/// `NodeChecker` for MemberAccessIdentifier is done by hand since it's not present in V1
impl NodeChecker for MemberAccessIdentifier {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        match self {
            Self::Identifier(element) => element.check_node_with_offset(node, text_offset),
            Self::AddressKeyword(element) => {
                let ident = Identifier {
                    range: element.range.clone(),
                };
                ident.check_node_with_offset(node, text_offset)
            },
        }
    }
}

{% elif parent_type == "TupleDeconstructionTarget" %}
/// `NodeChecker` for TupleDeconstructionTarget - no direct v1 equivalent, delegate to variants
impl NodeChecker for TupleDeconstructionTarget {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        // TupleDeconstructionTarget doesn't exist in v1, so we skip the kind check
        // and directly delegate to the variant's checker
        match self {
            Self::VarTupleDeconstructionTarget(element) => element.check_node_with_offset(node, text_offset),
            Self::TypedTupleDeconstructionTarget(element) => element.check_node_with_offset(node, text_offset),
        }
    }
}

{% else %}
/// Generic `NodeChecker` for choices
impl NodeChecker for {{ parent_type }} {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != 1 {
            return vec![NodeCheckerError::new(format!("Expected exactly one child for {}, but got: {children:#?}", NonterminalKind::{{ parent_type }}), node_range)];
        }

        let (child, child_offset) = &children[0];

        if child.label != EdgeLabel::Variant {
            let child_range = *child_offset..(*child_offset + child.node.text_len());
            return vec![NodeCheckerError::new(format!("Expected child to be of variant type, but it was {}", child.label), child_range)];
        }

        let mut errors = vec![];

        match self {
            {% for variant in choice.variants %}
            Self::{{ variant.name }}(element) => {
                errors.extend(element.check_node_with_offset(&child.node, *child_offset));
            }
            {% endfor %}
        }

        errors
    }
}
{% endif %}
{% endfor %}

//
// Repeated & Separated
//

{% for parent_type, collection in target.collections %}
{% if parent_type == "IdentifierPathTailElements" %}
// Skip NodeChecker for IdentifierPathTailElements, it's handled by IdentifierPath

{% elif parent_type == "TypedTupleDeconstructionElements" %}
/// NodeChecker for TypedTupleDeconstructionElements maps to v1's TupleDeconstructionElements
impl NodeChecker for TypedTupleDeconstructionElements {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TupleDeconstructionElements) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TupleDeconstructionElements, but it was {}",
                node.kind()
            ), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != self.elements.len() {
            return vec![NodeCheckerError::new(format!(
                "Expected {} elements, but got: {:#?}",
                self.elements.len(),
                children
            ), node_range)];
        }

        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {
            let element = &self.elements[i];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}

{% elif parent_type == "UntypedTupleDeconstructionElements" %}
/// NodeChecker for UntypedTupleDeconstructionElements maps to v1's TupleDeconstructionElements
impl NodeChecker for UntypedTupleDeconstructionElements {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::TupleDeconstructionElements) {
            return vec![NodeCheckerError::new(format!(
                "Expected node kind to be TupleDeconstructionElements, but it was {}",
                node.kind()
            ), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != self.elements.len() {
            return vec![NodeCheckerError::new(format!(
                "Expected {} elements, but got: {:#?}",
                self.elements.len(),
                children
            ), node_range)];
        }

        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {
            let element = &self.elements[i];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}

{% else %}
/// Generic `NodeChecker` for repeated and separated
impl NodeChecker for {{ parent_type }} {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());

        if node.kind() != NodeKind::Nonterminal(NonterminalKind::{{ parent_type }}) {
            // Don't even check the rest
            return vec![NodeCheckerError::new(format!("Expected node kind to be {}, but it was {}", NonterminalKind::{{ parent_type }}, node.kind()), node_range)];
        }

        let children = children_with_offsets(node, text_offset);

        if children.len() != self.elements.len() {
            return vec![NodeCheckerError::new(format!("Expected {} elements, but got: {:#?}", self.elements.len(), children), node_range)];
        }

        let mut errors = vec![];

        for (i, (child, child_offset)) in children.iter().enumerate() {
            let element = &self.elements[i];
            errors.extend(element.check_node_with_offset(&child.node, *child_offset));
        }
        errors
    }
}
{% endif %}
{% endfor %}


// Terminals

{% for parent_type in target.terminals %}
/// Generic `NodeChecker` for terminals
impl NodeChecker for {{ parent_type }} {
    fn check_node_with_offset(&self, node: &Node, text_offset: TextIndex) -> Vec<NodeCheckerError> {
        let node_range = text_offset..(text_offset + node.text_len());
        let mut errors = vec![];
        if let NodeKind::Terminal(terminal_kind) = node.kind() {
            let v1_kind = terminal_kind.as_ref();
            let v2_kind = "{{ parent_type }}";

            if v1_kind != v2_kind {
                errors.push(NodeCheckerError::new(format!("Expected node kind to be {v2_kind}, but it was {v1_kind}"), node_range));
            }
        } else {
            errors.push(NodeCheckerError::new(format!("Expected node kind to be a terminal, but it was {}", node.kind()), node_range));
        }
        errors
    }
}
{% endfor %}
