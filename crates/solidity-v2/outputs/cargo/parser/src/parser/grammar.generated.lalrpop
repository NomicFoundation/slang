// This file is generated automatically by infrastructure scripts. Please don't edit by hand.

use crate::lexer::LexemeKind;
use slang_solidity_v2_cst::structured_cst::nodes::*;
use crate::parser::parser_helpers::{
    IndexAccessPath, extract_extra_attributes, index_access_path_add_index,
    new_expression_index_access_path, new_index_access_path_from_elementary_type,
    new_index_access_path_from_identifier_path, new_type_name_index_access_path,
};

grammar<'source>(source: &'source str);

SeparatedAllowEmpty<S, T>: Vec<T> = {
    => vec![],
    Separated<S, T> => <>,
};

Separated<S, T>: Vec<T> = {
    <e:T> => {
        vec![e]
    },
    <mut v: Separated<S, T>> S <e: T> => {
        v.push(e);
        v
    },
};

#[inline]
RepeatedAllowEmpty<T>: Vec<T> = {
    => vec![],
    Repeated<T> => <>,
};

Repeated<T>: Vec<T> = {
    <T> => {
        vec![<>]
    },
    <mut v: Repeated<T>> <e: T> => {
        v.push(e);
        v
    },
};

// Rules for section Pragma

// Rules for topic Pragma Directives
    Pragma: Pragma = {
        <version_pragma: VersionPragma>  => new_pragma_version_pragma(<>),
        <abicoder_pragma: AbicoderPragma>  => new_pragma_abicoder_pragma(<>),
        <experimental_pragma: ExperimentalPragma>  => new_pragma_experimental_pragma(<>),
        
    };
    AbicoderPragma: AbicoderPragma = {
        <abicoder_keyword: AbicoderKeyword>  <version: AbicoderVersion>  => new_abicoder_pragma(<>),
        
    };
    ExperimentalPragma: ExperimentalPragma = {
        <experimental_keyword: ExperimentalKeyword>  <feature: ExperimentalFeature>  => new_experimental_pragma(<>),
        
    };
    AbicoderVersion: AbicoderVersion = {
        <abicoder_v1_keyword: AbicoderV1Keyword>  => new_abicoder_version_abicoder_v1_keyword(<>),
        <abicoder_v2_keyword: AbicoderV2Keyword>  => new_abicoder_version_abicoder_v2_keyword(<>),
        
    };
    ExperimentalFeature: ExperimentalFeature = {
        <abi_encoder_v2_keyword: ABIEncoderV2Keyword>  => new_experimental_feature_abi_encoder_v2_keyword(<>),
        <smt_checker_keyword: SMTCheckerKeyword>  => new_experimental_feature_smt_checker_keyword(<>),
        <string_literal: StringLiteral>  => new_experimental_feature_string_literal(<>),
        
    };
    VersionPragma: VersionPragma = {
        <solidity_keyword: SolidityKeyword>  <sets: VersionExpressionSets>  => new_version_pragma(<>),
        
    };
    VersionExpressionSets: VersionExpressionSets = {
        <version_expression_set: Separated<BarBar, <VersionExpressionSet>>>  => new_version_expression_sets(<>),
        
    };
    VersionExpressionSet: VersionExpressionSet = {
        <version_expression: Repeated<<VersionExpression>>>  => new_version_expression_set(<>),
        
    };
    VersionExpression: VersionExpression = {
        <version_range: VersionRange>  => new_version_expression_version_range(<>),
        <version_term: VersionTerm>  => new_version_expression_version_term(<>),
        
    };
    VersionRange: VersionRange = {
        <start: VersionLiteral>  <minus: Minus>  <end: VersionLiteral>  => new_version_range(<>),
        
    };
    VersionTerm: VersionTerm = {
        <operator: (VersionOperator)?>  <literal: VersionLiteral>  => new_version_term(<>),
        
    };
    VersionOperator: VersionOperator = {
        <caret: Caret>  => new_version_operator_caret(<>),
        <tilde: Tilde>  => new_version_operator_tilde(<>),
        <equal: Equal>  => new_version_operator_equal(<>),
        <less_than: LessThan>  => new_version_operator_less_than(<>),
        <greater_than: GreaterThan>  => new_version_operator_greater_than(<>),
        <less_than_equal: LessThanEqual>  => new_version_operator_less_than_equal(<>),
        <greater_than_equal: GreaterThanEqual>  => new_version_operator_greater_than_equal(<>),
        
    };
    VersionLiteral: VersionLiteral = {
        <simple_version_literal: SimpleVersionLiteral>  => new_version_literal_simple_version_literal(<>),
        <single_quoted_version_literal: SingleQuotedVersionLiteral>  => new_version_literal_single_quoted_version_literal(<>),
        <double_quoted_version_literal: DoubleQuotedVersionLiteral>  => new_version_literal_double_quoted_version_literal(<>),
        
    };
    SimpleVersionLiteral: SimpleVersionLiteral = {
        <version_specifier: Separated<Period, <VersionSpecifier>>>  => new_simple_version_literal(<>),
        
    };
    

// Rules for topic Pragma Keywords
    




// Rules for section File Structure

// Rules for topic Source Unit
    pub SourceUnit: SourceUnit = {
        <members: SourceUnitMembers>  => new_source_unit(<>),
        
    };
    SourceUnitMembers: SourceUnitMembers = {
        <source_unit_member: RepeatedAllowEmpty<<SourceUnitMember>>>  => new_source_unit_members(<>),
        
    };
    SourceUnitMember: SourceUnitMember = {
        <pragma_directive: PragmaDirective>  => new_source_unit_member_pragma_directive(<>),
        <import_directive: ImportDirective>  => new_source_unit_member_import_directive(<>),
        <contract_definition: ContractDefinition>  => new_source_unit_member_contract_definition(<>),
        <interface_definition: InterfaceDefinition>  => new_source_unit_member_interface_definition(<>),
        <library_definition: LibraryDefinition>  => new_source_unit_member_library_definition(<>),
        <struct_definition: StructDefinition>  => new_source_unit_member_struct_definition(<>),
        <enum_definition: EnumDefinition>  => new_source_unit_member_enum_definition(<>),
        <function_definition: FunctionDefinition>  => new_source_unit_member_function_definition(<>),
        <error_definition: ErrorDefinition>  => new_source_unit_member_error_definition(<>),
        <user_defined_value_type_definition: UserDefinedValueTypeDefinition>  => new_source_unit_member_user_defined_value_type_definition(<>),
        <using_directive: UsingDirective>  => new_source_unit_member_using_directive(<>),
        <event_definition: EventDefinition>  => new_source_unit_member_event_definition(<>),
        <constant_definition: ConstantDefinition>  => new_source_unit_member_constant_definition(<>),
        
    };
    
    
PragmaDirective: PragmaDirective = {
    <pragma_keyword: PragmaKeyword>  ! <semicolon: Semicolon>  => {
    let abicoder = new_pragma_abicoder_pragma(new_abicoder_pragma(new_abicoder_keyword(0..0, source), new_abicoder_version_abicoder_v1_keyword(new_abicoder_v1_keyword(0..0, source))));
    new_pragma_directive(pragma_keyword, abicoder , semicolon)
    }
};

    ImportDirective: ImportDirective = {
        <import_keyword: ImportKeyword>  <clause: ImportClause>  <semicolon: Semicolon>  => new_import_directive(<>),
        
    };
    UsingDirective: UsingDirective = {
        <using_keyword: UsingKeyword>  <clause: UsingClause>  <for_keyword: ForKeyword>  <target: UsingTarget>  <global_keyword: (GlobalKeyword)?>  <semicolon: Semicolon>  => new_using_directive(<>),
        
    };
    

// Rules for topic Import Directives
    ImportClause: ImportClause = {
        <path_import: PathImport>  => new_import_clause_path_import(<>),
        <named_import: NamedImport>  => new_import_clause_named_import(<>),
        <import_deconstruction: ImportDeconstruction>  => new_import_clause_import_deconstruction(<>),
        
    };
    PathImport: PathImport = {
        <path: StringLiteral>  <alias: (ImportAlias)?>  => new_path_import(<>),
        
    };
    NamedImport: NamedImport = {
        <asterisk: Asterisk>  <alias: ImportAlias>  <from_keyword: FromKeyword>  <path: StringLiteral>  => new_named_import(<>),
        
    };
    ImportDeconstruction: ImportDeconstruction = {
        <open_brace: OpenBrace>  <symbols: ImportDeconstructionSymbols>  <close_brace: CloseBrace>  <from_keyword: FromKeyword>  <path: StringLiteral>  => new_import_deconstruction(<>),
        
    };
    ImportDeconstructionSymbols: ImportDeconstructionSymbols = {
        <import_deconstruction_symbol: Separated<Comma, <ImportDeconstructionSymbol>>>  => new_import_deconstruction_symbols(<>),
        
    };
    ImportDeconstructionSymbol: ImportDeconstructionSymbol = {
        <name: Identifier>  <alias: (ImportAlias)?>  => new_import_deconstruction_symbol(<>),
        
    };
    ImportAlias: ImportAlias = {
        <as_keyword: AsKeyword>  <identifier: Identifier>  => new_import_alias(<>),
        
    };
    

// Rules for topic Using Directives
    UsingClause: UsingClause = {
        <identifier_path: IdentifierPath>  => new_using_clause_identifier_path(<>),
        <using_deconstruction: UsingDeconstruction>  => new_using_clause_using_deconstruction(<>),
        
    };
    UsingDeconstruction: UsingDeconstruction = {
        <open_brace: OpenBrace>  <symbols: UsingDeconstructionSymbols>  <close_brace: CloseBrace>  => new_using_deconstruction(<>),
        
    };
    UsingDeconstructionSymbols: UsingDeconstructionSymbols = {
        <using_deconstruction_symbol: Separated<Comma, <UsingDeconstructionSymbol>>>  => new_using_deconstruction_symbols(<>),
        
    };
    UsingDeconstructionSymbol: UsingDeconstructionSymbol = {
        <name: IdentifierPath>  <alias: (UsingAlias)?>  => new_using_deconstruction_symbol(<>),
        
    };
    UsingAlias: UsingAlias = {
        <as_keyword: AsKeyword>  <operator: UsingOperator>  => new_using_alias(<>),
        
    };
    UsingOperator: UsingOperator = {
        <ampersand: Ampersand>  => new_using_operator_ampersand(<>),
        <asterisk: Asterisk>  => new_using_operator_asterisk(<>),
        <bang_equal: BangEqual>  => new_using_operator_bang_equal(<>),
        <bar: Bar>  => new_using_operator_bar(<>),
        <caret: Caret>  => new_using_operator_caret(<>),
        <equal_equal: EqualEqual>  => new_using_operator_equal_equal(<>),
        <greater_than: GreaterThan>  => new_using_operator_greater_than(<>),
        <greater_than_equal: GreaterThanEqual>  => new_using_operator_greater_than_equal(<>),
        <less_than: LessThan>  => new_using_operator_less_than(<>),
        <less_than_equal: LessThanEqual>  => new_using_operator_less_than_equal(<>),
        <minus: Minus>  => new_using_operator_minus(<>),
        <percent: Percent>  => new_using_operator_percent(<>),
        <plus: Plus>  => new_using_operator_plus(<>),
        <slash: Slash>  => new_using_operator_slash(<>),
        <tilde: Tilde>  => new_using_operator_tilde(<>),
        
    };
    UsingTarget: UsingTarget = {
        <type_name: TypeName>  => new_using_target_type_name(<>),
        <asterisk: Asterisk>  => new_using_target_asterisk(<>),
        
    };
    

// Rules for topic Trivia
    

// Rules for topic Keywords
    

// Rules for topic Punctuation
    




// Rules for section Definitions

// Rules for topic Contracts
    
    
// Contracts are syntactically complex (for an LR parser) since the storage layout specifier
// has a trailing expression, which can have a trailing option call (`{ ... }`), which conflicts
// with the contract members block.
//
// In order to solve this we use a trailing expression that captures both the expression and the members,
// and then extract the members from it.
pub ContractDefinition: ContractDefinition = {
    // If no specifiers are present, we simply capture the members directly
    <abstract_keyword: (AbstractKeyword)?>  <contract_keyword: ContractKeyword>  <name: Identifier>  <open_brace: OpenBrace>  <members: ContractMembers>  <close_brace: CloseBrace>  => {
        new_contract_definition(abstract_keyword, contract_keyword, name, new_contract_specifiers(vec![]), open_brace, members, close_brace)
    },
    // If specifiers are present, we extract the trailing members from them
    <abstract_keyword: (AbstractKeyword)?>  <contract_keyword: ContractKeyword>  <name: Identifier>  <specifiers: ContractSpecifiersTrailingMembers>  => {
        let (specifiers, (open_brace, members, close_brace)) = specifiers;
        new_contract_definition(abstract_keyword, contract_keyword, name, specifiers, open_brace, members, close_brace)
    },
};

    
    
// In this case, we require at least one specifier, the case with zero is handled above.
// Note that the return type now includes the trailing members
ContractSpecifiersTrailingMembers: (ContractSpecifiers, (OpenBrace, ContractMembers, CloseBrace)) = {
    <mut contract_specifier: RepeatedAllowEmpty<<ContractSpecifier>>> <tail: ContractSpecifierTrailingMembers>  => {
        let (specifier, tail) = tail;
        contract_specifier.push(specifier);
        (new_contract_specifiers(contract_specifier), tail)
    },
};
ContractSpecifierTrailingMembers: (ContractSpecifier, (OpenBrace, ContractMembers, CloseBrace)) = {
    // Since there's no conflict with inheritance specifiers, we can parse them directly and
    // then parse the members
    <inheritance_specifier: InheritanceSpecifier> <open_brace: OpenBrace>  <members: ContractMembers>  <close_brace: CloseBrace>  => {
        (new_contract_specifier_inheritance_specifier(inheritance_specifier), (open_brace, members, close_brace))
    },
    // For storage layout specifiers, we need to extract the trailing members from them
    <storage_layout_specifier: StorageLayoutSpecifierTrailingMembers>  => {
        let (storage_layout_specifier, tail) = storage_layout_specifier;
        (new_contract_specifier_storage_layout_specifier(storage_layout_specifier), tail)
    },
};

StorageLayoutSpecifierTrailingMembers: (StorageLayoutSpecifier, (OpenBrace, ContractMembers, CloseBrace)) = {
    // Instead of parsing a regular Expression, we parse one that captures the trailing members
    <layout_keyword: LayoutKeyword>  <at_keyword: AtKeyword>  <expression: ExpressionTrailingMembers>  => {
        let (expr, tail) = expression;
        (new_storage_layout_specifier(layout_keyword, at_keyword, expr), tail)
    },
};

// An expression followed by contract members
// See the Expression rule for details
ExpressionTrailingMembers: (Expression, (OpenBrace, ContractMembers, CloseBrace)) = {
        <expression: Expression19<BracedContractMembers>>  => <>,
};
BracedContractMembers: (OpenBrace, ContractMembers, CloseBrace) = {
    <open_brace: OpenBrace>  <members: ContractMembers>  <close_brace: CloseBrace>  => {
        (open_brace, members, close_brace)
    },
};

    ContractSpecifier: ContractSpecifier = {
        <inheritance_specifier: InheritanceSpecifier>  => new_contract_specifier_inheritance_specifier(<>),
        <storage_layout_specifier: StorageLayoutSpecifier>  => new_contract_specifier_storage_layout_specifier(<>),
        
    };
    InheritanceSpecifier: InheritanceSpecifier = {
        <is_keyword: IsKeyword>  <types: InheritanceTypes>  => new_inheritance_specifier(<>),
        
    };
    InheritanceTypes: InheritanceTypes = {
        <inheritance_type: Separated<Comma, <InheritanceType>>>  => new_inheritance_types(<>),
        
    };
    InheritanceType: InheritanceType = {
        <type_name: IdentifierPath>  <arguments: (ArgumentsDeclaration)?>  => new_inheritance_type(<>),
        
    };
    StorageLayoutSpecifier: StorageLayoutSpecifier = {
        <layout_keyword: LayoutKeyword>  <at_keyword: AtKeyword>  <expression: Expression>  => new_storage_layout_specifier(<>),
        
    };
    ContractMembers: ContractMembers = {
        <contract_member: RepeatedAllowEmpty<<ContractMember>>>  => new_contract_members(<>),
        
    };
    ContractMember: ContractMember = {
        <using_directive: UsingDirective>  => new_contract_member_using_directive(<>),
        <function_definition: FunctionDefinition>  => new_contract_member_function_definition(<>),
        <constructor_definition: ConstructorDefinition>  => new_contract_member_constructor_definition(<>),
        <receive_function_definition: ReceiveFunctionDefinition>  => new_contract_member_receive_function_definition(<>),
        <fallback_function_definition: FallbackFunctionDefinition>  => new_contract_member_fallback_function_definition(<>),
        <modifier_definition: ModifierDefinition>  => new_contract_member_modifier_definition(<>),
        <struct_definition: StructDefinition>  => new_contract_member_struct_definition(<>),
        <enum_definition: EnumDefinition>  => new_contract_member_enum_definition(<>),
        <event_definition: EventDefinition>  => new_contract_member_event_definition(<>),
        <error_definition: ErrorDefinition>  => new_contract_member_error_definition(<>),
        <user_defined_value_type_definition: UserDefinedValueTypeDefinition>  => new_contract_member_user_defined_value_type_definition(<>),
        <state_variable_definition: StateVariableDefinition>  => new_contract_member_state_variable_definition(<>),
        
    };
    

// Rules for topic Interfaces
    InterfaceDefinition: InterfaceDefinition = {
        <interface_keyword: InterfaceKeyword>  <name: Identifier>  <inheritance: (InheritanceSpecifier)?>  <open_brace: OpenBrace>  <members: InterfaceMembers>  <close_brace: CloseBrace>  => new_interface_definition(<>),
        
    };
    InterfaceMembers: InterfaceMembers = {
        <contract_member: RepeatedAllowEmpty<<ContractMember>>>  => new_interface_members(<>),
        
    };
    

// Rules for topic Libraries
    LibraryDefinition: LibraryDefinition = {
        <library_keyword: LibraryKeyword>  <name: Identifier>  <open_brace: OpenBrace>  <members: LibraryMembers>  <close_brace: CloseBrace>  => new_library_definition(<>),
        
    };
    LibraryMembers: LibraryMembers = {
        <contract_member: RepeatedAllowEmpty<<ContractMember>>>  => new_library_members(<>),
        
    };
    

// Rules for topic Structs
    StructDefinition: StructDefinition = {
        <struct_keyword: StructKeyword>  <name: Identifier>  <open_brace: OpenBrace>  <members: StructMembers>  <close_brace: CloseBrace>  => new_struct_definition(<>),
        
    };
    StructMembers: StructMembers = {
        <struct_member: RepeatedAllowEmpty<<StructMember>>>  => new_struct_members(<>),
        
    };
    StructMember: StructMember = {
        <type_name: TypeName>  <name: Identifier>  <semicolon: Semicolon>  => new_struct_member(<>),
        
    };
    

// Rules for topic Enums
    EnumDefinition: EnumDefinition = {
        <enum_keyword: EnumKeyword>  <name: Identifier>  <open_brace: OpenBrace>  <members: EnumMembers>  <close_brace: CloseBrace>  => new_enum_definition(<>),
        
    };
    EnumMembers: EnumMembers = {
        <identifier: SeparatedAllowEmpty<Comma, <Identifier>>>  => new_enum_members(<>),
        
    };
    

// Rules for topic Constants
    ConstantDefinition: ConstantDefinition = {
        <type_name: TypeName>  <constant_keyword: ConstantKeyword>  <name: Identifier>  <equal: Equal>  <value: Expression>  <semicolon: Semicolon>  => new_constant_definition(<>),
        
    };
    

// Rules for topic State Variables
    
    
// State variable definitions have a conflict when used with function types, since some attributes
// can be both function type attributes and state variable attributes.
// For example in `function (uint a) internal internal foo;`, the first `internal` is a function type attribute,
// while the second `internal` is a state variable attribute.
//
// To disambiguate in these cases we need to count, everything from the second attribute onwards
// belongs to the state variable. This is very hard to do in LR(1) grammars, so we resort to letting
// the function type capture all compatible attributes, and then extract the trailing ones to use them in the state variable.
// 
// This is done by splitting the state variable rules into two cases, one where any type is allowed, except function types
// that do not specify a return; and one where only function types without return are allowed.
//
// Another issue comes from the `error` keyword, since it's not reserved it can also be used as an identifier.
// This conflicts with state variables since `error foo...` could be the beginning of either an
// error definition or a state variable definition.
//
// To solve this we match against state variables where the type is exactly `error` as a special case.
StateVariableDefinition: StateVariableDefinition = {
    // When allowing any type except function types without return, we can parse normally.
    // Note the `IdentifierPathNoError`, it avoids matching against `error` as an identifier.
    <type_name: TypeName1<FunctionTypeInternalReturn, IndexAccessPath<IdentifierPathNoError>>>  <attributes: StateVariableAttributes>  <name: Identifier>  <value: (StateVariableDefinitionValue)?>  <semicolon: Semicolon>  => new_state_variable_definition(<>),

    // Special case for `error` type
    <l:@L> L_ErrorKeyword_Unreserved <r:@R>  <attributes: StateVariableAttributes>  <name: Identifier>  <value: (StateVariableDefinitionValue)?>  <semicolon: Semicolon> => {
        let identifier = new_identifier(l..r, source);
        let iap = new_index_access_path_from_identifier_path(new_identifier_path(vec![new_identifier_path_element_identifier(identifier)]));
        let type_name = new_type_name_index_access_path(iap);

        new_state_variable_definition(type_name, attributes, name, value, semicolon)
    },


    // If the function type has no return, then we don't directly parse state variable attributes, we only do it if
    // we see a special one (one that can be a state variable attribute but not a function type attribute).
    <type_name: FunctionTypeInternalNoReturn> <special_attributes: (<SpecialStateVariableAttribute> <StateVariableAttributes>)?> <name: Identifier>  <value: (StateVariableDefinitionValue)?>  <semicolon: Semicolon>  => {
        let (function_type, mut extra_attributes) = extract_extra_attributes(type_name);
        if let Some(special_attributes) = special_attributes {
            extra_attributes.push(special_attributes.0);
            extra_attributes.extend(special_attributes.1.elements);
        }
        new_state_variable_definition(new_type_name_function_type(function_type), new_state_variable_attributes(extra_attributes), name, value, semicolon)
    },
};

// Match an identifier path that, if it's a single element, is not `error`
IdentifierPathNoError: IdentifierPath = {
    // We either have any identifier with a tail (ie a period)
    <head: Identifier>  <mut tail: IdentifierPathTail>  => {
        tail.insert(0, new_identifier_path_element_identifier(head));
        new_identifier_path(tail)
    },
    // or a single identifier that is not `error`
    <head: SomeIdentifier<"ErrorKeyword_Unreserved">>  => new_identifier_path(vec![new_identifier_path_element_identifier(<>)]),
};

// These are the attributes that can appear in a state variable but not a function,
// they can work as a limit between these definitions.
SpecialStateVariableAttribute: StateVariableAttribute = {
        <override_specifier: OverrideSpecifier>  => new_state_variable_attribute_override_specifier(<>),
        <immutable_keyword: ImmutableKeyword>  => new_state_variable_attribute_immutable_keyword(<>),
        <transient_keyword: TransientKeyword>  => new_state_variable_attribute_transient_keyword(<>),
};

    StateVariableDefinitionValue: StateVariableDefinitionValue = {
        <equal: Equal>  <value: Expression>  => new_state_variable_definition_value(<>),
        
    };
    #[inline]
    StateVariableAttributes: StateVariableAttributes = {
        <state_variable_attribute: RepeatedAllowEmpty<<StateVariableAttribute>>>  => new_state_variable_attributes(<>),
        
    };
    StateVariableAttribute: StateVariableAttribute = {
        <override_specifier: OverrideSpecifier>  => new_state_variable_attribute_override_specifier(<>),
        <constant_keyword: ConstantKeyword>  => new_state_variable_attribute_constant_keyword(<>),
        <internal_keyword: InternalKeyword>  => new_state_variable_attribute_internal_keyword(<>),
        <private_keyword: PrivateKeyword>  => new_state_variable_attribute_private_keyword(<>),
        <public_keyword: PublicKeyword>  => new_state_variable_attribute_public_keyword(<>),
        <immutable_keyword: ImmutableKeyword>  => new_state_variable_attribute_immutable_keyword(<>),
        <transient_keyword: TransientKeyword>  => new_state_variable_attribute_transient_keyword(<>),
        
    };
    

// Rules for topic Functions
    FunctionDefinition: FunctionDefinition = {
        <function_keyword: FunctionKeyword>  <name: FunctionName>  <parameters: ParametersDeclaration>  <attributes: FunctionAttributes>  <returns: (ReturnsDeclaration)?>  <body: FunctionBody>  => new_function_definition(<>),
        
    };
    FunctionName: FunctionName = {
        <identifier: Identifier>  => new_function_name_identifier(<>),
        <fallback_keyword: FallbackKeyword>  => new_function_name_fallback_keyword(<>),
        <receive_keyword: ReceiveKeyword>  => new_function_name_receive_keyword(<>),
        
    };
    ParametersDeclaration: ParametersDeclaration = {
        <open_paren: OpenParen>  <parameters: Parameters>  <close_paren: CloseParen>  => new_parameters_declaration(<>),
        
    };
    Parameters: Parameters = {
        <parameter: SeparatedAllowEmpty<Comma, <Parameter>>>  => new_parameters(<>),
        
    };
    Parameter: Parameter = {
        <type_name: TypeName>  <storage_location: (StorageLocation)?>  <name: (Identifier)?>  => new_parameter(<>),
        
    };
    FunctionAttributes: FunctionAttributes = {
        <function_attribute: RepeatedAllowEmpty<<FunctionAttribute>>>  => new_function_attributes(<>),
        
    };
    FunctionAttribute: FunctionAttribute = {
        <modifier_invocation: ModifierInvocation>  => new_function_attribute_modifier_invocation(<>),
        <override_specifier: OverrideSpecifier>  => new_function_attribute_override_specifier(<>),
        <external_keyword: ExternalKeyword>  => new_function_attribute_external_keyword(<>),
        <internal_keyword: InternalKeyword>  => new_function_attribute_internal_keyword(<>),
        <payable_keyword: PayableKeyword>  => new_function_attribute_payable_keyword(<>),
        <private_keyword: PrivateKeyword>  => new_function_attribute_private_keyword(<>),
        <public_keyword: PublicKeyword>  => new_function_attribute_public_keyword(<>),
        <pure_keyword: PureKeyword>  => new_function_attribute_pure_keyword(<>),
        <view_keyword: ViewKeyword>  => new_function_attribute_view_keyword(<>),
        <virtual_keyword: VirtualKeyword>  => new_function_attribute_virtual_keyword(<>),
        
    };
    OverrideSpecifier: OverrideSpecifier = {
        <override_keyword: OverrideKeyword>  <overridden: (OverridePathsDeclaration)?>  => new_override_specifier(<>),
        
    };
    OverridePathsDeclaration: OverridePathsDeclaration = {
        <open_paren: OpenParen>  <paths: OverridePaths>  <close_paren: CloseParen>  => new_override_paths_declaration(<>),
        
    };
    OverridePaths: OverridePaths = {
        <identifier_path: Separated<Comma, <IdentifierPath>>>  => new_override_paths(<>),
        
    };
    ReturnsDeclaration: ReturnsDeclaration = {
        <returns_keyword: ReturnsKeyword>  <variables: ParametersDeclaration>  => new_returns_declaration(<>),
        
    };
    FunctionBody: FunctionBody = {
        <block: Block>  => new_function_body_block(<>),
        <semicolon: Semicolon>  => new_function_body_semicolon(<>),
        
    };
    ConstructorDefinition: ConstructorDefinition = {
        <constructor_keyword: ConstructorKeyword>  <parameters: ParametersDeclaration>  <attributes: ConstructorAttributes>  <body: Block>  => new_constructor_definition(<>),
        
    };
    ConstructorAttributes: ConstructorAttributes = {
        <constructor_attribute: RepeatedAllowEmpty<<ConstructorAttribute>>>  => new_constructor_attributes(<>),
        
    };
    ConstructorAttribute: ConstructorAttribute = {
        <modifier_invocation: ModifierInvocation>  => new_constructor_attribute_modifier_invocation(<>),
        <internal_keyword: InternalKeyword>  => new_constructor_attribute_internal_keyword(<>),
        <payable_keyword: PayableKeyword>  => new_constructor_attribute_payable_keyword(<>),
        <public_keyword: PublicKeyword>  => new_constructor_attribute_public_keyword(<>),
        
    };
    FallbackFunctionDefinition: FallbackFunctionDefinition = {
        <fallback_keyword: FallbackKeyword>  <parameters: ParametersDeclaration>  <attributes: FallbackFunctionAttributes>  <returns: (ReturnsDeclaration)?>  <body: FunctionBody>  => new_fallback_function_definition(<>),
        
    };
    FallbackFunctionAttributes: FallbackFunctionAttributes = {
        <fallback_function_attribute: RepeatedAllowEmpty<<FallbackFunctionAttribute>>>  => new_fallback_function_attributes(<>),
        
    };
    FallbackFunctionAttribute: FallbackFunctionAttribute = {
        <modifier_invocation: ModifierInvocation>  => new_fallback_function_attribute_modifier_invocation(<>),
        <override_specifier: OverrideSpecifier>  => new_fallback_function_attribute_override_specifier(<>),
        <external_keyword: ExternalKeyword>  => new_fallback_function_attribute_external_keyword(<>),
        <payable_keyword: PayableKeyword>  => new_fallback_function_attribute_payable_keyword(<>),
        <pure_keyword: PureKeyword>  => new_fallback_function_attribute_pure_keyword(<>),
        <view_keyword: ViewKeyword>  => new_fallback_function_attribute_view_keyword(<>),
        <virtual_keyword: VirtualKeyword>  => new_fallback_function_attribute_virtual_keyword(<>),
        
    };
    ReceiveFunctionDefinition: ReceiveFunctionDefinition = {
        <receive_keyword: ReceiveKeyword>  <parameters: ParametersDeclaration>  <attributes: ReceiveFunctionAttributes>  <body: FunctionBody>  => new_receive_function_definition(<>),
        
    };
    ReceiveFunctionAttributes: ReceiveFunctionAttributes = {
        <receive_function_attribute: RepeatedAllowEmpty<<ReceiveFunctionAttribute>>>  => new_receive_function_attributes(<>),
        
    };
    ReceiveFunctionAttribute: ReceiveFunctionAttribute = {
        <modifier_invocation: ModifierInvocation>  => new_receive_function_attribute_modifier_invocation(<>),
        <override_specifier: OverrideSpecifier>  => new_receive_function_attribute_override_specifier(<>),
        <external_keyword: ExternalKeyword>  => new_receive_function_attribute_external_keyword(<>),
        <payable_keyword: PayableKeyword>  => new_receive_function_attribute_payable_keyword(<>),
        <virtual_keyword: VirtualKeyword>  => new_receive_function_attribute_virtual_keyword(<>),
        
    };
    

// Rules for topic Modifiers
    ModifierDefinition: ModifierDefinition = {
        <modifier_keyword: ModifierKeyword>  <name: Identifier>  <parameters: (ParametersDeclaration)?>  <attributes: ModifierAttributes>  <body: FunctionBody>  => new_modifier_definition(<>),
        
    };
    ModifierAttributes: ModifierAttributes = {
        <modifier_attribute: RepeatedAllowEmpty<<ModifierAttribute>>>  => new_modifier_attributes(<>),
        
    };
    ModifierAttribute: ModifierAttribute = {
        <override_specifier: OverrideSpecifier>  => new_modifier_attribute_override_specifier(<>),
        <virtual_keyword: VirtualKeyword>  => new_modifier_attribute_virtual_keyword(<>),
        
    };
    ModifierInvocation: ModifierInvocation = {
        <name: IdentifierPath>  <arguments: (ArgumentsDeclaration)?>  => new_modifier_invocation(<>),
        
    };
    

// Rules for topic Events
    EventDefinition: EventDefinition = {
        <event_keyword: EventKeyword>  <name: Identifier>  <parameters: EventParametersDeclaration>  <anonymous_keyword: (AnonymousKeyword)?>  <semicolon: Semicolon>  => new_event_definition(<>),
        
    };
    EventParametersDeclaration: EventParametersDeclaration = {
        <open_paren: OpenParen>  <parameters: EventParameters>  <close_paren: CloseParen>  => new_event_parameters_declaration(<>),
        
    };
    EventParameters: EventParameters = {
        <event_parameter: SeparatedAllowEmpty<Comma, <EventParameter>>>  => new_event_parameters(<>),
        
    };
    EventParameter: EventParameter = {
        <type_name: TypeName>  <indexed_keyword: (IndexedKeyword)?>  <name: (Identifier)?>  => new_event_parameter(<>),
        
    };
    

// Rules for topic User Defined Value Types
    UserDefinedValueTypeDefinition: UserDefinedValueTypeDefinition = {
        <type_keyword: TypeKeyword>  <name: Identifier>  <is_keyword: IsKeyword>  <value_type: ElementaryType>  <semicolon: Semicolon>  => new_user_defined_value_type_definition(<>),
        
    };
    

// Rules for topic Errors
    #[inline]
    ErrorDefinition: ErrorDefinition = {
        <error_keyword: ErrorKeyword>  <name: Identifier>  <members: ErrorParametersDeclaration>  <semicolon: Semicolon>  => new_error_definition(<>),
        
    };
    ErrorParametersDeclaration: ErrorParametersDeclaration = {
        <open_paren: OpenParen>  <parameters: ErrorParameters>  <close_paren: CloseParen>  => new_error_parameters_declaration(<>),
        
    };
    ErrorParameters: ErrorParameters = {
        <error_parameter: SeparatedAllowEmpty<Comma, <ErrorParameter>>>  => new_error_parameters(<>),
        
    };
    ErrorParameter: ErrorParameter = {
        <type_name: TypeName>  <name: (Identifier)?>  => new_error_parameter(<>),
        
    };
    




// Rules for section Types

// Rules for topic Advanced Types
    
    
// TypeName has two peculiarities:
// 1. We need to parametrize the FunctionRule to allow StateVariableDefinition to disable FunctionTypes without returns.
//    Note that the ArrayTypeName doesn't respect this; most of these manual cases care about trailing constructs, as
//    soon as an extra `[]` is added, the ambiguities disappear.
// 2. A TypeName that can be represented as an `IndexAccessPath` can conflict with a `MemberAccess`, for example
//    `a.b[c]` can be either a member access over an identifier path, or array type, depending on what comes next.
//    This means we need to treat these constructs as IAPs for as long as possible, and only convert them to TypeNames
//    when it's certainly a type. `new_type_name_index_access_path` transforms an IAP into a TypeName.
//    However, since a IAP and an array type conflict, we need to make sure that array types are only matched against
//    base types that are not IAPs, hence the parametric IAPRule.
TypeName0<FunctionRule, IAPRule>: TypeName = {
    <function_type: FunctionRule> => new_type_name_function_type(<>),
    <mapping_type: MappingType>  => new_type_name_mapping_type(<>),
    <index_access_path: IAPRule> => new_type_name_index_access_path(<>),
};
TypeName1<FunctionRule, IAPRule>: TypeName = {
    <type_name: ArrayTypeName>  => new_type_name_array_type_name(<>),
    <type_name: TypeName0<FunctionRule, IAPRule>>  => <>,
};
TypeName: TypeName = {
    // A regular type can have any function type and an IAP
    <type_name: TypeName1<FunctionType, IndexAccessPath<IdentifierPath>>>  => <>,
};

#[inline]
ArrayTypeName: ArrayTypeName = {
    // The base expression shouldn't end in a trailing IAP, if it does (like `a.b[c]`) it will be
    // handled by `new_type_name_index_access_path` above
    <type_name: TypeName1<FunctionType, NoIndexAccessPath>>  <open_bracket: OpenBracket>  <index: (Expression)?>  <close_bracket: CloseBracket>  => new_array_type_name(<>),
};

// An empty rule to disable IAPs
NoIndexAccessPath: IndexAccessPath = {};

    
    
// The only reason to split FunctionType into two rules is to allow StateVariableDefinition
// to choose whether to allow FunctionTypes without returns or not.
// Note: This could be solved with macros, but is short enough to be explicit
FunctionType: FunctionType = {
    FunctionTypeInternalNoReturn => <>,
    FunctionTypeInternalReturn => <>,
};

FunctionTypeInternalNoReturn: FunctionType = {
    <function_keyword: FunctionKeyword>  <parameters: ParametersDeclaration>  <attributes: FunctionTypeAttributes>   => new_function_type(function_keyword, parameters, attributes, None),
};
FunctionTypeInternalReturn: FunctionType = {
    <function_keyword: FunctionKeyword>  <parameters: ParametersDeclaration>  <attributes: FunctionTypeAttributes>  <returns: ReturnsDeclaration>  => new_function_type(function_keyword, parameters, attributes, Some(returns)),
    
};

    FunctionTypeAttributes: FunctionTypeAttributes = {
        <function_type_attribute: RepeatedAllowEmpty<<FunctionTypeAttribute>>>  => new_function_type_attributes(<>),
        
    };
    FunctionTypeAttribute: FunctionTypeAttribute = {
        <internal_keyword: InternalKeyword>  => new_function_type_attribute_internal_keyword(<>),
        <external_keyword: ExternalKeyword>  => new_function_type_attribute_external_keyword(<>),
        <private_keyword: PrivateKeyword>  => new_function_type_attribute_private_keyword(<>),
        <public_keyword: PublicKeyword>  => new_function_type_attribute_public_keyword(<>),
        <pure_keyword: PureKeyword>  => new_function_type_attribute_pure_keyword(<>),
        <view_keyword: ViewKeyword>  => new_function_type_attribute_view_keyword(<>),
        <payable_keyword: PayableKeyword>  => new_function_type_attribute_payable_keyword(<>),
        
    };
    MappingType: MappingType = {
        <mapping_keyword: MappingKeyword>  <open_paren: OpenParen>  <key_type: MappingKey>  <equal_greater_than: EqualGreaterThan>  <value_type: MappingValue>  <close_paren: CloseParen>  => new_mapping_type(<>),
        
    };
    MappingKey: MappingKey = {
        <key_type: MappingKeyType>  <name: (Identifier)?>  => new_mapping_key(<>),
        
    };
    MappingKeyType: MappingKeyType = {
        <elementary_type: ElementaryType>  => new_mapping_key_type_elementary_type(<>),
        <identifier_path: IdentifierPath>  => new_mapping_key_type_identifier_path(<>),
        
    };
    MappingValue: MappingValue = {
        <type_name: TypeName>  <name: (Identifier)?>  => new_mapping_value(<>),
        
    };
    

// Rules for topic Elementary Types
    ElementaryType: ElementaryType = {
        <bool_keyword: BoolKeyword>  => new_elementary_type_bool_keyword(<>),
        <string_keyword: StringKeyword>  => new_elementary_type_string_keyword(<>),
        <address_type: AddressType>  => new_elementary_type_address_type(<>),
        <bytes_keyword: BytesKeyword>  => new_elementary_type_bytes_keyword(<>),
        <int_keyword: IntKeyword>  => new_elementary_type_int_keyword(<>),
        <uint_keyword: UintKeyword>  => new_elementary_type_uint_keyword(<>),
        <fixed_keyword: FixedKeyword>  => new_elementary_type_fixed_keyword(<>),
        <ufixed_keyword: UfixedKeyword>  => new_elementary_type_ufixed_keyword(<>),
        
    };
    AddressType: AddressType = {
        <address_keyword: AddressKeyword>  <payable_keyword: (PayableKeyword)?>  => new_address_type(<>),
        
    };
    




// Rules for section Statements

// Rules for topic Blocks
    Block: Block = {
        <open_brace: OpenBrace>  <statements: Statements>  <close_brace: CloseBrace>  => new_block(<>),
        
    };
    Statements: Statements = {
        <statement: RepeatedAllowEmpty<<Statement>>>  => new_statements(<>),
        
    };
    
    
// There's two issues with `Statement`:
//
// This is a common problem in grammars[1]. To not reinvent the wheel we follow advice from
// LALRPOP community[2].
// Briefly, we parametrize statements on whether they allow a trailing else or not, forcing `else`s to attach to
// the innermost `if`` possible.
//
// [1]: https://en.wikipedia.org/wiki/Dangling_else
// [2]: https://github.com/lalrpop/lalrpop/issues/67#issuecomment-188951041
//
// On top of that, the `revert` keyword is unreserved, meaning that a variable declaration like
// `revert x = ...;` is valid.
// From the perspective of the parser there's an ambiguity when looking at a statement starting with `revert x ...`
//
// To solve it we introduce a special `VariableDeclarationStatement` that handles this case specifically,
// since both this and `RevertStatement` are inlined, the parser doesn't need to reduce until it has seen the
// entire statement.
_Statement<TrailingElse>: Statement = {
    <if_statement: IfStatement<TrailingElse>>  => new_statement_if_statement(<>),
    <for_statement: ForStatement<TrailingElse>>  => new_statement_for_statement(<>),
    <while_statement: WhileStatement<TrailingElse>>  => new_statement_while_statement(<>),
    <do_while_statement: DoWhileStatement>  => new_statement_do_while_statement(<>),
    <continue_statement: ContinueStatement>  => new_statement_continue_statement(<>),
    <break_statement: BreakStatement>  => new_statement_break_statement(<>),
    <return_statement: ReturnStatement>  => new_statement_return_statement(<>),
    <emit_statement: EmitStatement>  => new_statement_emit_statement(<>),
    <try_statement: TryStatement>  => new_statement_try_statement(<>),
    <revert_statement: RevertStatement>  => new_statement_revert_statement(<>),
    <assembly_statement: AssemblyStatement>  => new_statement_assembly_statement(<>),
    <block: Block>  => new_statement_block(<>),
    <unchecked_block: UncheckedBlock>  => new_statement_unchecked_block(<>),
    <variable_declaration_statement: VariableDeclarationStatementSpecialRevert>  => new_statement_variable_declaration_statement(<>),
    <expression_statement: ExpressionStatement>  => new_statement_expression_statement(<>),
};

// By default statements allow dangling `else`s
Statement = _Statement<"True">;

// A VariableDeclarationStatement that has a `revert` type as a special case, this allows
// to disambiguate between a revert statement and a variable declaration with type `revert`
//
// Note: They need to be inline together with `RevertStatement` to actually avoid shift/reduce conflicts
#[inline]
VariableDeclarationStatementSpecialRevert: VariableDeclarationStatement = {
    <target: VariableDeclarationTargetSpecialRevert>  <semicolon: Semicolon>  => new_variable_declaration_statement(<>),
};
#[inline]
VariableDeclarationTargetSpecialRevert: VariableDeclarationTarget = {
    <single_typed_declaration: SingleTypedDeclarationSpecialRevert>  => new_variable_declaration_target_single_typed_declaration(<>),
    <multi_typed_declaration: MultiTypedDeclaration>  => new_variable_declaration_target_multi_typed_declaration(<>),
};
#[inline]
SingleTypedDeclarationSpecialRevert: SingleTypedDeclaration = {
    <declaration: VariableDeclarationSpecialRevert>  <value: (VariableDeclarationValue)?>  => new_single_typed_declaration(<>),
};
#[inline]
VariableDeclarationSpecialRevert: VariableDeclaration = {
    // A regular type that is not `revert`
    //
    // Note: we're tempted to inline TypeNames, but they are recursive, that's why we extract the special case
    <type_name: TypeName1<FunctionType, IndexAccessPath<IdentifierPathNoRevert>>>  <storage_location: (StorageLocation)?>  <name: Identifier>  => new_variable_declaration(<>),
    // The special `revert` type
    <l:@L> L_RevertKeyword_Unreserved <r:@R>  <storage_location: (StorageLocation)?>  <name: Identifier>  => {
        let identifier = new_identifier(l..r, source);
        let iap = new_index_access_path_from_identifier_path(new_identifier_path(vec![new_identifier_path_element_identifier(identifier)]));
        let type_name = new_type_name_index_access_path(iap);
        new_variable_declaration(type_name, storage_location, name)
    }
};

// An IdentifierPath that cannot be `revert`, used to disambiguate from the `revert` type
#[inline]
IdentifierPathNoRevert: IdentifierPath = {
    // We either have any identifier with a tail (ie a period)
    <head: Identifier> <mut tail: IdentifierPathTail>  => {
        tail.insert(0, new_identifier_path_element_identifier(head));
        new_identifier_path(tail)
    },
    // or a single identifier that is not `revert`
    <head: SomeIdentifier<"RevertKeyword_Unreserved">>  => new_identifier_path(vec![new_identifier_path_element_identifier(<>)]),
};

    UncheckedBlock: UncheckedBlock = {
        <unchecked_keyword: UncheckedKeyword>  <block: Block>  => new_unchecked_block(<>),
        
    };
    ExpressionStatement: ExpressionStatement = {
        <expression: Expression>  <semicolon: Semicolon>  => new_expression_statement(<>),
        
    };
    AssemblyStatement: AssemblyStatement = {
        <assembly_keyword: AssemblyKeyword>  <label: (StringLiteral)?>  <flags: (AssemblyFlagsDeclaration)?>  <body: YulBlock>  => new_assembly_statement(<>),
        
    };
    AssemblyFlagsDeclaration: AssemblyFlagsDeclaration = {
        <open_paren: OpenParen>  <flags: AssemblyFlags>  <close_paren: CloseParen>  => new_assembly_flags_declaration(<>),
        
    };
    AssemblyFlags: AssemblyFlags = {
        <string_literal: Separated<Comma, <StringLiteral>>>  => new_assembly_flags(<>),
        
    };
    

// Rules for topic Declaration Statements
    VariableDeclaration: VariableDeclaration = {
        <type_name: TypeName>  <storage_location: (StorageLocation)?>  <name: Identifier>  => new_variable_declaration(<>),
        
    };
    VariableDeclarationStatement: VariableDeclarationStatement = {
        <target: VariableDeclarationTarget>  <semicolon: Semicolon>  => new_variable_declaration_statement(<>),
        
    };
    VariableDeclarationTarget: VariableDeclarationTarget = {
        <single_typed_declaration: SingleTypedDeclaration>  => new_variable_declaration_target_single_typed_declaration(<>),
        <multi_typed_declaration: MultiTypedDeclaration>  => new_variable_declaration_target_multi_typed_declaration(<>),
        
    };
    SingleTypedDeclaration: SingleTypedDeclaration = {
        <declaration: VariableDeclaration>  <value: (VariableDeclarationValue)?>  => new_single_typed_declaration(<>),
        
    };
    MultiTypedDeclaration: MultiTypedDeclaration = {
        <open_paren: OpenParen>  <elements: MultiTypedDeclarationElements>  <close_paren: CloseParen>  <value: VariableDeclarationValue>  => new_multi_typed_declaration(<>),
        
    };
    
    
// MultiTypedDeclaration conflict with tuple expression, for example, the following is ambiguous:
//
// |--------|  => Assignment expression
// |--|        => Tuple expression
// (,,) = foo;
// |--------|  => MultiTypedDeclaration
//
// In order to fix that, we give priority to assignment expressions, except an actual declaration (`uint bar`)
// is seen.
//
// Since they also share a prefix (`(,,,`) we need to have a common prefix rule to avoid reduce/reduce conflicts.
MultiTypedDeclarationElements: MultiTypedDeclarationElements = {
    <prefix: TuplePrefix> <differentiator: VariableDeclaration> <typed_tuple_deconstruction_element: (Comma <Separated<Comma, <MultiTypedDeclarationElement>>>)?>  => {
        let mut elements = vec![new_multi_typed_declaration_element(None); prefix];
        elements.push(new_multi_typed_declaration_element(Some(differentiator)));
        elements.extend(typed_tuple_deconstruction_element.unwrap_or(vec![]));
        new_multi_typed_declaration_elements(elements)
    },
    
};

// TuplePrefix counts how many leading commas we have in a tuple deconstruction or
// in a tuple expression, this helps avoid reduce/reduce conflicts
TuplePrefix: usize = {
    // Count how many commas we have at the start, each comma represents an unnamed element
    Comma  <rest: TuplePrefix>  => 1 + rest,
    => 0,
};

    MultiTypedDeclarationElement: MultiTypedDeclarationElement = {
        <member: (VariableDeclaration)?>  => new_multi_typed_declaration_element(<>),
        
    };
    VariableDeclarationValue: VariableDeclarationValue = {
        <equal: Equal>  <expression: Expression>  => new_variable_declaration_value(<>),
        
    };
    StorageLocation: StorageLocation = {
        <memory_keyword: MemoryKeyword>  => new_storage_location_memory_keyword(<>),
        <storage_keyword: StorageKeyword>  => new_storage_location_storage_keyword(<>),
        <call_data_keyword: CallDataKeyword>  => new_storage_location_call_data_keyword(<>),
        
    };
    

// Rules for topic Control Statements
    
    
// As explained in the `Statement` rule, this solves the dangling else problem
IfStatement<TrailingElse>: IfStatement = {
    // IfStatement only allows `if`s without an else if TrailingElse == "True"
    <if_keyword: IfKeyword>  <open_paren: OpenParen>  <condition: Expression>  <close_paren: CloseParen>  <body: _Statement<"True">> if TrailingElse == "True"  => new_if_statement(<>, None),
    <if_keyword: IfKeyword>  <open_paren: OpenParen>  <condition: Expression>  <close_paren: CloseParen>  <body: _Statement<"False">>  <else_keyword: ElseKeyword>  <else_branch: _Statement<TrailingElse>>  => new_if_statement(if_keyword, open_paren, condition, close_paren, body, Some(new_else_branch(else_keyword, else_branch))),
};

    ElseBranch: ElseBranch = {
        <else_keyword: ElseKeyword>  <body: Statement>  => new_else_branch(<>),
        
    };
    
    
// As explained in the `Statement` rule, this solves the dangling else problem
//
// Since a `ForStatement` can have a trailing `Statement` we need to parametrize it as well
ForStatement<TrailingElse>: ForStatement = {
        <for_keyword: ForKeyword>  <open_paren: OpenParen>  <initialization: ForStatementInitialization>  <condition: ForStatementCondition>  <iterator: (Expression)?>  <close_paren: CloseParen>  <body: _Statement<TrailingElse>>  => new_for_statement(<>),
};
    ForStatementInitialization: ForStatementInitialization = {
        <variable_declaration_statement: VariableDeclarationStatement>  => new_for_statement_initialization_variable_declaration_statement(<>),
        <expression_statement: ExpressionStatement>  => new_for_statement_initialization_expression_statement(<>),
        <semicolon: Semicolon>  => new_for_statement_initialization_semicolon(<>),
        
    };
    ForStatementCondition: ForStatementCondition = {
        <expression_statement: ExpressionStatement>  => new_for_statement_condition_expression_statement(<>),
        <semicolon: Semicolon>  => new_for_statement_condition_semicolon(<>),
        
    };
    
    
// As explained in the `Statement` rule, this solves the dangling else problem
//
// Since a `WhileStatement` can have a trailing `Statement` we need to parametrize it as well
WhileStatement<TrailingElse>: WhileStatement = {
        <while_keyword: WhileKeyword>  <open_paren: OpenParen>  <condition: Expression>  <close_paren: CloseParen>  <body: _Statement<TrailingElse>>  => new_while_statement(<>),
};
    DoWhileStatement: DoWhileStatement = {
        <do_keyword: DoKeyword>  <body: Statement>  <while_keyword: WhileKeyword>  <open_paren: OpenParen>  <condition: Expression>  <close_paren: CloseParen>  <semicolon: Semicolon>  => new_do_while_statement(<>),
        
    };
    ContinueStatement: ContinueStatement = {
        <continue_keyword: ContinueKeyword>  <semicolon: Semicolon>  => new_continue_statement(<>),
        
    };
    BreakStatement: BreakStatement = {
        <break_keyword: BreakKeyword>  <semicolon: Semicolon>  => new_break_statement(<>),
        
    };
    ReturnStatement: ReturnStatement = {
        <return_keyword: ReturnKeyword>  <expression: (Expression)?>  <semicolon: Semicolon>  => new_return_statement(<>),
        
    };
    EmitStatement: EmitStatement = {
        <emit_keyword: EmitKeyword>  <event: IdentifierPath>  <arguments: ArgumentsDeclaration>  <semicolon: Semicolon>  => new_emit_statement(<>),
        
    };
    

// Rules for topic Error Handling
    
    
// A try statement conflicts with expressions since an expression can have named arguments (similar to a block)
// at the end. For example, if the parser sees `try foo { a` it doesn't know whether foo is an expression and it should
// start parsing a block (a reduce) or whether it should keep parsing a call options expression (a shift).
//
// We use expressions with a trailing block to solve this, and steal the block from there.
TryStatement: TryStatement = {
    // a `ReturnsDeclaration` acts as a disambiguator
    <try_keyword: TryKeyword>  <expression: Expression>  <returns: ReturnsDeclaration>  <body: Block>  <catch_clauses: CatchClauses>  => {
        new_try_statement(try_keyword, expression, Some(returns), body, catch_clauses)
    },
    <try_keyword: TryKeyword>  <expression: ExpressionTrailingBlock>   <catch_clauses: CatchClauses>  => {
        let (expr, body) = expression;
        new_try_statement(try_keyword, expr, None, body, catch_clauses)
    },
};

// An expression followed by a block
ExpressionTrailingBlock: (Expression, Block) = {
        <expression: Expression19<Block>>  => <>,
};

    CatchClauses: CatchClauses = {
        <catch_clause: Repeated<<CatchClause>>>  => new_catch_clauses(<>),
        
    };
    CatchClause: CatchClause = {
        <catch_keyword: CatchKeyword>  <error: (CatchClauseError)?>  <body: Block>  => new_catch_clause(<>),
        
    };
    CatchClauseError: CatchClauseError = {
        <name: (Identifier)?>  <parameters: ParametersDeclaration>  => new_catch_clause_error(<>),
        
    };
    #[inline]
    RevertStatement: RevertStatement = {
        <revert_keyword: RevertKeyword>  <error: IdentifierPath>  <arguments: ArgumentsDeclaration>  <semicolon: Semicolon>  => new_revert_statement(<>),
        
    };
    




// Rules for section Expressions

// Rules for topic Base Expressions
    
    
// Expression has a lot of tricky cases:
// 1. There's conflicts with `TypeName`, for example `a.b[c]` can be either a member access over an identifier path, or
//    an array type, depending on what comes next. As explained on the `TypeName` rule, we need to delay reduction of
//    these constructs as long as possible, only converting them to `Expression` at new_expression_index_access_path.
//    Note: That there's no `ElementaryType` rule, it's handled as an IAP
// 2. But this creates another problem, since we still want to have `MemberAccess` and `IndexAccess` as expressions,
//    but now they conflict with IAP; for example, `a.b` can be either a member access or an IAP, therefore we have to
//    disable member access and index access over IAPs that can be types, we do this by parametrizing the
//    `IndexAccessPathRule`
// 3. Also, new expressions are problematic, since they have a trailing `TypeName`, allowing this example to be parsed
//    in two different ambiguous ways:
//
//        |--------| => IndexAccessExpression
//        |-----|    => NewExpression
//            |-|    => TypeName
//        new foo[]
//            |---|  => TypeName (an array type)
//        |-------|  => NewExpression
//
//    We want to fix this by giving priority to the internal typename, therefore we parametrize over `NewExpressionRule`
//    disallowing `MemberAccess` and `IndexAccess` over new expressions.
// 4. `Expression` are often at a trailing position, for example in storage layout specifiers,
//    to facilitate fixing ambiguities in those cases, we allow `Expression` to be parametrized over a trailing element,
//    that will be matched against when possible, and lifted up through the recursion.
//    This seems to not have any effect, but it allows the parser to postpone reductions.
// 5. Finally, expressions have multiple precedence levels and associativity, we handle this explicitely here.
Expression0<IndexAccessPathRule, NewExpressionRule>: Expression = {
    // The Rule used here is parametric
    <index_access_path: IndexAccessPathRule> => new_expression_index_access_path(<>),
    // The Rule used here is parametric
    <new_expression: NewExpressionRule> => new_expression_new_expression(<>),
    <tuple_expression: TupleExpression>  => new_expression_tuple_expression(<>),
    <type_expression: TypeExpression>  => new_expression_type_expression(<>),
    <array_expression: ArrayExpression>  => new_expression_array_expression(<>),
    <hex_number_expression: HexNumberExpression>  => new_expression_hex_number_expression(<>),
    <decimal_number_expression: DecimalNumberExpression>  => new_expression_decimal_number_expression(<>),
    <string_expression: StringExpression>  => new_expression_string_expression(<>),
    <payable_keyword: PayableKeyword>  => new_expression_payable_keyword(<>),
    <this_keyword: ThisKeyword>  => new_expression_this_keyword(<>),
    <super_keyword: SuperKeyword>  => new_expression_super_keyword(<>),
    <true_keyword: TrueKeyword>  => new_expression_true_keyword(<>),
    <false_keyword: FalseKeyword>  => new_expression_false_keyword(<>),
};

// An IAP that doesn't match anything
NoIndexAccessPath_Expr: IndexAccessPath = {};

// We simplifiy all these levels of expressions into a single one, there's no need
// for precedence here
Expression1<IndexAccessPathRule, NewExpressionRule>: Expression = {
    // When parsing an index acces expression, the sub expression shouldn't trail in an index access path
    // Nor should it trail on a NewExpression
    <expression: Expression1<NoIndexAccessPath_Expr, NoNewExpression>>  <open_bracket: OpenBracket>  <start: (Expression)?>  <end: (IndexAccessEnd)?>  <close_bracket: CloseBracket>  => new_expression_index_access_expression(new_index_access_expression(<>)),
    // When parsing a member access expression, the sub expression shouldn't trail in a path
    // Nor should it trail on a NewExpression
    <expression: Expression1<IndexAccessPath<NoIdentPath>, NoNewExpression>>  <period: Period>  <member: IdentifierPathElement>  => new_expression_member_access_expression(new_member_access_expression(<>)),

    // Both the braces and the arguments declaration serve as markers for disambiguation, therefore
    // resetting the parametric rules.
    <expression: Expression1<IndexAccessPath<IdentifierPath>, NewExpression>>  <open_brace: OpenBrace>  <options: CallOptions>  <close_brace: CloseBrace>  => new_expression_call_options_expression(new_call_options_expression(<>)),
    <expression: Expression1<IndexAccessPath<IdentifierPath>, NewExpression>>  <arguments: ArgumentsDeclaration>  => new_expression_function_call_expression(new_function_call_expression(<>)),

    <expression: Expression0<IndexAccessPathRule, NewExpressionRule>>  => <>,
};

// A Matcher for an empty NewExpression 
NoNewExpression: NewExpression = {};

// Tail is a rule identifying what comes after the expression, whatever is captured is added to the tuple result
Expression5<Tail>: (Expression, Tail) = {
    <expression_prefix_expression_operator: Expression_PrefixExpression_Operator>  <expression: Expression5<Tail>>  => {
        let (expr, tail) = expression;
        (new_expression_prefix_expression(new_prefix_expression(expression_prefix_expression_operator, expr)), tail)
    },
    
    // A tail can appear just after a postfix or primary expression
    <expression: Expression1<IndexAccessPath<IdentifierPath>, NewExpression>> <tail: Tail> => {
        (expression, tail)
    },
};
Expression6<Tail>: (Expression, Tail) = {
    // This is the only other postfix expression that can overwrite a trailing element
    // Note that the recursive call expects no tail at all
    <expression: Expression6<EmptyTail>>  <expression_postfix_expression_operator: Expression_PostfixExpression_Operator> <tail: Tail>  => {
        // This is monomorphized by LALRPOP, so we can't really fix this
        #[allow(clippy::ignored_unit_patterns)]
        let (expr, _) = expression;
        (new_expression_postfix_expression(new_postfix_expression(expr, expression_postfix_expression_operator)), tail)
    },
    
    <expression: Expression5<Tail>>  => <>,
};
Expression7<Tail>: (Expression, Tail) = {
    // Note that only the right recursive rule matches a tail, the left recursive expects no tail
    <expression: Expression6<EmptyTail>>  <operator: Expression_ExponentiationExpression_Operator>  <expression_2: Expression7<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_exponentiation_expression(new_exponentiation_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression6<Tail>>  => <>,
};
Expression8<Tail>: (Expression, Tail) = {
    <expression: Expression8<EmptyTail>>  <expression_multiplicative_expression_operator: Expression_MultiplicativeExpression_Operator>  <expression_2: Expression7<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_multiplicative_expression(new_multiplicative_expression(e, expression_multiplicative_expression_operator, e2)), tail)
    },
    
    <expression: Expression7<Tail>>  => <>,
};
Expression9<Tail>: (Expression, Tail) = {
    <expression: Expression9<EmptyTail>>  <expression_additive_expression_operator: Expression_AdditiveExpression_Operator>  <expression_2: Expression8<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_additive_expression(new_additive_expression(e, expression_additive_expression_operator, e2)), tail)
    },
    
    <expression: Expression8<Tail>>  => <>,
};
Expression10<Tail>: (Expression, Tail) = {
    <expression: Expression10<EmptyTail>>  <expression_shift_expression_operator: Expression_ShiftExpression_Operator>  <expression_2: Expression9<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_shift_expression(new_shift_expression(e, expression_shift_expression_operator, e2)), tail)
    },
    
    <expression: Expression9<Tail>>  => <>,
};
Expression11<Tail>: (Expression, Tail) = {
    <expression: Expression11<EmptyTail>>  <operator: Ampersand>  <expression_2: Expression10<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_bitwise_and_expression(new_bitwise_and_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression10<Tail>>  => <>,
};
Expression12<Tail>: (Expression, Tail) = {
    <expression: Expression12<EmptyTail>>  <operator: Caret>  <expression_2: Expression11<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_bitwise_xor_expression(new_bitwise_xor_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression11<Tail>>  => <>,
};
Expression13<Tail>: (Expression, Tail) = {
    <expression: Expression13<EmptyTail>>  <operator: Bar>  <expression_2: Expression12<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_bitwise_or_expression(new_bitwise_or_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression12<Tail>>  => <>,
};
Expression14<Tail>: (Expression, Tail) = {
    <expression: Expression14<EmptyTail>>  <expression_inequality_expression_operator: Expression_InequalityExpression_Operator>  <expression_2: Expression13<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_inequality_expression(new_inequality_expression(e, expression_inequality_expression_operator, e2)), tail)
    },
    
    <expression: Expression13<Tail>>  => <>,
};
Expression15<Tail>: (Expression, Tail) = {
    <expression: Expression15<EmptyTail>>  <expression_equality_expression_operator: Expression_EqualityExpression_Operator>  <expression_2: Expression14<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_equality_expression(new_equality_expression(e, expression_equality_expression_operator, e2)), tail)
    },
    
    <expression: Expression14<Tail>>  => <>,
};
Expression16<Tail>: (Expression, Tail) = {
    <expression: Expression16<EmptyTail>>  <operator: AmpersandAmpersand>  <expression_2: Expression15<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_and_expression(new_and_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression15<Tail>>  => <>,
};
Expression17<Tail>: (Expression, Tail) = {
    <expression: Expression17<EmptyTail>>  <operator: BarBar>  <expression_2: Expression16<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_or_expression(new_or_expression(e, operator, e2)), tail)
    },
    
    <expression: Expression16<Tail>>  => <>,
};
Expression18<Tail>: (Expression, Tail) = {
    <expression: Expression17<EmptyTail>>  <question_mark: QuestionMark>  <true_expression: Expression18<EmptyTail>>  <colon: Colon>  <false_expression: Expression18<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (cond_expr, _) = expression;
        #[allow(clippy::ignored_unit_patterns)]
        let (true_expr, _) = true_expression;
        let (false_expr, tail) = false_expression;
        (new_expression_conditional_expression(new_conditional_expression(cond_expr, question_mark, true_expr, colon, false_expr)), tail)
    },
    
    <expression: Expression17<Tail>>  => <>,
};
Expression19<Tail>: (Expression, Tail) = {
    <expression: Expression19<EmptyTail>>  <expression_assignment_expression_operator: Expression_AssignmentExpression_Operator>  <expression_2: Expression18<Tail>>  => {
        #[allow(clippy::ignored_unit_patterns)]
        let (e, _) = expression;
        let (e2, tail) = expression_2;
        (new_expression_assignment_expression(new_assignment_expression(e, expression_assignment_expression_operator, e2)), tail)
    },
    
    <expression: Expression18<Tail>>  => <>,
};

// Expression is public
pub Expression: Expression = {
    // By default, we expect no tail
    <expression: Expression19<EmptyTail>>  => expression.0,
};

// An empty tail is the default behaviour
EmptyTail: () = {
    () => (),
};

// The different operators are used like choices, and wrapped accordingly
Expression_PrefixExpression_Operator: Expression_PrefixExpression_Operator = {
    <operator: PlusPlus>  => new_expression_prefix_expression_operator_plus_plus(<>),
    <operator: MinusMinus>  => new_expression_prefix_expression_operator_minus_minus(<>),
    <operator: Tilde>  => new_expression_prefix_expression_operator_tilde(<>),
    <operator: Bang>  => new_expression_prefix_expression_operator_bang(<>),
    <operator: Minus>  => new_expression_prefix_expression_operator_minus(<>),
    <operator: DeleteKeyword>  => new_expression_prefix_expression_operator_delete_keyword(<>),
};
Expression_PostfixExpression_Operator: Expression_PostfixExpression_Operator = {
    <operator: PlusPlus>  => new_expression_postfix_expression_operator_plus_plus(<>),
    <operator: MinusMinus>  => new_expression_postfix_expression_operator_minus_minus(<>),
};
Expression_ExponentiationExpression_Operator: Expression_ExponentiationExpression_Operator = {
    <operator: AsteriskAsterisk>  => new_expression_exponentiation_expression_operator_asterisk_asterisk(<>),
};
Expression_MultiplicativeExpression_Operator: Expression_MultiplicativeExpression_Operator = {
    <operator: Asterisk>  => new_expression_multiplicative_expression_operator_asterisk(<>),
    <operator: Slash>  => new_expression_multiplicative_expression_operator_slash(<>),
    <operator: Percent>  => new_expression_multiplicative_expression_operator_percent(<>),
};
Expression_AdditiveExpression_Operator: Expression_AdditiveExpression_Operator = {
    <operator: Plus>  => new_expression_additive_expression_operator_plus(<>),
    <operator: Minus>  => new_expression_additive_expression_operator_minus(<>),
};
Expression_ShiftExpression_Operator: Expression_ShiftExpression_Operator = {
    <operator: LessThanLessThan>  => new_expression_shift_expression_operator_less_than_less_than(<>),
    <operator: GreaterThanGreaterThan>  => new_expression_shift_expression_operator_greater_than_greater_than(<>),
    <operator: GreaterThanGreaterThanGreaterThan>  => new_expression_shift_expression_operator_greater_than_greater_than_greater_than(<>),
};
Expression_InequalityExpression_Operator: Expression_InequalityExpression_Operator = {
    <operator: LessThan>  => new_expression_inequality_expression_operator_less_than(<>),
    <operator: GreaterThan>  => new_expression_inequality_expression_operator_greater_than(<>),
    <operator: LessThanEqual>  => new_expression_inequality_expression_operator_less_than_equal(<>),
    <operator: GreaterThanEqual>  => new_expression_inequality_expression_operator_greater_than_equal(<>),
};
Expression_EqualityExpression_Operator: Expression_EqualityExpression_Operator = {
    <operator: EqualEqual>  => new_expression_equality_expression_operator_equal_equal(<>),
    <operator: BangEqual>  => new_expression_equality_expression_operator_bang_equal(<>),
};
Expression_AssignmentExpression_Operator: Expression_AssignmentExpression_Operator = {
    <operator: Equal>  => new_expression_assignment_expression_operator_equal(<>),
    <operator: BarEqual>  => new_expression_assignment_expression_operator_bar_equal(<>),
    <operator: PlusEqual>  => new_expression_assignment_expression_operator_plus_equal(<>),
    <operator: MinusEqual>  => new_expression_assignment_expression_operator_minus_equal(<>),
    <operator: CaretEqual>  => new_expression_assignment_expression_operator_caret_equal(<>),
    <operator: SlashEqual>  => new_expression_assignment_expression_operator_slash_equal(<>),
    <operator: PercentEqual>  => new_expression_assignment_expression_operator_percent_equal(<>),
    <operator: AsteriskEqual>  => new_expression_assignment_expression_operator_asterisk_equal(<>),
    <operator: AmpersandEqual>  => new_expression_assignment_expression_operator_ampersand_equal(<>),
    <operator: LessThanLessThanEqual>  => new_expression_assignment_expression_operator_less_than_less_than_equal(<>),
    <operator: GreaterThanGreaterThanEqual>  => new_expression_assignment_expression_operator_greater_than_greater_than_equal(<>),
    <operator: GreaterThanGreaterThanGreaterThanEqual>  => new_expression_assignment_expression_operator_greater_than_greater_than_greater_than_equal(<>),
};

// A rule matching en empty `IdentifierPath`
NoIdentPath: IdentifierPath = {};

// An Index Access Path that is parametric over the IdentifierPath rule used for member access and index access
IndexAccessPath<IdentPathRule>: IndexAccessPath = {
    // As before, we usually care about trailing constructs, so the brackets serve as markers to reset the parametric rule
    <iap: IndexAccessPath<IdentifierPath>> <open_bracket: OpenBracket>  <start: (Expression)?>  <end: (IndexAccessEnd)?>  <close_bracket: CloseBracket>  => index_access_path_add_index(<>),
    <IndexAccessPath1<IdentPathRule>>  => <>,
};
IndexAccessPath1<IdentPathRule>: IndexAccessPath = {
    <identifier: IdentPathRule> => new_index_access_path_from_identifier_path(<>),
    <elementary_type: ElementaryType>  => new_index_access_path_from_elementary_type(<>),
};

    IndexAccessEnd: IndexAccessEnd = {
        <colon: Colon>  <end: (Expression)?>  => new_index_access_end(<>),
        
    };
    

// Rules for topic Function Calls
    ArgumentsDeclaration: ArgumentsDeclaration = {
        <positional_arguments_declaration: PositionalArgumentsDeclaration>  => new_arguments_declaration_positional_arguments_declaration(<>),
        <named_arguments_declaration: NamedArgumentsDeclaration>  => new_arguments_declaration_named_arguments_declaration(<>),
        
    };
    PositionalArgumentsDeclaration: PositionalArgumentsDeclaration = {
        <open_paren: OpenParen>  <arguments: PositionalArguments>  <close_paren: CloseParen>  => new_positional_arguments_declaration(<>),
        
    };
    PositionalArguments: PositionalArguments = {
        <expression: SeparatedAllowEmpty<Comma, <Expression>>>  => new_positional_arguments(<>),
        
    };
    NamedArgumentsDeclaration: NamedArgumentsDeclaration = {
        <open_paren: OpenParen>  <arguments: NamedArgumentGroup>  <close_paren: CloseParen>  => new_named_arguments_declaration(<>),
        
    };
    NamedArgumentGroup: NamedArgumentGroup = {
        <open_brace: OpenBrace>  <arguments: NamedArguments>  <close_brace: CloseBrace>  => new_named_argument_group(<>),
        
    };
    NamedArguments: NamedArguments = {
        <named_argument: SeparatedAllowEmpty<Comma, <NamedArgument>>>  => new_named_arguments(<>),
        
    };
    CallOptions: CallOptions = {
        <named_argument: Separated<Comma, <NamedArgument>>>  => new_call_options(<>),
        
    };
    NamedArgument: NamedArgument = {
        <name: Identifier>  <colon: Colon>  <value: Expression>  => new_named_argument(<>),
        
    };
    

// Rules for topic Primary Expressions
    TypeExpression: TypeExpression = {
        <type_keyword: TypeKeyword>  <open_paren: OpenParen>  <type_name: TypeName>  <close_paren: CloseParen>  => new_type_expression(<>),
        
    };
    
    
// We avoid function types entirely in new expressions, this is ok since they're not allowed
// in Solidity, but the error will be syntactic rather than semantic, which may be confusing.
//
// We do this to avoid the amibiguity of `try new function () returns (uint) ...`, where the returns clause may be
// parsed either as part of the function type or as part of a try statement.
NewExpression: NewExpression = {
    <new_keyword: NewKeyword>  <type_name: TypeName1<NoFunctionType, IndexAccessPath<IdentifierPath>>>  => new_new_expression(<>),
    
};

NoFunctionType: FunctionType = {};

    TupleExpression: TupleExpression = {
        <open_paren: OpenParen>  <items: TupleValues>  <close_paren: CloseParen>  => new_tuple_expression(<>),
        
    };
    
    
// See the comment around TupleDeconstructionStatement for an explanation of this rule.
#[inline]
TupleValues: TupleValues = {
    <prefix: TuplePrefix> => {
        // We need to add an extra empty element here, since the trailing comma indicates
        // an additional empty tuple value.
        let elements = vec![new_tuple_value(None); prefix + 1];
        new_tuple_values(elements)
    },
    <prefix: TuplePrefix> <differentiator: Expression> <tuple_value: (Comma <Separated<Comma, <TupleValue>>>)?>  => {
        let mut elements = vec![new_tuple_value(None); prefix];
        elements.push(new_tuple_value(Some(differentiator)));
        elements.extend(tuple_value.unwrap_or(vec![]));
        new_tuple_values(elements)
    },
    
};

    TupleValue: TupleValue = {
        <expression: (Expression)?>  => new_tuple_value(<>),
        
    };
    ArrayExpression: ArrayExpression = {
        <open_bracket: OpenBracket>  <items: ArrayValues>  <close_bracket: CloseBracket>  => new_array_expression(<>),
        
    };
    ArrayValues: ArrayValues = {
        <expression: Separated<Comma, <Expression>>>  => new_array_values(<>),
        
    };
    

// Rules for topic Numbers
    
    
// This rule shouldn't be manual, but the node constructor takes an optional argument that is not
// enabled in 0.8.30, therefore we don't have it automatically generated
HexNumberExpression: HexNumberExpression = {
        <literal: HexLiteral>  => new_hex_number_expression(<>, None),
};
    DecimalNumberExpression: DecimalNumberExpression = {
        <literal: DecimalLiteral>  <unit: (NumberUnit)?>  => new_decimal_number_expression(<>),
        
    };
    NumberUnit: NumberUnit = {
        <wei_keyword: WeiKeyword>  => new_number_unit_wei_keyword(<>),
        <gwei_keyword: GweiKeyword>  => new_number_unit_gwei_keyword(<>),
        <ether_keyword: EtherKeyword>  => new_number_unit_ether_keyword(<>),
        <seconds_keyword: SecondsKeyword>  => new_number_unit_seconds_keyword(<>),
        <minutes_keyword: MinutesKeyword>  => new_number_unit_minutes_keyword(<>),
        <hours_keyword: HoursKeyword>  => new_number_unit_hours_keyword(<>),
        <days_keyword: DaysKeyword>  => new_number_unit_days_keyword(<>),
        <weeks_keyword: WeeksKeyword>  => new_number_unit_weeks_keyword(<>),
        
    };
    

// Rules for topic Strings
    StringExpression: StringExpression = {
        <string_literals: StringLiterals>  => new_string_expression_string_literals(<>),
        <hex_string_literals: HexStringLiterals>  => new_string_expression_hex_string_literals(<>),
        <unicode_string_literals: UnicodeStringLiterals>  => new_string_expression_unicode_string_literals(<>),
        
    };
    StringLiterals: StringLiterals = {
        <string_literal: Repeated<<StringLiteral>>>  => new_string_literals(<>),
        
    };
    StringLiteral: StringLiteral = {
        <single_quoted_string_literal: SingleQuotedStringLiteral>  => new_string_literal_single_quoted_string_literal(<>),
        <double_quoted_string_literal: DoubleQuotedStringLiteral>  => new_string_literal_double_quoted_string_literal(<>),
        
    };
    HexStringLiterals: HexStringLiterals = {
        <hex_string_literal: Repeated<<HexStringLiteral>>>  => new_hex_string_literals(<>),
        
    };
    HexStringLiteral: HexStringLiteral = {
        <single_quoted_hex_string_literal: SingleQuotedHexStringLiteral>  => new_hex_string_literal_single_quoted_hex_string_literal(<>),
        <double_quoted_hex_string_literal: DoubleQuotedHexStringLiteral>  => new_hex_string_literal_double_quoted_hex_string_literal(<>),
        
    };
    UnicodeStringLiterals: UnicodeStringLiterals = {
        <unicode_string_literal: Repeated<<UnicodeStringLiteral>>>  => new_unicode_string_literals(<>),
        
    };
    UnicodeStringLiteral: UnicodeStringLiteral = {
        <single_quoted_unicode_string_literal: SingleQuotedUnicodeStringLiteral>  => new_unicode_string_literal_single_quoted_unicode_string_literal(<>),
        <double_quoted_unicode_string_literal: DoubleQuotedUnicodeStringLiteral>  => new_unicode_string_literal_double_quoted_unicode_string_literal(<>),
        
    };
    

// Rules for topic Identifiers
    
    
// We need to force this to differentiate the first element from not being
// an `AddressKeyword`
IdentifierPath: IdentifierPath = {
    <head: Identifier>  <tail: (IdentifierPathTail)?>  => {
        match tail {
            Some(mut tail) => {
                tail.insert(0, new_identifier_path_element_identifier(head));
                new_identifier_path(tail)
            },
            None => new_identifier_path(vec![new_identifier_path_element_identifier(head)]),
        }
    },
    
};
IdentifierPathTail: Vec<IdentifierPathElement> = {
    Period  <elements: IdentifierPathTailElements>  => <>,
    
};
IdentifierPathTailElements: Vec<IdentifierPathElement> = {
    <member_access_identifier: Separated<Period, <IdentifierPathElement>>>  => <>,
    
};

    IdentifierPathElement: IdentifierPathElement = {
        <identifier: Identifier>  => new_identifier_path_element_identifier(<>),
        <address_keyword: AddressKeyword>  => new_identifier_path_element_address_keyword(<>),
        
    };
    




// Rules for section Yul

// Rules for topic Yul Statements
    
    
YulBlock: YulBlock = {
    <open_brace: OpenBrace>  !  <close_brace: CloseBrace>  => {
        new_yul_block(open_brace, new_yul_statements(vec![]), close_brace)
    }
};

    YulStatements: YulStatements = {
        <yul_statement: RepeatedAllowEmpty<<YulStatement>>>  => new_yul_statements(<>),
        
    };
    YulStatement: YulStatement = {
        <yul_block: YulBlock>  => new_yul_statement_yul_block(<>),
        <yul_function_definition: YulFunctionDefinition>  => new_yul_statement_yul_function_definition(<>),
        <yul_if_statement: YulIfStatement>  => new_yul_statement_yul_if_statement(<>),
        <yul_for_statement: YulForStatement>  => new_yul_statement_yul_for_statement(<>),
        <yul_switch_statement: YulSwitchStatement>  => new_yul_statement_yul_switch_statement(<>),
        <yul_leave_statement: YulLeaveStatement>  => new_yul_statement_yul_leave_statement(<>),
        <yul_break_statement: YulBreakStatement>  => new_yul_statement_yul_break_statement(<>),
        <yul_continue_statement: YulContinueStatement>  => new_yul_statement_yul_continue_statement(<>),
        <yul_variable_assignment_statement: YulVariableAssignmentStatement>  => new_yul_statement_yul_variable_assignment_statement(<>),
        <yul_variable_declaration_statement: YulVariableDeclarationStatement>  => new_yul_statement_yul_variable_declaration_statement(<>),
        <yul_expression: YulExpression>  => new_yul_statement_yul_expression(<>),
        
    };
    YulFunctionDefinition: YulFunctionDefinition = {
        <function_keyword: YulFunctionKeyword>  <name: YulIdentifier>  <parameters: YulParametersDeclaration>  <returns: (YulReturnsDeclaration)?>  <body: YulBlock>  => new_yul_function_definition(<>),
        
    };
    YulParametersDeclaration: YulParametersDeclaration = {
        <open_paren: OpenParen>  <parameters: YulParameters>  <close_paren: CloseParen>  => new_yul_parameters_declaration(<>),
        
    };
    YulParameters: YulParameters = {
        <yul_identifier: SeparatedAllowEmpty<Comma, <YulIdentifier>>>  => new_yul_parameters(<>),
        
    };
    YulReturnsDeclaration: YulReturnsDeclaration = {
        <minus_greater_than: MinusGreaterThan>  <variables: YulVariableNames>  => new_yul_returns_declaration(<>),
        
    };
    YulVariableNames: YulVariableNames = {
        <yul_identifier: Separated<Comma, <YulIdentifier>>>  => new_yul_variable_names(<>),
        
    };
    YulVariableDeclarationStatement: YulVariableDeclarationStatement = {
        <let_keyword: YulLetKeyword>  <variables: YulVariableNames>  <value: (YulVariableDeclarationValue)?>  => new_yul_variable_declaration_statement(<>),
        
    };
    YulVariableDeclarationValue: YulVariableDeclarationValue = {
        <assignment: YulAssignmentOperator>  <expression: YulExpression>  => new_yul_variable_declaration_value(<>),
        
    };
    YulVariableAssignmentStatement: YulVariableAssignmentStatement = {
        <variables: YulPaths>  <assignment: YulAssignmentOperator>  <expression: YulExpression>  => new_yul_variable_assignment_statement(<>),
        
    };
    YulAssignmentOperator: YulAssignmentOperator = {
        <colon_equal: ColonEqual>  => new_yul_assignment_operator_colon_equal(<>),
        
    };
    YulIfStatement: YulIfStatement = {
        <if_keyword: YulIfKeyword>  <condition: YulExpression>  <body: YulBlock>  => new_yul_if_statement(<>),
        
    };
    YulForStatement: YulForStatement = {
        <for_keyword: YulForKeyword>  <initialization: YulBlock>  <condition: YulExpression>  <iterator: YulBlock>  <body: YulBlock>  => new_yul_for_statement(<>),
        
    };
    YulSwitchStatement: YulSwitchStatement = {
        <switch_keyword: YulSwitchKeyword>  <expression: YulExpression>  <cases: YulSwitchCases>  => new_yul_switch_statement(<>),
        
    };
    YulSwitchCases: YulSwitchCases = {
        <yul_switch_case: Repeated<<YulSwitchCase>>>  => new_yul_switch_cases(<>),
        
    };
    YulSwitchCase: YulSwitchCase = {
        <yul_default_case: YulDefaultCase>  => new_yul_switch_case_yul_default_case(<>),
        <yul_value_case: YulValueCase>  => new_yul_switch_case_yul_value_case(<>),
        
    };
    YulDefaultCase: YulDefaultCase = {
        <default_keyword: YulDefaultKeyword>  <body: YulBlock>  => new_yul_default_case(<>),
        
    };
    YulValueCase: YulValueCase = {
        <case_keyword: YulCaseKeyword>  <value: YulLiteral>  <body: YulBlock>  => new_yul_value_case(<>),
        
    };
    YulLeaveStatement: YulLeaveStatement = {
        <leave_keyword: YulLeaveKeyword>  => new_yul_leave_statement(<>),
        
    };
    YulBreakStatement: YulBreakStatement = {
        <break_keyword: YulBreakKeyword>  => new_yul_break_statement(<>),
        
    };
    YulContinueStatement: YulContinueStatement = {
        <continue_keyword: YulContinueKeyword>  => new_yul_continue_statement(<>),
        
    };
    

// Rules for topic Yul Expressions
    YulExpression0: YulExpression = {
        <yul_literal: YulLiteral>  => new_yul_expression_yul_literal(<>),
        <yul_path: YulPath>  => new_yul_expression_yul_path(<>),
        
    };
    #[inline]
    YulFunctionCallExpression: YulFunctionCallExpression = {
        <yul_expression: YulExpression1>  <open_paren: OpenParen>  <arguments: YulArguments>  <close_paren: CloseParen>  => new_yul_function_call_expression(<>),
        
    };
    YulExpression1: YulExpression = {
        <yul_expression: YulFunctionCallExpression>  => new_yul_expression_yul_function_call_expression(<>),
        <yul_expression: YulExpression0>  => <>,
        
    };
    YulExpression: YulExpression = {
        <yul_expression: YulExpression1>  => <>,
        
    };
    YulArguments: YulArguments = {
        <yul_expression: SeparatedAllowEmpty<Comma, <YulExpression>>>  => new_yul_arguments(<>),
        
    };
    YulPaths: YulPaths = {
        <yul_path: Separated<Comma, <YulPath>>>  => new_yul_paths(<>),
        
    };
    YulPath: YulPath = {
        <yul_identifier: Separated<Period, <YulIdentifier>>>  => new_yul_path(<>),
        
    };
    YulLiteral: YulLiteral = {
        <yul_true_keyword: YulTrueKeyword>  => new_yul_literal_yul_true_keyword(<>),
        <yul_false_keyword: YulFalseKeyword>  => new_yul_literal_yul_false_keyword(<>),
        <yul_decimal_literal: YulDecimalLiteral>  => new_yul_literal_yul_decimal_literal(<>),
        <yul_hex_literal: YulHexLiteral>  => new_yul_literal_yul_hex_literal(<>),
        <hex_string_literal: HexStringLiteral>  => new_yul_literal_hex_string_literal(<>),
        <string_literal: StringLiteral>  => new_yul_literal_string_literal(<>),
        
    };
    

// Rules for topic Yul Keywords
    






// Lexemes formatting
//
// A given terminal can actually match against multiple lexemes,
// so we generate a rule per terminal that matches against all its lexemes.
//
// An example is `YulIdentifier` which matches the `L_YulIdentifier` lexeme,
// but also all the unreserved keywords that are valid Yul identifiers.
#[inline]
ABIEncoderV2Keyword: ABIEncoderV2Keyword = {

        <l:@L> L_ABIEncoderV2Keyword_Reserved <r:@L> => new_abi_encoder_v2_keyword(l..r, source),

};
#[inline]
AbicoderKeyword: AbicoderKeyword = {

        <l:@L> L_AbicoderKeyword_Reserved <r:@L> => new_abicoder_keyword(l..r, source),

};
#[inline]
AbicoderV1Keyword: AbicoderV1Keyword = {

        <l:@L> L_AbicoderV1Keyword_Reserved <r:@L> => new_abicoder_v1_keyword(l..r, source),

};
#[inline]
AbicoderV2Keyword: AbicoderV2Keyword = {

        <l:@L> L_AbicoderV2Keyword_Reserved <r:@L> => new_abicoder_v2_keyword(l..r, source),

};
#[inline]
AbstractKeyword: AbstractKeyword = {

        <l:@L> L_AbstractKeyword_Reserved <r:@L> => new_abstract_keyword(l..r, source),

};
#[inline]
AddressKeyword: AddressKeyword = {

        <l:@L> L_AddressKeyword_Reserved <r:@L> => new_address_keyword(l..r, source),

};
#[inline]
AfterKeyword: AfterKeyword = {

        <l:@L> L_AfterKeyword_Reserved <r:@L> => new_after_keyword(l..r, source),

};
#[inline]
AliasKeyword: AliasKeyword = {

        <l:@L> L_AliasKeyword_Reserved <r:@L> => new_alias_keyword(l..r, source),

};
#[inline]
Ampersand: Ampersand = {

        <l:@L> L_Ampersand <r:@L> => new_ampersand(l..r, source),

};
#[inline]
AmpersandAmpersand: AmpersandAmpersand = {

        <l:@L> L_AmpersandAmpersand <r:@L> => new_ampersand_ampersand(l..r, source),

};
#[inline]
AmpersandEqual: AmpersandEqual = {

        <l:@L> L_AmpersandEqual <r:@L> => new_ampersand_equal(l..r, source),

};
#[inline]
AnonymousKeyword: AnonymousKeyword = {

        <l:@L> L_AnonymousKeyword_Reserved <r:@L> => new_anonymous_keyword(l..r, source),

};
#[inline]
ApplyKeyword: ApplyKeyword = {

        <l:@L> L_ApplyKeyword_Reserved <r:@L> => new_apply_keyword(l..r, source),

};
#[inline]
AsKeyword: AsKeyword = {

        <l:@L> L_AsKeyword_Reserved <r:@L> => new_as_keyword(l..r, source),

};
#[inline]
AssemblyKeyword: AssemblyKeyword = {

        <l:@L> L_AssemblyKeyword_Reserved <r:@L> => new_assembly_keyword(l..r, source),

};
#[inline]
Asterisk: Asterisk = {

        <l:@L> L_Asterisk <r:@L> => new_asterisk(l..r, source),

};
#[inline]
AsteriskAsterisk: AsteriskAsterisk = {

        <l:@L> L_AsteriskAsterisk <r:@L> => new_asterisk_asterisk(l..r, source),

};
#[inline]
AsteriskEqual: AsteriskEqual = {

        <l:@L> L_AsteriskEqual <r:@L> => new_asterisk_equal(l..r, source),

};
#[inline]
AtKeyword: AtKeyword = {

        <l:@L> L_AtKeyword_Unreserved <r:@L> => new_at_keyword(l..r, source),

};
#[inline]
AutoKeyword: AutoKeyword = {

        <l:@L> L_AutoKeyword_Reserved <r:@L> => new_auto_keyword(l..r, source),

};
#[inline]
Bang: Bang = {

        <l:@L> L_Bang <r:@L> => new_bang(l..r, source),

};
#[inline]
BangEqual: BangEqual = {

        <l:@L> L_BangEqual <r:@L> => new_bang_equal(l..r, source),

};
#[inline]
Bar: Bar = {

        <l:@L> L_Bar <r:@L> => new_bar(l..r, source),

};
#[inline]
BarBar: BarBar = {

        <l:@L> L_BarBar <r:@L> => new_bar_bar(l..r, source),

};
#[inline]
BarEqual: BarEqual = {

        <l:@L> L_BarEqual <r:@L> => new_bar_equal(l..r, source),

};
#[inline]
BoolKeyword: BoolKeyword = {

        <l:@L> L_BoolKeyword_Reserved <r:@L> => new_bool_keyword(l..r, source),

};
#[inline]
BreakKeyword: BreakKeyword = {

        <l:@L> L_BreakKeyword_Reserved <r:@L> => new_break_keyword(l..r, source),

};
#[inline]
ByteKeyword: ByteKeyword = {

        <l:@L> L_ByteKeyword_Reserved <r:@L> => new_byte_keyword(l..r, source),

};
#[inline]
BytesKeyword: BytesKeyword = {

        <l:@L> L_BytesKeyword_Reserved <r:@L> => new_bytes_keyword(l..r, source),

};
#[inline]
CallDataKeyword: CallDataKeyword = {

        <l:@L> L_CallDataKeyword_Reserved <r:@L> => new_call_data_keyword(l..r, source),

};
#[inline]
Caret: Caret = {

        <l:@L> L_Caret <r:@L> => new_caret(l..r, source),

};
#[inline]
CaretEqual: CaretEqual = {

        <l:@L> L_CaretEqual <r:@L> => new_caret_equal(l..r, source),

};
#[inline]
CaseKeyword: CaseKeyword = {

        <l:@L> L_CaseKeyword_Reserved <r:@L> => new_case_keyword(l..r, source),

};
#[inline]
CatchKeyword: CatchKeyword = {

        <l:@L> L_CatchKeyword_Reserved <r:@L> => new_catch_keyword(l..r, source),

};
#[inline]
CloseBrace: CloseBrace = {

        <l:@L> L_CloseBrace <r:@L> => new_close_brace(l..r, source),

};
#[inline]
CloseBracket: CloseBracket = {

        <l:@L> L_CloseBracket <r:@L> => new_close_bracket(l..r, source),

};
#[inline]
CloseParen: CloseParen = {

        <l:@L> L_CloseParen <r:@L> => new_close_paren(l..r, source),

};
#[inline]
Colon: Colon = {

        <l:@L> L_Colon <r:@L> => new_colon(l..r, source),

};
#[inline]
ColonEqual: ColonEqual = {

        <l:@L> L_ColonEqual <r:@L> => new_colon_equal(l..r, source),

};
#[inline]
Comma: Comma = {

        <l:@L> L_Comma <r:@L> => new_comma(l..r, source),

};
#[inline]
ConstantKeyword: ConstantKeyword = {

        <l:@L> L_ConstantKeyword_Reserved <r:@L> => new_constant_keyword(l..r, source),

};
#[inline]
ConstructorKeyword: ConstructorKeyword = {

        <l:@L> L_ConstructorKeyword_Reserved <r:@L> => new_constructor_keyword(l..r, source),

};
#[inline]
ContinueKeyword: ContinueKeyword = {

        <l:@L> L_ContinueKeyword_Reserved <r:@L> => new_continue_keyword(l..r, source),

};
#[inline]
ContractKeyword: ContractKeyword = {

        <l:@L> L_ContractKeyword_Reserved <r:@L> => new_contract_keyword(l..r, source),

};
#[inline]
CopyOfKeyword: CopyOfKeyword = {

        <l:@L> L_CopyOfKeyword_Reserved <r:@L> => new_copy_of_keyword(l..r, source),

};
#[inline]
DaysKeyword: DaysKeyword = {

        <l:@L> L_DaysKeyword_Reserved <r:@L> => new_days_keyword(l..r, source),

};
#[inline]
DecimalLiteral: DecimalLiteral = {

        <l:@L> L_DecimalLiteral <r:@L> => new_decimal_literal(l..r, source),

};
#[inline]
DefaultKeyword: DefaultKeyword = {

        <l:@L> L_DefaultKeyword_Reserved <r:@L> => new_default_keyword(l..r, source),

};
#[inline]
DefineKeyword: DefineKeyword = {

        <l:@L> L_DefineKeyword_Reserved <r:@L> => new_define_keyword(l..r, source),

};
#[inline]
DeleteKeyword: DeleteKeyword = {

        <l:@L> L_DeleteKeyword_Reserved <r:@L> => new_delete_keyword(l..r, source),

};
#[inline]
DoKeyword: DoKeyword = {

        <l:@L> L_DoKeyword_Reserved <r:@L> => new_do_keyword(l..r, source),

};
#[inline]
DoubleQuotedHexStringLiteral: DoubleQuotedHexStringLiteral = {

        <l:@L> L_DoubleQuotedHexStringLiteral <r:@L> => new_double_quoted_hex_string_literal(l..r, source),

};
#[inline]
DoubleQuotedStringLiteral: DoubleQuotedStringLiteral = {

        <l:@L> L_DoubleQuotedStringLiteral <r:@L> => new_double_quoted_string_literal(l..r, source),

};
#[inline]
DoubleQuotedUnicodeStringLiteral: DoubleQuotedUnicodeStringLiteral = {

        <l:@L> L_DoubleQuotedUnicodeStringLiteral <r:@L> => new_double_quoted_unicode_string_literal(l..r, source),

};
#[inline]
DoubleQuotedVersionLiteral: DoubleQuotedVersionLiteral = {

        <l:@L> L_DoubleQuotedVersionLiteral <r:@L> => new_double_quoted_version_literal(l..r, source),

};
#[inline]
ElseKeyword: ElseKeyword = {

        <l:@L> L_ElseKeyword_Reserved <r:@L> => new_else_keyword(l..r, source),

};
#[inline]
EmitKeyword: EmitKeyword = {

        <l:@L> L_EmitKeyword_Reserved <r:@L> => new_emit_keyword(l..r, source),

};
#[inline]
EndOfLine: EndOfLine = {

        <l:@L> L_EndOfLine <r:@L> => new_end_of_line(l..r, source),

};
#[inline]
EnumKeyword: EnumKeyword = {

        <l:@L> L_EnumKeyword_Reserved <r:@L> => new_enum_keyword(l..r, source),

};
#[inline]
Equal: Equal = {

        <l:@L> L_Equal <r:@L> => new_equal(l..r, source),

};
#[inline]
EqualColon: EqualColon = {

        <l:@L> L_EqualColon <r:@L> => new_equal_colon(l..r, source),

};
#[inline]
EqualEqual: EqualEqual = {

        <l:@L> L_EqualEqual <r:@L> => new_equal_equal(l..r, source),

};
#[inline]
EqualGreaterThan: EqualGreaterThan = {

        <l:@L> L_EqualGreaterThan <r:@L> => new_equal_greater_than(l..r, source),

};
#[inline]
ErrorKeyword: ErrorKeyword = {

        <l:@L> L_ErrorKeyword_Unreserved <r:@L> => new_error_keyword(l..r, source),

};
#[inline]
EtherKeyword: EtherKeyword = {

        <l:@L> L_EtherKeyword_Reserved <r:@L> => new_ether_keyword(l..r, source),

};
#[inline]
EventKeyword: EventKeyword = {

        <l:@L> L_EventKeyword_Reserved <r:@L> => new_event_keyword(l..r, source),

};
#[inline]
ExperimentalKeyword: ExperimentalKeyword = {

        <l:@L> L_ExperimentalKeyword_Reserved <r:@L> => new_experimental_keyword(l..r, source),

};
#[inline]
ExternalKeyword: ExternalKeyword = {

        <l:@L> L_ExternalKeyword_Reserved <r:@L> => new_external_keyword(l..r, source),

};
#[inline]
FallbackKeyword: FallbackKeyword = {

        <l:@L> L_FallbackKeyword_Reserved <r:@L> => new_fallback_keyword(l..r, source),

};
#[inline]
FalseKeyword: FalseKeyword = {

        <l:@L> L_FalseKeyword_Reserved <r:@L> => new_false_keyword(l..r, source),

};
#[inline]
FinalKeyword: FinalKeyword = {

        <l:@L> L_FinalKeyword_Reserved <r:@L> => new_final_keyword(l..r, source),

};
#[inline]
FinneyKeyword: FinneyKeyword = {

        <l:@L> L_FinneyKeyword_Unreserved <r:@L> => new_finney_keyword(l..r, source),

};
#[inline]
FixedKeyword: FixedKeyword = {

        <l:@L> L_FixedKeyword_Reserved <r:@L> => new_fixed_keyword(l..r, source),

};
#[inline]
ForKeyword: ForKeyword = {

        <l:@L> L_ForKeyword_Reserved <r:@L> => new_for_keyword(l..r, source),

};
#[inline]
FromKeyword: FromKeyword = {

        <l:@L> L_FromKeyword_Unreserved <r:@L> => new_from_keyword(l..r, source),

};
#[inline]
FunctionKeyword: FunctionKeyword = {

        <l:@L> L_FunctionKeyword_Reserved <r:@L> => new_function_keyword(l..r, source),

};
#[inline]
GlobalKeyword: GlobalKeyword = {

        <l:@L> L_GlobalKeyword_Unreserved <r:@L> => new_global_keyword(l..r, source),

};
#[inline]
GreaterThan: GreaterThan = {

        <l:@L> L_GreaterThan <r:@L> => new_greater_than(l..r, source),

};
#[inline]
GreaterThanEqual: GreaterThanEqual = {

        <l:@L> L_GreaterThanEqual <r:@L> => new_greater_than_equal(l..r, source),

};
#[inline]
GreaterThanGreaterThan: GreaterThanGreaterThan = {

        <l:@L> L_GreaterThanGreaterThan <r:@L> => new_greater_than_greater_than(l..r, source),

};
#[inline]
GreaterThanGreaterThanEqual: GreaterThanGreaterThanEqual = {

        <l:@L> L_GreaterThanGreaterThanEqual <r:@L> => new_greater_than_greater_than_equal(l..r, source),

};
#[inline]
GreaterThanGreaterThanGreaterThan: GreaterThanGreaterThanGreaterThan = {

        <l:@L> L_GreaterThanGreaterThanGreaterThan <r:@L> => new_greater_than_greater_than_greater_than(l..r, source),

};
#[inline]
GreaterThanGreaterThanGreaterThanEqual: GreaterThanGreaterThanGreaterThanEqual = {

        <l:@L> L_GreaterThanGreaterThanGreaterThanEqual <r:@L> => new_greater_than_greater_than_greater_than_equal(l..r, source),

};
#[inline]
GweiKeyword: GweiKeyword = {

        <l:@L> L_GweiKeyword_Reserved <r:@L> => new_gwei_keyword(l..r, source),

};
#[inline]
HexKeyword: HexKeyword = {

        <l:@L> L_HexKeyword_Reserved <r:@L> => new_hex_keyword(l..r, source),

};
#[inline]
HexLiteral: HexLiteral = {

        <l:@L> L_HexLiteral <r:@L> => new_hex_literal(l..r, source),

};
#[inline]
HoursKeyword: HoursKeyword = {

        <l:@L> L_HoursKeyword_Reserved <r:@L> => new_hours_keyword(l..r, source),

};
#[inline]
Identifier: Identifier = {
    SomeIdentifier<""> => <>,
};

// Making an Identifier inline generates an explosion of states, so DON'T
//
// We allow to pass parameters for certain tokens that are disallowed,
// this is an easy way to express "Any identifier except `X`" as `SomeIdentifier<"X">`
SomeIdentifier<Except>: Identifier = {

        <l:@L> L_AtKeyword_Unreserved <r:@L> if Except !~ "AtKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_ErrorKeyword_Unreserved <r:@L> if Except !~ "ErrorKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_FinneyKeyword_Unreserved <r:@L> if Except !~ "FinneyKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_FromKeyword_Unreserved <r:@L> if Except !~ "FromKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_GlobalKeyword_Unreserved <r:@L> if Except !~ "GlobalKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_Identifier <r:@L> if Except !~ "Identifier" => new_identifier(l..r, source),

        <l:@L> L_LayoutKeyword_Unreserved <r:@L> if Except !~ "LayoutKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_RevertKeyword_Unreserved <r:@L> if Except !~ "RevertKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_SzaboKeyword_Unreserved <r:@L> if Except !~ "SzaboKeyword_Unreserved" => new_identifier(l..r, source),

        <l:@L> L_TransientKeyword_Unreserved <r:@L> if Except !~ "TransientKeyword_Unreserved" => new_identifier(l..r, source),

};
#[inline]
IfKeyword: IfKeyword = {

        <l:@L> L_IfKeyword_Reserved <r:@L> => new_if_keyword(l..r, source),

};
#[inline]
ImmutableKeyword: ImmutableKeyword = {

        <l:@L> L_ImmutableKeyword_Reserved <r:@L> => new_immutable_keyword(l..r, source),

};
#[inline]
ImplementsKeyword: ImplementsKeyword = {

        <l:@L> L_ImplementsKeyword_Reserved <r:@L> => new_implements_keyword(l..r, source),

};
#[inline]
ImportKeyword: ImportKeyword = {

        <l:@L> L_ImportKeyword_Reserved <r:@L> => new_import_keyword(l..r, source),

};
#[inline]
InKeyword: InKeyword = {

        <l:@L> L_InKeyword_Reserved <r:@L> => new_in_keyword(l..r, source),

};
#[inline]
IndexedKeyword: IndexedKeyword = {

        <l:@L> L_IndexedKeyword_Reserved <r:@L> => new_indexed_keyword(l..r, source),

};
#[inline]
InlineKeyword: InlineKeyword = {

        <l:@L> L_InlineKeyword_Reserved <r:@L> => new_inline_keyword(l..r, source),

};
#[inline]
IntKeyword: IntKeyword = {

        <l:@L> L_IntKeyword_Reserved <r:@L> => new_int_keyword(l..r, source),

};
#[inline]
InterfaceKeyword: InterfaceKeyword = {

        <l:@L> L_InterfaceKeyword_Reserved <r:@L> => new_interface_keyword(l..r, source),

};
#[inline]
InternalKeyword: InternalKeyword = {

        <l:@L> L_InternalKeyword_Reserved <r:@L> => new_internal_keyword(l..r, source),

};
#[inline]
IsKeyword: IsKeyword = {

        <l:@L> L_IsKeyword_Reserved <r:@L> => new_is_keyword(l..r, source),

};
#[inline]
LayoutKeyword: LayoutKeyword = {

        <l:@L> L_LayoutKeyword_Unreserved <r:@L> => new_layout_keyword(l..r, source),

};
#[inline]
LessThan: LessThan = {

        <l:@L> L_LessThan <r:@L> => new_less_than(l..r, source),

};
#[inline]
LessThanEqual: LessThanEqual = {

        <l:@L> L_LessThanEqual <r:@L> => new_less_than_equal(l..r, source),

};
#[inline]
LessThanLessThan: LessThanLessThan = {

        <l:@L> L_LessThanLessThan <r:@L> => new_less_than_less_than(l..r, source),

};
#[inline]
LessThanLessThanEqual: LessThanLessThanEqual = {

        <l:@L> L_LessThanLessThanEqual <r:@L> => new_less_than_less_than_equal(l..r, source),

};
#[inline]
LetKeyword: LetKeyword = {

        <l:@L> L_LetKeyword_Reserved <r:@L> => new_let_keyword(l..r, source),

};
#[inline]
LibraryKeyword: LibraryKeyword = {

        <l:@L> L_LibraryKeyword_Reserved <r:@L> => new_library_keyword(l..r, source),

};
#[inline]
MacroKeyword: MacroKeyword = {

        <l:@L> L_MacroKeyword_Reserved <r:@L> => new_macro_keyword(l..r, source),

};
#[inline]
MappingKeyword: MappingKeyword = {

        <l:@L> L_MappingKeyword_Reserved <r:@L> => new_mapping_keyword(l..r, source),

};
#[inline]
MatchKeyword: MatchKeyword = {

        <l:@L> L_MatchKeyword_Reserved <r:@L> => new_match_keyword(l..r, source),

};
#[inline]
MemoryKeyword: MemoryKeyword = {

        <l:@L> L_MemoryKeyword_Reserved <r:@L> => new_memory_keyword(l..r, source),

};
#[inline]
Minus: Minus = {

        <l:@L> L_Minus <r:@L> => new_minus(l..r, source),

};
#[inline]
MinusEqual: MinusEqual = {

        <l:@L> L_MinusEqual <r:@L> => new_minus_equal(l..r, source),

};
#[inline]
MinusGreaterThan: MinusGreaterThan = {

        <l:@L> L_MinusGreaterThan <r:@L> => new_minus_greater_than(l..r, source),

};
#[inline]
MinusMinus: MinusMinus = {

        <l:@L> L_MinusMinus <r:@L> => new_minus_minus(l..r, source),

};
#[inline]
MinutesKeyword: MinutesKeyword = {

        <l:@L> L_MinutesKeyword_Reserved <r:@L> => new_minutes_keyword(l..r, source),

};
#[inline]
ModifierKeyword: ModifierKeyword = {

        <l:@L> L_ModifierKeyword_Reserved <r:@L> => new_modifier_keyword(l..r, source),

};
#[inline]
MultiLineComment: MultiLineComment = {

        <l:@L> L_MultiLineComment <r:@L> => new_multi_line_comment(l..r, source),

};
#[inline]
MultiLineNatSpecComment: MultiLineNatSpecComment = {

        <l:@L> L_MultiLineNatSpecComment <r:@L> => new_multi_line_nat_spec_comment(l..r, source),

};
#[inline]
MutableKeyword: MutableKeyword = {

        <l:@L> L_MutableKeyword_Reserved <r:@L> => new_mutable_keyword(l..r, source),

};
#[inline]
NewKeyword: NewKeyword = {

        <l:@L> L_NewKeyword_Reserved <r:@L> => new_new_keyword(l..r, source),

};
#[inline]
NullKeyword: NullKeyword = {

        <l:@L> L_NullKeyword_Reserved <r:@L> => new_null_keyword(l..r, source),

};
#[inline]
OfKeyword: OfKeyword = {

        <l:@L> L_OfKeyword_Reserved <r:@L> => new_of_keyword(l..r, source),

};
#[inline]
OpenBrace: OpenBrace = {

        <l:@L> L_OpenBrace <r:@L> => new_open_brace(l..r, source),

};
#[inline]
OpenBracket: OpenBracket = {

        <l:@L> L_OpenBracket <r:@L> => new_open_bracket(l..r, source),

};
#[inline]
OpenParen: OpenParen = {

        <l:@L> L_OpenParen <r:@L> => new_open_paren(l..r, source),

};
#[inline]
OverrideKeyword: OverrideKeyword = {

        <l:@L> L_OverrideKeyword_Reserved <r:@L> => new_override_keyword(l..r, source),

};
#[inline]
PartialKeyword: PartialKeyword = {

        <l:@L> L_PartialKeyword_Reserved <r:@L> => new_partial_keyword(l..r, source),

};
#[inline]
PayableKeyword: PayableKeyword = {

        <l:@L> L_PayableKeyword_Reserved <r:@L> => new_payable_keyword(l..r, source),

};
#[inline]
Percent: Percent = {

        <l:@L> L_Percent <r:@L> => new_percent(l..r, source),

};
#[inline]
PercentEqual: PercentEqual = {

        <l:@L> L_PercentEqual <r:@L> => new_percent_equal(l..r, source),

};
#[inline]
Period: Period = {

        <l:@L> L_Period <r:@L> => new_period(l..r, source),

};
#[inline]
Plus: Plus = {

        <l:@L> L_Plus <r:@L> => new_plus(l..r, source),

};
#[inline]
PlusEqual: PlusEqual = {

        <l:@L> L_PlusEqual <r:@L> => new_plus_equal(l..r, source),

};
#[inline]
PlusPlus: PlusPlus = {

        <l:@L> L_PlusPlus <r:@L> => new_plus_plus(l..r, source),

};
#[inline]
PragmaKeyword: PragmaKeyword = {

        <l:@L> L_PragmaKeyword_Reserved <r:@L> => new_pragma_keyword(l..r, source),

};
#[inline]
PrivateKeyword: PrivateKeyword = {

        <l:@L> L_PrivateKeyword_Reserved <r:@L> => new_private_keyword(l..r, source),

};
#[inline]
PromiseKeyword: PromiseKeyword = {

        <l:@L> L_PromiseKeyword_Reserved <r:@L> => new_promise_keyword(l..r, source),

};
#[inline]
PublicKeyword: PublicKeyword = {

        <l:@L> L_PublicKeyword_Reserved <r:@L> => new_public_keyword(l..r, source),

};
#[inline]
PureKeyword: PureKeyword = {

        <l:@L> L_PureKeyword_Reserved <r:@L> => new_pure_keyword(l..r, source),

};
#[inline]
QuestionMark: QuestionMark = {

        <l:@L> L_QuestionMark <r:@L> => new_question_mark(l..r, source),

};
#[inline]
ReceiveKeyword: ReceiveKeyword = {

        <l:@L> L_ReceiveKeyword_Reserved <r:@L> => new_receive_keyword(l..r, source),

};
#[inline]
ReferenceKeyword: ReferenceKeyword = {

        <l:@L> L_ReferenceKeyword_Reserved <r:@L> => new_reference_keyword(l..r, source),

};
#[inline]
RelocatableKeyword: RelocatableKeyword = {

        <l:@L> L_RelocatableKeyword_Reserved <r:@L> => new_relocatable_keyword(l..r, source),

};
#[inline]
ReturnKeyword: ReturnKeyword = {

        <l:@L> L_ReturnKeyword_Reserved <r:@L> => new_return_keyword(l..r, source),

};
#[inline]
ReturnsKeyword: ReturnsKeyword = {

        <l:@L> L_ReturnsKeyword_Reserved <r:@L> => new_returns_keyword(l..r, source),

};
#[inline]
RevertKeyword: RevertKeyword = {

        <l:@L> L_RevertKeyword_Unreserved <r:@L> => new_revert_keyword(l..r, source),

};
#[inline]
SMTCheckerKeyword: SMTCheckerKeyword = {

        <l:@L> L_SMTCheckerKeyword_Reserved <r:@L> => new_smt_checker_keyword(l..r, source),

};
#[inline]
SealedKeyword: SealedKeyword = {

        <l:@L> L_SealedKeyword_Reserved <r:@L> => new_sealed_keyword(l..r, source),

};
#[inline]
SecondsKeyword: SecondsKeyword = {

        <l:@L> L_SecondsKeyword_Reserved <r:@L> => new_seconds_keyword(l..r, source),

};
#[inline]
Semicolon: Semicolon = {

        <l:@L> L_Semicolon <r:@L> => new_semicolon(l..r, source),

};
#[inline]
SingleLineComment: SingleLineComment = {

        <l:@L> L_SingleLineComment <r:@L> => new_single_line_comment(l..r, source),

};
#[inline]
SingleLineNatSpecComment: SingleLineNatSpecComment = {

        <l:@L> L_SingleLineNatSpecComment <r:@L> => new_single_line_nat_spec_comment(l..r, source),

};
#[inline]
SingleQuotedHexStringLiteral: SingleQuotedHexStringLiteral = {

        <l:@L> L_SingleQuotedHexStringLiteral <r:@L> => new_single_quoted_hex_string_literal(l..r, source),

};
#[inline]
SingleQuotedStringLiteral: SingleQuotedStringLiteral = {

        <l:@L> L_SingleQuotedStringLiteral <r:@L> => new_single_quoted_string_literal(l..r, source),

};
#[inline]
SingleQuotedUnicodeStringLiteral: SingleQuotedUnicodeStringLiteral = {

        <l:@L> L_SingleQuotedUnicodeStringLiteral <r:@L> => new_single_quoted_unicode_string_literal(l..r, source),

};
#[inline]
SingleQuotedVersionLiteral: SingleQuotedVersionLiteral = {

        <l:@L> L_SingleQuotedVersionLiteral <r:@L> => new_single_quoted_version_literal(l..r, source),

};
#[inline]
SizeOfKeyword: SizeOfKeyword = {

        <l:@L> L_SizeOfKeyword_Reserved <r:@L> => new_size_of_keyword(l..r, source),

};
#[inline]
Slash: Slash = {

        <l:@L> L_Slash <r:@L> => new_slash(l..r, source),

};
#[inline]
SlashEqual: SlashEqual = {

        <l:@L> L_SlashEqual <r:@L> => new_slash_equal(l..r, source),

};
#[inline]
SolidityKeyword: SolidityKeyword = {

        <l:@L> L_SolidityKeyword_Reserved <r:@L> => new_solidity_keyword(l..r, source),

};
#[inline]
StaticKeyword: StaticKeyword = {

        <l:@L> L_StaticKeyword_Reserved <r:@L> => new_static_keyword(l..r, source),

};
#[inline]
StorageKeyword: StorageKeyword = {

        <l:@L> L_StorageKeyword_Reserved <r:@L> => new_storage_keyword(l..r, source),

};
#[inline]
StringKeyword: StringKeyword = {

        <l:@L> L_StringKeyword_Reserved <r:@L> => new_string_keyword(l..r, source),

};
#[inline]
StructKeyword: StructKeyword = {

        <l:@L> L_StructKeyword_Reserved <r:@L> => new_struct_keyword(l..r, source),

};
#[inline]
SuperKeyword: SuperKeyword = {

        <l:@L> L_SuperKeyword_Reserved <r:@L> => new_super_keyword(l..r, source),

};
#[inline]
SupportsKeyword: SupportsKeyword = {

        <l:@L> L_SupportsKeyword_Reserved <r:@L> => new_supports_keyword(l..r, source),

};
#[inline]
SwitchKeyword: SwitchKeyword = {

        <l:@L> L_SwitchKeyword_Reserved <r:@L> => new_switch_keyword(l..r, source),

};
#[inline]
SzaboKeyword: SzaboKeyword = {

        <l:@L> L_SzaboKeyword_Unreserved <r:@L> => new_szabo_keyword(l..r, source),

};
#[inline]
ThisKeyword: ThisKeyword = {

        <l:@L> L_ThisKeyword_Reserved <r:@L> => new_this_keyword(l..r, source),

};
#[inline]
ThrowKeyword: ThrowKeyword = {

        <l:@L> L_ThrowKeyword_Reserved <r:@L> => new_throw_keyword(l..r, source),

};
#[inline]
Tilde: Tilde = {

        <l:@L> L_Tilde <r:@L> => new_tilde(l..r, source),

};
#[inline]
TransientKeyword: TransientKeyword = {

        <l:@L> L_TransientKeyword_Unreserved <r:@L> => new_transient_keyword(l..r, source),

};
#[inline]
TrueKeyword: TrueKeyword = {

        <l:@L> L_TrueKeyword_Reserved <r:@L> => new_true_keyword(l..r, source),

};
#[inline]
TryKeyword: TryKeyword = {

        <l:@L> L_TryKeyword_Reserved <r:@L> => new_try_keyword(l..r, source),

};
#[inline]
TypeDefKeyword: TypeDefKeyword = {

        <l:@L> L_TypeDefKeyword_Reserved <r:@L> => new_type_def_keyword(l..r, source),

};
#[inline]
TypeKeyword: TypeKeyword = {

        <l:@L> L_TypeKeyword_Reserved <r:@L> => new_type_keyword(l..r, source),

};
#[inline]
TypeOfKeyword: TypeOfKeyword = {

        <l:@L> L_TypeOfKeyword_Reserved <r:@L> => new_type_of_keyword(l..r, source),

};
#[inline]
UfixedKeyword: UfixedKeyword = {

        <l:@L> L_UfixedKeyword_Reserved <r:@L> => new_ufixed_keyword(l..r, source),

};
#[inline]
UintKeyword: UintKeyword = {

        <l:@L> L_UintKeyword_Reserved <r:@L> => new_uint_keyword(l..r, source),

};
#[inline]
UncheckedKeyword: UncheckedKeyword = {

        <l:@L> L_UncheckedKeyword_Reserved <r:@L> => new_unchecked_keyword(l..r, source),

};
#[inline]
UsingKeyword: UsingKeyword = {

        <l:@L> L_UsingKeyword_Reserved <r:@L> => new_using_keyword(l..r, source),

};
#[inline]
VarKeyword: VarKeyword = {

        <l:@L> L_VarKeyword_Reserved <r:@L> => new_var_keyword(l..r, source),

};
#[inline]
VersionSpecifier: VersionSpecifier = {

        <l:@L> L_VersionSpecifier <r:@L> => new_version_specifier(l..r, source),

};
#[inline]
ViewKeyword: ViewKeyword = {

        <l:@L> L_ViewKeyword_Reserved <r:@L> => new_view_keyword(l..r, source),

};
#[inline]
VirtualKeyword: VirtualKeyword = {

        <l:@L> L_VirtualKeyword_Reserved <r:@L> => new_virtual_keyword(l..r, source),

};
#[inline]
WeeksKeyword: WeeksKeyword = {

        <l:@L> L_WeeksKeyword_Reserved <r:@L> => new_weeks_keyword(l..r, source),

};
#[inline]
WeiKeyword: WeiKeyword = {

        <l:@L> L_WeiKeyword_Reserved <r:@L> => new_wei_keyword(l..r, source),

};
#[inline]
WhileKeyword: WhileKeyword = {

        <l:@L> L_WhileKeyword_Reserved <r:@L> => new_while_keyword(l..r, source),

};
#[inline]
Whitespace: Whitespace = {

        <l:@L> L_Whitespace <r:@L> => new_whitespace(l..r, source),

};
#[inline]
YearsKeyword: YearsKeyword = {

        <l:@L> L_YearsKeyword_Reserved <r:@L> => new_years_keyword(l..r, source),

};
#[inline]
YulAbstractKeyword: YulAbstractKeyword = {

        <l:@L> L_YulAbstractKeyword_Unreserved <r:@L> => new_yul_abstract_keyword(l..r, source),

};
#[inline]
YulAfterKeyword: YulAfterKeyword = {

        <l:@L> L_YulAfterKeyword_Unreserved <r:@L> => new_yul_after_keyword(l..r, source),

};
#[inline]
YulAliasKeyword: YulAliasKeyword = {

        <l:@L> L_YulAliasKeyword_Unreserved <r:@L> => new_yul_alias_keyword(l..r, source),

};
#[inline]
YulAnonymousKeyword: YulAnonymousKeyword = {

        <l:@L> L_YulAnonymousKeyword_Unreserved <r:@L> => new_yul_anonymous_keyword(l..r, source),

};
#[inline]
YulApplyKeyword: YulApplyKeyword = {

        <l:@L> L_YulApplyKeyword_Unreserved <r:@L> => new_yul_apply_keyword(l..r, source),

};
#[inline]
YulAsKeyword: YulAsKeyword = {

        <l:@L> L_YulAsKeyword_Unreserved <r:@L> => new_yul_as_keyword(l..r, source),

};
#[inline]
YulAssemblyKeyword: YulAssemblyKeyword = {

        <l:@L> L_YulAssemblyKeyword_Unreserved <r:@L> => new_yul_assembly_keyword(l..r, source),

};
#[inline]
YulAutoKeyword: YulAutoKeyword = {

        <l:@L> L_YulAutoKeyword_Unreserved <r:@L> => new_yul_auto_keyword(l..r, source),

};
#[inline]
YulBoolKeyword: YulBoolKeyword = {

        <l:@L> L_YulBoolKeyword_Unreserved <r:@L> => new_yul_bool_keyword(l..r, source),

};
#[inline]
YulBreakKeyword: YulBreakKeyword = {

        <l:@L> L_YulBreakKeyword_Reserved <r:@L> => new_yul_break_keyword(l..r, source),

};
#[inline]
YulBytesKeyword: YulBytesKeyword = {

        <l:@L> L_YulBytesKeyword_Unreserved <r:@L> => new_yul_bytes_keyword(l..r, source),

};
#[inline]
YulCallDataKeyword: YulCallDataKeyword = {

        <l:@L> L_YulCallDataKeyword_Unreserved <r:@L> => new_yul_call_data_keyword(l..r, source),

};
#[inline]
YulCaseKeyword: YulCaseKeyword = {

        <l:@L> L_YulCaseKeyword_Reserved <r:@L> => new_yul_case_keyword(l..r, source),

};
#[inline]
YulCatchKeyword: YulCatchKeyword = {

        <l:@L> L_YulCatchKeyword_Unreserved <r:@L> => new_yul_catch_keyword(l..r, source),

};
#[inline]
YulConstantKeyword: YulConstantKeyword = {

        <l:@L> L_YulConstantKeyword_Unreserved <r:@L> => new_yul_constant_keyword(l..r, source),

};
#[inline]
YulConstructorKeyword: YulConstructorKeyword = {

        <l:@L> L_YulConstructorKeyword_Unreserved <r:@L> => new_yul_constructor_keyword(l..r, source),

};
#[inline]
YulContinueKeyword: YulContinueKeyword = {

        <l:@L> L_YulContinueKeyword_Reserved <r:@L> => new_yul_continue_keyword(l..r, source),

};
#[inline]
YulContractKeyword: YulContractKeyword = {

        <l:@L> L_YulContractKeyword_Unreserved <r:@L> => new_yul_contract_keyword(l..r, source),

};
#[inline]
YulCopyOfKeyword: YulCopyOfKeyword = {

        <l:@L> L_YulCopyOfKeyword_Unreserved <r:@L> => new_yul_copy_of_keyword(l..r, source),

};
#[inline]
YulDaysKeyword: YulDaysKeyword = {

        <l:@L> L_YulDaysKeyword_Unreserved <r:@L> => new_yul_days_keyword(l..r, source),

};
#[inline]
YulDecimalLiteral: YulDecimalLiteral = {

        <l:@L> L_YulDecimalLiteral <r:@L> => new_yul_decimal_literal(l..r, source),

};
#[inline]
YulDefaultKeyword: YulDefaultKeyword = {

        <l:@L> L_YulDefaultKeyword_Reserved <r:@L> => new_yul_default_keyword(l..r, source),

};
#[inline]
YulDefineKeyword: YulDefineKeyword = {

        <l:@L> L_YulDefineKeyword_Unreserved <r:@L> => new_yul_define_keyword(l..r, source),

};
#[inline]
YulDeleteKeyword: YulDeleteKeyword = {

        <l:@L> L_YulDeleteKeyword_Unreserved <r:@L> => new_yul_delete_keyword(l..r, source),

};
#[inline]
YulDoKeyword: YulDoKeyword = {

        <l:@L> L_YulDoKeyword_Unreserved <r:@L> => new_yul_do_keyword(l..r, source),

};
#[inline]
YulElseKeyword: YulElseKeyword = {

        <l:@L> L_YulElseKeyword_Unreserved <r:@L> => new_yul_else_keyword(l..r, source),

};
#[inline]
YulEmitKeyword: YulEmitKeyword = {

        <l:@L> L_YulEmitKeyword_Unreserved <r:@L> => new_yul_emit_keyword(l..r, source),

};
#[inline]
YulEnumKeyword: YulEnumKeyword = {

        <l:@L> L_YulEnumKeyword_Unreserved <r:@L> => new_yul_enum_keyword(l..r, source),

};
#[inline]
YulEtherKeyword: YulEtherKeyword = {

        <l:@L> L_YulEtherKeyword_Unreserved <r:@L> => new_yul_ether_keyword(l..r, source),

};
#[inline]
YulEventKeyword: YulEventKeyword = {

        <l:@L> L_YulEventKeyword_Unreserved <r:@L> => new_yul_event_keyword(l..r, source),

};
#[inline]
YulExternalKeyword: YulExternalKeyword = {

        <l:@L> L_YulExternalKeyword_Unreserved <r:@L> => new_yul_external_keyword(l..r, source),

};
#[inline]
YulFallbackKeyword: YulFallbackKeyword = {

        <l:@L> L_YulFallbackKeyword_Unreserved <r:@L> => new_yul_fallback_keyword(l..r, source),

};
#[inline]
YulFalseKeyword: YulFalseKeyword = {

        <l:@L> L_YulFalseKeyword_Reserved <r:@L> => new_yul_false_keyword(l..r, source),

};
#[inline]
YulFinalKeyword: YulFinalKeyword = {

        <l:@L> L_YulFinalKeyword_Unreserved <r:@L> => new_yul_final_keyword(l..r, source),

};
#[inline]
YulFinneyKeyword: YulFinneyKeyword = {

        <l:@L> L_YulFinneyKeyword_Unreserved <r:@L> => new_yul_finney_keyword(l..r, source),

};
#[inline]
YulFixedKeyword: YulFixedKeyword = {

        <l:@L> L_YulFixedKeyword_Unreserved <r:@L> => new_yul_fixed_keyword(l..r, source),

};
#[inline]
YulForKeyword: YulForKeyword = {

        <l:@L> L_YulForKeyword_Reserved <r:@L> => new_yul_for_keyword(l..r, source),

};
#[inline]
YulFunctionKeyword: YulFunctionKeyword = {

        <l:@L> L_YulFunctionKeyword_Reserved <r:@L> => new_yul_function_keyword(l..r, source),

};
#[inline]
YulGweiKeyword: YulGweiKeyword = {

        <l:@L> L_YulGweiKeyword_Unreserved <r:@L> => new_yul_gwei_keyword(l..r, source),

};
#[inline]
YulHexKeyword: YulHexKeyword = {

        <l:@L> L_YulHexKeyword_Reserved <r:@L> => new_yul_hex_keyword(l..r, source),

};
#[inline]
YulHexLiteral: YulHexLiteral = {

        <l:@L> L_YulHexLiteral <r:@L> => new_yul_hex_literal(l..r, source),

};
#[inline]
YulHoursKeyword: YulHoursKeyword = {

        <l:@L> L_YulHoursKeyword_Unreserved <r:@L> => new_yul_hours_keyword(l..r, source),

};
#[inline]
YulIdentifier: YulIdentifier = {

        <l:@L> L_YulAbstractKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAfterKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAliasKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAnonymousKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulApplyKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAssemblyKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulAutoKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulBoolKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulBytesKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulCallDataKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulCatchKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulConstantKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulConstructorKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulContractKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulCopyOfKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulDaysKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulDefineKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulDeleteKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulDoKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulElseKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulEmitKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulEnumKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulEtherKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulEventKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulExternalKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulFallbackKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulFinalKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulFinneyKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulFixedKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulGweiKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulHoursKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulIdentifier <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulImmutableKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulImplementsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulImportKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulInKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulIndexedKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulInlineKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulIntKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulInterfaceKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulInternalKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulIsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulLibraryKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMacroKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMappingKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMatchKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMemoryKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMinutesKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulModifierKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulMutableKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulNewKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulNullKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulOfKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulOverrideKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPartialKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPayableKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPragmaKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPrivateKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPromiseKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPublicKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulPureKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulReceiveKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulReferenceKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulRelocatableKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulReturnsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulSealedKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulSecondsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulSizeOfKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulStaticKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulStorageKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulStringKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulStructKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulSupportsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulSzaboKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulThrowKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulTryKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulTypeDefKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulTypeKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulTypeOfKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulUfixedKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulUintKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulUncheckedKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulUsingKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulVarKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulViewKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulVirtualKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulWeeksKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulWeiKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulWhileKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

        <l:@L> L_YulYearsKeyword_Unreserved <r:@L> => new_yul_identifier(l..r, source),

};
#[inline]
YulIfKeyword: YulIfKeyword = {

        <l:@L> L_YulIfKeyword_Reserved <r:@L> => new_yul_if_keyword(l..r, source),

};
#[inline]
YulImmutableKeyword: YulImmutableKeyword = {

        <l:@L> L_YulImmutableKeyword_Unreserved <r:@L> => new_yul_immutable_keyword(l..r, source),

};
#[inline]
YulImplementsKeyword: YulImplementsKeyword = {

        <l:@L> L_YulImplementsKeyword_Unreserved <r:@L> => new_yul_implements_keyword(l..r, source),

};
#[inline]
YulImportKeyword: YulImportKeyword = {

        <l:@L> L_YulImportKeyword_Unreserved <r:@L> => new_yul_import_keyword(l..r, source),

};
#[inline]
YulInKeyword: YulInKeyword = {

        <l:@L> L_YulInKeyword_Unreserved <r:@L> => new_yul_in_keyword(l..r, source),

};
#[inline]
YulIndexedKeyword: YulIndexedKeyword = {

        <l:@L> L_YulIndexedKeyword_Unreserved <r:@L> => new_yul_indexed_keyword(l..r, source),

};
#[inline]
YulInlineKeyword: YulInlineKeyword = {

        <l:@L> L_YulInlineKeyword_Unreserved <r:@L> => new_yul_inline_keyword(l..r, source),

};
#[inline]
YulIntKeyword: YulIntKeyword = {

        <l:@L> L_YulIntKeyword_Unreserved <r:@L> => new_yul_int_keyword(l..r, source),

};
#[inline]
YulInterfaceKeyword: YulInterfaceKeyword = {

        <l:@L> L_YulInterfaceKeyword_Unreserved <r:@L> => new_yul_interface_keyword(l..r, source),

};
#[inline]
YulInternalKeyword: YulInternalKeyword = {

        <l:@L> L_YulInternalKeyword_Unreserved <r:@L> => new_yul_internal_keyword(l..r, source),

};
#[inline]
YulIsKeyword: YulIsKeyword = {

        <l:@L> L_YulIsKeyword_Unreserved <r:@L> => new_yul_is_keyword(l..r, source),

};
#[inline]
YulLeaveKeyword: YulLeaveKeyword = {

        <l:@L> L_YulLeaveKeyword_Reserved <r:@L> => new_yul_leave_keyword(l..r, source),

};
#[inline]
YulLetKeyword: YulLetKeyword = {

        <l:@L> L_YulLetKeyword_Reserved <r:@L> => new_yul_let_keyword(l..r, source),

};
#[inline]
YulLibraryKeyword: YulLibraryKeyword = {

        <l:@L> L_YulLibraryKeyword_Unreserved <r:@L> => new_yul_library_keyword(l..r, source),

};
#[inline]
YulMacroKeyword: YulMacroKeyword = {

        <l:@L> L_YulMacroKeyword_Unreserved <r:@L> => new_yul_macro_keyword(l..r, source),

};
#[inline]
YulMappingKeyword: YulMappingKeyword = {

        <l:@L> L_YulMappingKeyword_Unreserved <r:@L> => new_yul_mapping_keyword(l..r, source),

};
#[inline]
YulMatchKeyword: YulMatchKeyword = {

        <l:@L> L_YulMatchKeyword_Unreserved <r:@L> => new_yul_match_keyword(l..r, source),

};
#[inline]
YulMemoryKeyword: YulMemoryKeyword = {

        <l:@L> L_YulMemoryKeyword_Unreserved <r:@L> => new_yul_memory_keyword(l..r, source),

};
#[inline]
YulMinutesKeyword: YulMinutesKeyword = {

        <l:@L> L_YulMinutesKeyword_Unreserved <r:@L> => new_yul_minutes_keyword(l..r, source),

};
#[inline]
YulModifierKeyword: YulModifierKeyword = {

        <l:@L> L_YulModifierKeyword_Unreserved <r:@L> => new_yul_modifier_keyword(l..r, source),

};
#[inline]
YulMutableKeyword: YulMutableKeyword = {

        <l:@L> L_YulMutableKeyword_Unreserved <r:@L> => new_yul_mutable_keyword(l..r, source),

};
#[inline]
YulNewKeyword: YulNewKeyword = {

        <l:@L> L_YulNewKeyword_Unreserved <r:@L> => new_yul_new_keyword(l..r, source),

};
#[inline]
YulNullKeyword: YulNullKeyword = {

        <l:@L> L_YulNullKeyword_Unreserved <r:@L> => new_yul_null_keyword(l..r, source),

};
#[inline]
YulOfKeyword: YulOfKeyword = {

        <l:@L> L_YulOfKeyword_Unreserved <r:@L> => new_yul_of_keyword(l..r, source),

};
#[inline]
YulOverrideKeyword: YulOverrideKeyword = {

        <l:@L> L_YulOverrideKeyword_Unreserved <r:@L> => new_yul_override_keyword(l..r, source),

};
#[inline]
YulPartialKeyword: YulPartialKeyword = {

        <l:@L> L_YulPartialKeyword_Unreserved <r:@L> => new_yul_partial_keyword(l..r, source),

};
#[inline]
YulPayableKeyword: YulPayableKeyword = {

        <l:@L> L_YulPayableKeyword_Unreserved <r:@L> => new_yul_payable_keyword(l..r, source),

};
#[inline]
YulPragmaKeyword: YulPragmaKeyword = {

        <l:@L> L_YulPragmaKeyword_Unreserved <r:@L> => new_yul_pragma_keyword(l..r, source),

};
#[inline]
YulPrivateKeyword: YulPrivateKeyword = {

        <l:@L> L_YulPrivateKeyword_Unreserved <r:@L> => new_yul_private_keyword(l..r, source),

};
#[inline]
YulPromiseKeyword: YulPromiseKeyword = {

        <l:@L> L_YulPromiseKeyword_Unreserved <r:@L> => new_yul_promise_keyword(l..r, source),

};
#[inline]
YulPublicKeyword: YulPublicKeyword = {

        <l:@L> L_YulPublicKeyword_Unreserved <r:@L> => new_yul_public_keyword(l..r, source),

};
#[inline]
YulPureKeyword: YulPureKeyword = {

        <l:@L> L_YulPureKeyword_Unreserved <r:@L> => new_yul_pure_keyword(l..r, source),

};
#[inline]
YulReceiveKeyword: YulReceiveKeyword = {

        <l:@L> L_YulReceiveKeyword_Unreserved <r:@L> => new_yul_receive_keyword(l..r, source),

};
#[inline]
YulReferenceKeyword: YulReferenceKeyword = {

        <l:@L> L_YulReferenceKeyword_Unreserved <r:@L> => new_yul_reference_keyword(l..r, source),

};
#[inline]
YulRelocatableKeyword: YulRelocatableKeyword = {

        <l:@L> L_YulRelocatableKeyword_Unreserved <r:@L> => new_yul_relocatable_keyword(l..r, source),

};
#[inline]
YulReturnsKeyword: YulReturnsKeyword = {

        <l:@L> L_YulReturnsKeyword_Unreserved <r:@L> => new_yul_returns_keyword(l..r, source),

};
#[inline]
YulSealedKeyword: YulSealedKeyword = {

        <l:@L> L_YulSealedKeyword_Unreserved <r:@L> => new_yul_sealed_keyword(l..r, source),

};
#[inline]
YulSecondsKeyword: YulSecondsKeyword = {

        <l:@L> L_YulSecondsKeyword_Unreserved <r:@L> => new_yul_seconds_keyword(l..r, source),

};
#[inline]
YulSizeOfKeyword: YulSizeOfKeyword = {

        <l:@L> L_YulSizeOfKeyword_Unreserved <r:@L> => new_yul_size_of_keyword(l..r, source),

};
#[inline]
YulStaticKeyword: YulStaticKeyword = {

        <l:@L> L_YulStaticKeyword_Unreserved <r:@L> => new_yul_static_keyword(l..r, source),

};
#[inline]
YulStorageKeyword: YulStorageKeyword = {

        <l:@L> L_YulStorageKeyword_Unreserved <r:@L> => new_yul_storage_keyword(l..r, source),

};
#[inline]
YulStringKeyword: YulStringKeyword = {

        <l:@L> L_YulStringKeyword_Unreserved <r:@L> => new_yul_string_keyword(l..r, source),

};
#[inline]
YulStructKeyword: YulStructKeyword = {

        <l:@L> L_YulStructKeyword_Unreserved <r:@L> => new_yul_struct_keyword(l..r, source),

};
#[inline]
YulSuperKeyword: YulSuperKeyword = {

        <l:@L> L_YulSuperKeyword_Reserved <r:@L> => new_yul_super_keyword(l..r, source),

};
#[inline]
YulSupportsKeyword: YulSupportsKeyword = {

        <l:@L> L_YulSupportsKeyword_Unreserved <r:@L> => new_yul_supports_keyword(l..r, source),

};
#[inline]
YulSwitchKeyword: YulSwitchKeyword = {

        <l:@L> L_YulSwitchKeyword_Reserved <r:@L> => new_yul_switch_keyword(l..r, source),

};
#[inline]
YulSzaboKeyword: YulSzaboKeyword = {

        <l:@L> L_YulSzaboKeyword_Unreserved <r:@L> => new_yul_szabo_keyword(l..r, source),

};
#[inline]
YulThisKeyword: YulThisKeyword = {

        <l:@L> L_YulThisKeyword_Reserved <r:@L> => new_yul_this_keyword(l..r, source),

};
#[inline]
YulThrowKeyword: YulThrowKeyword = {

        <l:@L> L_YulThrowKeyword_Unreserved <r:@L> => new_yul_throw_keyword(l..r, source),

};
#[inline]
YulTrueKeyword: YulTrueKeyword = {

        <l:@L> L_YulTrueKeyword_Reserved <r:@L> => new_yul_true_keyword(l..r, source),

};
#[inline]
YulTryKeyword: YulTryKeyword = {

        <l:@L> L_YulTryKeyword_Unreserved <r:@L> => new_yul_try_keyword(l..r, source),

};
#[inline]
YulTypeDefKeyword: YulTypeDefKeyword = {

        <l:@L> L_YulTypeDefKeyword_Unreserved <r:@L> => new_yul_type_def_keyword(l..r, source),

};
#[inline]
YulTypeKeyword: YulTypeKeyword = {

        <l:@L> L_YulTypeKeyword_Unreserved <r:@L> => new_yul_type_keyword(l..r, source),

};
#[inline]
YulTypeOfKeyword: YulTypeOfKeyword = {

        <l:@L> L_YulTypeOfKeyword_Unreserved <r:@L> => new_yul_type_of_keyword(l..r, source),

};
#[inline]
YulUfixedKeyword: YulUfixedKeyword = {

        <l:@L> L_YulUfixedKeyword_Unreserved <r:@L> => new_yul_ufixed_keyword(l..r, source),

};
#[inline]
YulUintKeyword: YulUintKeyword = {

        <l:@L> L_YulUintKeyword_Unreserved <r:@L> => new_yul_uint_keyword(l..r, source),

};
#[inline]
YulUncheckedKeyword: YulUncheckedKeyword = {

        <l:@L> L_YulUncheckedKeyword_Unreserved <r:@L> => new_yul_unchecked_keyword(l..r, source),

};
#[inline]
YulUsingKeyword: YulUsingKeyword = {

        <l:@L> L_YulUsingKeyword_Unreserved <r:@L> => new_yul_using_keyword(l..r, source),

};
#[inline]
YulVarKeyword: YulVarKeyword = {

        <l:@L> L_YulVarKeyword_Unreserved <r:@L> => new_yul_var_keyword(l..r, source),

};
#[inline]
YulViewKeyword: YulViewKeyword = {

        <l:@L> L_YulViewKeyword_Unreserved <r:@L> => new_yul_view_keyword(l..r, source),

};
#[inline]
YulVirtualKeyword: YulVirtualKeyword = {

        <l:@L> L_YulVirtualKeyword_Unreserved <r:@L> => new_yul_virtual_keyword(l..r, source),

};
#[inline]
YulWeeksKeyword: YulWeeksKeyword = {

        <l:@L> L_YulWeeksKeyword_Unreserved <r:@L> => new_yul_weeks_keyword(l..r, source),

};
#[inline]
YulWeiKeyword: YulWeiKeyword = {

        <l:@L> L_YulWeiKeyword_Unreserved <r:@L> => new_yul_wei_keyword(l..r, source),

};
#[inline]
YulWhileKeyword: YulWhileKeyword = {

        <l:@L> L_YulWhileKeyword_Unreserved <r:@L> => new_yul_while_keyword(l..r, source),

};
#[inline]
YulYearsKeyword: YulYearsKeyword = {

        <l:@L> L_YulYearsKeyword_Unreserved <r:@L> => new_yul_years_keyword(l..r, source),

};



extern {
    type Location = usize;
    // TODO(v2): error recovery
    type Error = ();

    enum LexemeKind {
        L_ABIEncoderV2Keyword_Reserved => LexemeKind::ABIEncoderV2Keyword_Reserved,
        L_AbicoderKeyword_Reserved => LexemeKind::AbicoderKeyword_Reserved,
        L_AbicoderV1Keyword_Reserved => LexemeKind::AbicoderV1Keyword_Reserved,
        L_AbicoderV2Keyword_Reserved => LexemeKind::AbicoderV2Keyword_Reserved,
        L_AbstractKeyword_Reserved => LexemeKind::AbstractKeyword_Reserved,
        L_AddressKeyword_Reserved => LexemeKind::AddressKeyword_Reserved,
        L_AfterKeyword_Reserved => LexemeKind::AfterKeyword_Reserved,
        L_AliasKeyword_Reserved => LexemeKind::AliasKeyword_Reserved,
        L_AliasKeyword_Unreserved => LexemeKind::AliasKeyword_Unreserved,
        L_Ampersand => LexemeKind::Ampersand,
        L_AmpersandAmpersand => LexemeKind::AmpersandAmpersand,
        L_AmpersandEqual => LexemeKind::AmpersandEqual,
        L_AnonymousKeyword_Reserved => LexemeKind::AnonymousKeyword_Reserved,
        L_ApplyKeyword_Reserved => LexemeKind::ApplyKeyword_Reserved,
        L_ApplyKeyword_Unreserved => LexemeKind::ApplyKeyword_Unreserved,
        L_AsKeyword_Reserved => LexemeKind::AsKeyword_Reserved,
        L_AssemblyKeyword_Reserved => LexemeKind::AssemblyKeyword_Reserved,
        L_Asterisk => LexemeKind::Asterisk,
        L_AsteriskAsterisk => LexemeKind::AsteriskAsterisk,
        L_AsteriskEqual => LexemeKind::AsteriskEqual,
        L_AtKeyword_Unreserved => LexemeKind::AtKeyword_Unreserved,
        L_AutoKeyword_Reserved => LexemeKind::AutoKeyword_Reserved,
        L_AutoKeyword_Unreserved => LexemeKind::AutoKeyword_Unreserved,
        L_Bang => LexemeKind::Bang,
        L_BangEqual => LexemeKind::BangEqual,
        L_Bar => LexemeKind::Bar,
        L_BarBar => LexemeKind::BarBar,
        L_BarEqual => LexemeKind::BarEqual,
        L_BoolKeyword_Reserved => LexemeKind::BoolKeyword_Reserved,
        L_BreakKeyword_Reserved => LexemeKind::BreakKeyword_Reserved,
        L_ByteKeyword_Reserved => LexemeKind::ByteKeyword_Reserved,
        L_BytesKeyword_Reserved => LexemeKind::BytesKeyword_Reserved,
        L_CallDataKeyword_Reserved => LexemeKind::CallDataKeyword_Reserved,
        L_CallDataKeyword_Unreserved => LexemeKind::CallDataKeyword_Unreserved,
        L_Caret => LexemeKind::Caret,
        L_CaretEqual => LexemeKind::CaretEqual,
        L_CaseKeyword_Reserved => LexemeKind::CaseKeyword_Reserved,
        L_CatchKeyword_Reserved => LexemeKind::CatchKeyword_Reserved,
        L_CloseBrace => LexemeKind::CloseBrace,
        L_CloseBracket => LexemeKind::CloseBracket,
        L_CloseParen => LexemeKind::CloseParen,
        L_Colon => LexemeKind::Colon,
        L_ColonEqual => LexemeKind::ColonEqual,
        L_Comma => LexemeKind::Comma,
        L_ConstantKeyword_Reserved => LexemeKind::ConstantKeyword_Reserved,
        L_ConstructorKeyword_Reserved => LexemeKind::ConstructorKeyword_Reserved,
        L_ConstructorKeyword_Unreserved => LexemeKind::ConstructorKeyword_Unreserved,
        L_ContinueKeyword_Reserved => LexemeKind::ContinueKeyword_Reserved,
        L_ContractKeyword_Reserved => LexemeKind::ContractKeyword_Reserved,
        L_CopyOfKeyword_Reserved => LexemeKind::CopyOfKeyword_Reserved,
        L_CopyOfKeyword_Unreserved => LexemeKind::CopyOfKeyword_Unreserved,
        L_DaysKeyword_Reserved => LexemeKind::DaysKeyword_Reserved,
        L_DecimalLiteral => LexemeKind::DecimalLiteral,
        L_DefaultKeyword_Reserved => LexemeKind::DefaultKeyword_Reserved,
        L_DefineKeyword_Reserved => LexemeKind::DefineKeyword_Reserved,
        L_DefineKeyword_Unreserved => LexemeKind::DefineKeyword_Unreserved,
        L_DeleteKeyword_Reserved => LexemeKind::DeleteKeyword_Reserved,
        L_DoKeyword_Reserved => LexemeKind::DoKeyword_Reserved,
        L_DoubleQuotedHexStringLiteral => LexemeKind::DoubleQuotedHexStringLiteral,
        L_DoubleQuotedStringLiteral => LexemeKind::DoubleQuotedStringLiteral,
        L_DoubleQuotedUnicodeStringLiteral => LexemeKind::DoubleQuotedUnicodeStringLiteral,
        L_DoubleQuotedVersionLiteral => LexemeKind::DoubleQuotedVersionLiteral,
        L_ElseKeyword_Reserved => LexemeKind::ElseKeyword_Reserved,
        L_EmitKeyword_Reserved => LexemeKind::EmitKeyword_Reserved,
        L_EmitKeyword_Unreserved => LexemeKind::EmitKeyword_Unreserved,
        L_EndOfLine => LexemeKind::EndOfLine,
        L_EnumKeyword_Reserved => LexemeKind::EnumKeyword_Reserved,
        L_Equal => LexemeKind::Equal,
        L_EqualColon => LexemeKind::EqualColon,
        L_EqualEqual => LexemeKind::EqualEqual,
        L_EqualGreaterThan => LexemeKind::EqualGreaterThan,
        L_ErrorKeyword_Unreserved => LexemeKind::ErrorKeyword_Unreserved,
        L_EtherKeyword_Reserved => LexemeKind::EtherKeyword_Reserved,
        L_EventKeyword_Reserved => LexemeKind::EventKeyword_Reserved,
        L_ExperimentalKeyword_Reserved => LexemeKind::ExperimentalKeyword_Reserved,
        L_ExternalKeyword_Reserved => LexemeKind::ExternalKeyword_Reserved,
        L_FallbackKeyword_Reserved => LexemeKind::FallbackKeyword_Reserved,
        L_FallbackKeyword_Unreserved => LexemeKind::FallbackKeyword_Unreserved,
        L_FalseKeyword_Reserved => LexemeKind::FalseKeyword_Reserved,
        L_FinalKeyword_Reserved => LexemeKind::FinalKeyword_Reserved,
        L_FinneyKeyword_Reserved => LexemeKind::FinneyKeyword_Reserved,
        L_FinneyKeyword_Unreserved => LexemeKind::FinneyKeyword_Unreserved,
        L_FixedKeyword_Reserved => LexemeKind::FixedKeyword_Reserved,
        L_FixedKeyword_Unreserved => LexemeKind::FixedKeyword_Unreserved,
        L_ForKeyword_Reserved => LexemeKind::ForKeyword_Reserved,
        L_FromKeyword_Unreserved => LexemeKind::FromKeyword_Unreserved,
        L_FunctionKeyword_Reserved => LexemeKind::FunctionKeyword_Reserved,
        L_GlobalKeyword_Unreserved => LexemeKind::GlobalKeyword_Unreserved,
        L_GreaterThan => LexemeKind::GreaterThan,
        L_GreaterThanEqual => LexemeKind::GreaterThanEqual,
        L_GreaterThanGreaterThan => LexemeKind::GreaterThanGreaterThan,
        L_GreaterThanGreaterThanEqual => LexemeKind::GreaterThanGreaterThanEqual,
        L_GreaterThanGreaterThanGreaterThan => LexemeKind::GreaterThanGreaterThanGreaterThan,
        L_GreaterThanGreaterThanGreaterThanEqual => LexemeKind::GreaterThanGreaterThanGreaterThanEqual,
        L_GweiKeyword_Reserved => LexemeKind::GweiKeyword_Reserved,
        L_GweiKeyword_Unreserved => LexemeKind::GweiKeyword_Unreserved,
        L_HexKeyword_Reserved => LexemeKind::HexKeyword_Reserved,
        L_HexLiteral => LexemeKind::HexLiteral,
        L_HoursKeyword_Reserved => LexemeKind::HoursKeyword_Reserved,
        L_Identifier => LexemeKind::Identifier,
        L_IfKeyword_Reserved => LexemeKind::IfKeyword_Reserved,
        L_ImmutableKeyword_Reserved => LexemeKind::ImmutableKeyword_Reserved,
        L_ImmutableKeyword_Unreserved => LexemeKind::ImmutableKeyword_Unreserved,
        L_ImplementsKeyword_Reserved => LexemeKind::ImplementsKeyword_Reserved,
        L_ImplementsKeyword_Unreserved => LexemeKind::ImplementsKeyword_Unreserved,
        L_ImportKeyword_Reserved => LexemeKind::ImportKeyword_Reserved,
        L_InKeyword_Reserved => LexemeKind::InKeyword_Reserved,
        L_IndexedKeyword_Reserved => LexemeKind::IndexedKeyword_Reserved,
        L_InlineKeyword_Reserved => LexemeKind::InlineKeyword_Reserved,
        L_IntKeyword_Reserved => LexemeKind::IntKeyword_Reserved,
        L_InterfaceKeyword_Reserved => LexemeKind::InterfaceKeyword_Reserved,
        L_InternalKeyword_Reserved => LexemeKind::InternalKeyword_Reserved,
        L_IsKeyword_Reserved => LexemeKind::IsKeyword_Reserved,
        L_LayoutKeyword_Unreserved => LexemeKind::LayoutKeyword_Unreserved,
        L_LessThan => LexemeKind::LessThan,
        L_LessThanEqual => LexemeKind::LessThanEqual,
        L_LessThanLessThan => LexemeKind::LessThanLessThan,
        L_LessThanLessThanEqual => LexemeKind::LessThanLessThanEqual,
        L_LetKeyword_Reserved => LexemeKind::LetKeyword_Reserved,
        L_LibraryKeyword_Reserved => LexemeKind::LibraryKeyword_Reserved,
        L_MacroKeyword_Reserved => LexemeKind::MacroKeyword_Reserved,
        L_MacroKeyword_Unreserved => LexemeKind::MacroKeyword_Unreserved,
        L_MappingKeyword_Reserved => LexemeKind::MappingKeyword_Reserved,
        L_MatchKeyword_Reserved => LexemeKind::MatchKeyword_Reserved,
        L_MemoryKeyword_Reserved => LexemeKind::MemoryKeyword_Reserved,
        L_Minus => LexemeKind::Minus,
        L_MinusEqual => LexemeKind::MinusEqual,
        L_MinusGreaterThan => LexemeKind::MinusGreaterThan,
        L_MinusMinus => LexemeKind::MinusMinus,
        L_MinutesKeyword_Reserved => LexemeKind::MinutesKeyword_Reserved,
        L_ModifierKeyword_Reserved => LexemeKind::ModifierKeyword_Reserved,
        L_MultiLineComment => LexemeKind::MultiLineComment,
        L_MultiLineNatSpecComment => LexemeKind::MultiLineNatSpecComment,
        L_MutableKeyword_Reserved => LexemeKind::MutableKeyword_Reserved,
        L_MutableKeyword_Unreserved => LexemeKind::MutableKeyword_Unreserved,
        L_NewKeyword_Reserved => LexemeKind::NewKeyword_Reserved,
        L_NullKeyword_Reserved => LexemeKind::NullKeyword_Reserved,
        L_OfKeyword_Reserved => LexemeKind::OfKeyword_Reserved,
        L_OpenBrace => LexemeKind::OpenBrace,
        L_OpenBracket => LexemeKind::OpenBracket,
        L_OpenParen => LexemeKind::OpenParen,
        L_OverrideKeyword_Reserved => LexemeKind::OverrideKeyword_Reserved,
        L_OverrideKeyword_Unreserved => LexemeKind::OverrideKeyword_Unreserved,
        L_PartialKeyword_Reserved => LexemeKind::PartialKeyword_Reserved,
        L_PartialKeyword_Unreserved => LexemeKind::PartialKeyword_Unreserved,
        L_PayableKeyword_Reserved => LexemeKind::PayableKeyword_Reserved,
        L_Percent => LexemeKind::Percent,
        L_PercentEqual => LexemeKind::PercentEqual,
        L_Period => LexemeKind::Period,
        L_Plus => LexemeKind::Plus,
        L_PlusEqual => LexemeKind::PlusEqual,
        L_PlusPlus => LexemeKind::PlusPlus,
        L_PragmaKeyword_Reserved => LexemeKind::PragmaKeyword_Reserved,
        L_PrivateKeyword_Reserved => LexemeKind::PrivateKeyword_Reserved,
        L_PromiseKeyword_Reserved => LexemeKind::PromiseKeyword_Reserved,
        L_PromiseKeyword_Unreserved => LexemeKind::PromiseKeyword_Unreserved,
        L_PublicKeyword_Reserved => LexemeKind::PublicKeyword_Reserved,
        L_PureKeyword_Reserved => LexemeKind::PureKeyword_Reserved,
        L_QuestionMark => LexemeKind::QuestionMark,
        L_ReceiveKeyword_Reserved => LexemeKind::ReceiveKeyword_Reserved,
        L_ReceiveKeyword_Unreserved => LexemeKind::ReceiveKeyword_Unreserved,
        L_ReferenceKeyword_Reserved => LexemeKind::ReferenceKeyword_Reserved,
        L_ReferenceKeyword_Unreserved => LexemeKind::ReferenceKeyword_Unreserved,
        L_RelocatableKeyword_Reserved => LexemeKind::RelocatableKeyword_Reserved,
        L_ReturnKeyword_Reserved => LexemeKind::ReturnKeyword_Reserved,
        L_ReturnsKeyword_Reserved => LexemeKind::ReturnsKeyword_Reserved,
        L_RevertKeyword_Unreserved => LexemeKind::RevertKeyword_Unreserved,
        L_SMTCheckerKeyword_Reserved => LexemeKind::SMTCheckerKeyword_Reserved,
        L_SealedKeyword_Reserved => LexemeKind::SealedKeyword_Reserved,
        L_SealedKeyword_Unreserved => LexemeKind::SealedKeyword_Unreserved,
        L_SecondsKeyword_Reserved => LexemeKind::SecondsKeyword_Reserved,
        L_Semicolon => LexemeKind::Semicolon,
        L_SingleLineComment => LexemeKind::SingleLineComment,
        L_SingleLineNatSpecComment => LexemeKind::SingleLineNatSpecComment,
        L_SingleQuotedHexStringLiteral => LexemeKind::SingleQuotedHexStringLiteral,
        L_SingleQuotedStringLiteral => LexemeKind::SingleQuotedStringLiteral,
        L_SingleQuotedUnicodeStringLiteral => LexemeKind::SingleQuotedUnicodeStringLiteral,
        L_SingleQuotedVersionLiteral => LexemeKind::SingleQuotedVersionLiteral,
        L_SizeOfKeyword_Reserved => LexemeKind::SizeOfKeyword_Reserved,
        L_SizeOfKeyword_Unreserved => LexemeKind::SizeOfKeyword_Unreserved,
        L_Slash => LexemeKind::Slash,
        L_SlashEqual => LexemeKind::SlashEqual,
        L_SolidityKeyword_Reserved => LexemeKind::SolidityKeyword_Reserved,
        L_StaticKeyword_Reserved => LexemeKind::StaticKeyword_Reserved,
        L_StorageKeyword_Reserved => LexemeKind::StorageKeyword_Reserved,
        L_StringKeyword_Reserved => LexemeKind::StringKeyword_Reserved,
        L_StructKeyword_Reserved => LexemeKind::StructKeyword_Reserved,
        L_SuperKeyword_Reserved => LexemeKind::SuperKeyword_Reserved,
        L_SuperKeyword_Unreserved => LexemeKind::SuperKeyword_Unreserved,
        L_SupportsKeyword_Reserved => LexemeKind::SupportsKeyword_Reserved,
        L_SupportsKeyword_Unreserved => LexemeKind::SupportsKeyword_Unreserved,
        L_SwitchKeyword_Reserved => LexemeKind::SwitchKeyword_Reserved,
        L_SzaboKeyword_Reserved => LexemeKind::SzaboKeyword_Reserved,
        L_SzaboKeyword_Unreserved => LexemeKind::SzaboKeyword_Unreserved,
        L_ThisKeyword_Reserved => LexemeKind::ThisKeyword_Reserved,
        L_ThisKeyword_Unreserved => LexemeKind::ThisKeyword_Unreserved,
        L_ThrowKeyword_Reserved => LexemeKind::ThrowKeyword_Reserved,
        L_Tilde => LexemeKind::Tilde,
        L_TransientKeyword_Unreserved => LexemeKind::TransientKeyword_Unreserved,
        L_TrueKeyword_Reserved => LexemeKind::TrueKeyword_Reserved,
        L_TryKeyword_Reserved => LexemeKind::TryKeyword_Reserved,
        L_TypeDefKeyword_Reserved => LexemeKind::TypeDefKeyword_Reserved,
        L_TypeDefKeyword_Unreserved => LexemeKind::TypeDefKeyword_Unreserved,
        L_TypeKeyword_Reserved => LexemeKind::TypeKeyword_Reserved,
        L_TypeOfKeyword_Reserved => LexemeKind::TypeOfKeyword_Reserved,
        L_UfixedKeyword_Reserved => LexemeKind::UfixedKeyword_Reserved,
        L_UfixedKeyword_Unreserved => LexemeKind::UfixedKeyword_Unreserved,
        L_UintKeyword_Reserved => LexemeKind::UintKeyword_Reserved,
        L_UncheckedKeyword_Reserved => LexemeKind::UncheckedKeyword_Reserved,
        L_UncheckedKeyword_Unreserved => LexemeKind::UncheckedKeyword_Unreserved,
        L_UsingKeyword_Reserved => LexemeKind::UsingKeyword_Reserved,
        L_VarKeyword_Reserved => LexemeKind::VarKeyword_Reserved,
        L_VersionSpecifier => LexemeKind::VersionSpecifier,
        L_ViewKeyword_Reserved => LexemeKind::ViewKeyword_Reserved,
        L_VirtualKeyword_Reserved => LexemeKind::VirtualKeyword_Reserved,
        L_VirtualKeyword_Unreserved => LexemeKind::VirtualKeyword_Unreserved,
        L_WeeksKeyword_Reserved => LexemeKind::WeeksKeyword_Reserved,
        L_WeiKeyword_Reserved => LexemeKind::WeiKeyword_Reserved,
        L_WhileKeyword_Reserved => LexemeKind::WhileKeyword_Reserved,
        L_Whitespace => LexemeKind::Whitespace,
        L_YearsKeyword_Reserved => LexemeKind::YearsKeyword_Reserved,
        L_YulAbstractKeyword_Reserved => LexemeKind::YulAbstractKeyword_Reserved,
        L_YulAbstractKeyword_Unreserved => LexemeKind::YulAbstractKeyword_Unreserved,
        L_YulAfterKeyword_Reserved => LexemeKind::YulAfterKeyword_Reserved,
        L_YulAfterKeyword_Unreserved => LexemeKind::YulAfterKeyword_Unreserved,
        L_YulAliasKeyword_Reserved => LexemeKind::YulAliasKeyword_Reserved,
        L_YulAliasKeyword_Unreserved => LexemeKind::YulAliasKeyword_Unreserved,
        L_YulAnonymousKeyword_Reserved => LexemeKind::YulAnonymousKeyword_Reserved,
        L_YulAnonymousKeyword_Unreserved => LexemeKind::YulAnonymousKeyword_Unreserved,
        L_YulApplyKeyword_Reserved => LexemeKind::YulApplyKeyword_Reserved,
        L_YulApplyKeyword_Unreserved => LexemeKind::YulApplyKeyword_Unreserved,
        L_YulAsKeyword_Reserved => LexemeKind::YulAsKeyword_Reserved,
        L_YulAsKeyword_Unreserved => LexemeKind::YulAsKeyword_Unreserved,
        L_YulAssemblyKeyword_Reserved => LexemeKind::YulAssemblyKeyword_Reserved,
        L_YulAssemblyKeyword_Unreserved => LexemeKind::YulAssemblyKeyword_Unreserved,
        L_YulAutoKeyword_Reserved => LexemeKind::YulAutoKeyword_Reserved,
        L_YulAutoKeyword_Unreserved => LexemeKind::YulAutoKeyword_Unreserved,
        L_YulBoolKeyword_Reserved => LexemeKind::YulBoolKeyword_Reserved,
        L_YulBoolKeyword_Unreserved => LexemeKind::YulBoolKeyword_Unreserved,
        L_YulBreakKeyword_Reserved => LexemeKind::YulBreakKeyword_Reserved,
        L_YulBytesKeyword_Reserved => LexemeKind::YulBytesKeyword_Reserved,
        L_YulBytesKeyword_Unreserved => LexemeKind::YulBytesKeyword_Unreserved,
        L_YulCallDataKeyword_Reserved => LexemeKind::YulCallDataKeyword_Reserved,
        L_YulCallDataKeyword_Unreserved => LexemeKind::YulCallDataKeyword_Unreserved,
        L_YulCaseKeyword_Reserved => LexemeKind::YulCaseKeyword_Reserved,
        L_YulCatchKeyword_Reserved => LexemeKind::YulCatchKeyword_Reserved,
        L_YulCatchKeyword_Unreserved => LexemeKind::YulCatchKeyword_Unreserved,
        L_YulConstantKeyword_Reserved => LexemeKind::YulConstantKeyword_Reserved,
        L_YulConstantKeyword_Unreserved => LexemeKind::YulConstantKeyword_Unreserved,
        L_YulConstructorKeyword_Reserved => LexemeKind::YulConstructorKeyword_Reserved,
        L_YulConstructorKeyword_Unreserved => LexemeKind::YulConstructorKeyword_Unreserved,
        L_YulContinueKeyword_Reserved => LexemeKind::YulContinueKeyword_Reserved,
        L_YulContractKeyword_Reserved => LexemeKind::YulContractKeyword_Reserved,
        L_YulContractKeyword_Unreserved => LexemeKind::YulContractKeyword_Unreserved,
        L_YulCopyOfKeyword_Reserved => LexemeKind::YulCopyOfKeyword_Reserved,
        L_YulCopyOfKeyword_Unreserved => LexemeKind::YulCopyOfKeyword_Unreserved,
        L_YulDaysKeyword_Reserved => LexemeKind::YulDaysKeyword_Reserved,
        L_YulDaysKeyword_Unreserved => LexemeKind::YulDaysKeyword_Unreserved,
        L_YulDecimalLiteral => LexemeKind::YulDecimalLiteral,
        L_YulDefaultKeyword_Reserved => LexemeKind::YulDefaultKeyword_Reserved,
        L_YulDefineKeyword_Reserved => LexemeKind::YulDefineKeyword_Reserved,
        L_YulDefineKeyword_Unreserved => LexemeKind::YulDefineKeyword_Unreserved,
        L_YulDeleteKeyword_Reserved => LexemeKind::YulDeleteKeyword_Reserved,
        L_YulDeleteKeyword_Unreserved => LexemeKind::YulDeleteKeyword_Unreserved,
        L_YulDoKeyword_Reserved => LexemeKind::YulDoKeyword_Reserved,
        L_YulDoKeyword_Unreserved => LexemeKind::YulDoKeyword_Unreserved,
        L_YulElseKeyword_Reserved => LexemeKind::YulElseKeyword_Reserved,
        L_YulElseKeyword_Unreserved => LexemeKind::YulElseKeyword_Unreserved,
        L_YulEmitKeyword_Reserved => LexemeKind::YulEmitKeyword_Reserved,
        L_YulEmitKeyword_Unreserved => LexemeKind::YulEmitKeyword_Unreserved,
        L_YulEnumKeyword_Reserved => LexemeKind::YulEnumKeyword_Reserved,
        L_YulEnumKeyword_Unreserved => LexemeKind::YulEnumKeyword_Unreserved,
        L_YulEtherKeyword_Reserved => LexemeKind::YulEtherKeyword_Reserved,
        L_YulEtherKeyword_Unreserved => LexemeKind::YulEtherKeyword_Unreserved,
        L_YulEventKeyword_Reserved => LexemeKind::YulEventKeyword_Reserved,
        L_YulEventKeyword_Unreserved => LexemeKind::YulEventKeyword_Unreserved,
        L_YulExternalKeyword_Reserved => LexemeKind::YulExternalKeyword_Reserved,
        L_YulExternalKeyword_Unreserved => LexemeKind::YulExternalKeyword_Unreserved,
        L_YulFallbackKeyword_Reserved => LexemeKind::YulFallbackKeyword_Reserved,
        L_YulFallbackKeyword_Unreserved => LexemeKind::YulFallbackKeyword_Unreserved,
        L_YulFalseKeyword_Reserved => LexemeKind::YulFalseKeyword_Reserved,
        L_YulFinalKeyword_Reserved => LexemeKind::YulFinalKeyword_Reserved,
        L_YulFinalKeyword_Unreserved => LexemeKind::YulFinalKeyword_Unreserved,
        L_YulFinneyKeyword_Reserved => LexemeKind::YulFinneyKeyword_Reserved,
        L_YulFinneyKeyword_Unreserved => LexemeKind::YulFinneyKeyword_Unreserved,
        L_YulFixedKeyword_Reserved => LexemeKind::YulFixedKeyword_Reserved,
        L_YulFixedKeyword_Unreserved => LexemeKind::YulFixedKeyword_Unreserved,
        L_YulForKeyword_Reserved => LexemeKind::YulForKeyword_Reserved,
        L_YulFunctionKeyword_Reserved => LexemeKind::YulFunctionKeyword_Reserved,
        L_YulGweiKeyword_Reserved => LexemeKind::YulGweiKeyword_Reserved,
        L_YulGweiKeyword_Unreserved => LexemeKind::YulGweiKeyword_Unreserved,
        L_YulHexKeyword_Reserved => LexemeKind::YulHexKeyword_Reserved,
        L_YulHexLiteral => LexemeKind::YulHexLiteral,
        L_YulHoursKeyword_Reserved => LexemeKind::YulHoursKeyword_Reserved,
        L_YulHoursKeyword_Unreserved => LexemeKind::YulHoursKeyword_Unreserved,
        L_YulIdentifier => LexemeKind::YulIdentifier,
        L_YulIfKeyword_Reserved => LexemeKind::YulIfKeyword_Reserved,
        L_YulImmutableKeyword_Reserved => LexemeKind::YulImmutableKeyword_Reserved,
        L_YulImmutableKeyword_Unreserved => LexemeKind::YulImmutableKeyword_Unreserved,
        L_YulImplementsKeyword_Reserved => LexemeKind::YulImplementsKeyword_Reserved,
        L_YulImplementsKeyword_Unreserved => LexemeKind::YulImplementsKeyword_Unreserved,
        L_YulImportKeyword_Reserved => LexemeKind::YulImportKeyword_Reserved,
        L_YulImportKeyword_Unreserved => LexemeKind::YulImportKeyword_Unreserved,
        L_YulInKeyword_Reserved => LexemeKind::YulInKeyword_Reserved,
        L_YulInKeyword_Unreserved => LexemeKind::YulInKeyword_Unreserved,
        L_YulIndexedKeyword_Reserved => LexemeKind::YulIndexedKeyword_Reserved,
        L_YulIndexedKeyword_Unreserved => LexemeKind::YulIndexedKeyword_Unreserved,
        L_YulInlineKeyword_Reserved => LexemeKind::YulInlineKeyword_Reserved,
        L_YulInlineKeyword_Unreserved => LexemeKind::YulInlineKeyword_Unreserved,
        L_YulIntKeyword_Reserved => LexemeKind::YulIntKeyword_Reserved,
        L_YulIntKeyword_Unreserved => LexemeKind::YulIntKeyword_Unreserved,
        L_YulInterfaceKeyword_Reserved => LexemeKind::YulInterfaceKeyword_Reserved,
        L_YulInterfaceKeyword_Unreserved => LexemeKind::YulInterfaceKeyword_Unreserved,
        L_YulInternalKeyword_Reserved => LexemeKind::YulInternalKeyword_Reserved,
        L_YulInternalKeyword_Unreserved => LexemeKind::YulInternalKeyword_Unreserved,
        L_YulIsKeyword_Reserved => LexemeKind::YulIsKeyword_Reserved,
        L_YulIsKeyword_Unreserved => LexemeKind::YulIsKeyword_Unreserved,
        L_YulLeaveKeyword_Reserved => LexemeKind::YulLeaveKeyword_Reserved,
        L_YulLeaveKeyword_Unreserved => LexemeKind::YulLeaveKeyword_Unreserved,
        L_YulLetKeyword_Reserved => LexemeKind::YulLetKeyword_Reserved,
        L_YulLibraryKeyword_Reserved => LexemeKind::YulLibraryKeyword_Reserved,
        L_YulLibraryKeyword_Unreserved => LexemeKind::YulLibraryKeyword_Unreserved,
        L_YulMacroKeyword_Reserved => LexemeKind::YulMacroKeyword_Reserved,
        L_YulMacroKeyword_Unreserved => LexemeKind::YulMacroKeyword_Unreserved,
        L_YulMappingKeyword_Reserved => LexemeKind::YulMappingKeyword_Reserved,
        L_YulMappingKeyword_Unreserved => LexemeKind::YulMappingKeyword_Unreserved,
        L_YulMatchKeyword_Reserved => LexemeKind::YulMatchKeyword_Reserved,
        L_YulMatchKeyword_Unreserved => LexemeKind::YulMatchKeyword_Unreserved,
        L_YulMemoryKeyword_Reserved => LexemeKind::YulMemoryKeyword_Reserved,
        L_YulMemoryKeyword_Unreserved => LexemeKind::YulMemoryKeyword_Unreserved,
        L_YulMinutesKeyword_Reserved => LexemeKind::YulMinutesKeyword_Reserved,
        L_YulMinutesKeyword_Unreserved => LexemeKind::YulMinutesKeyword_Unreserved,
        L_YulModifierKeyword_Reserved => LexemeKind::YulModifierKeyword_Reserved,
        L_YulModifierKeyword_Unreserved => LexemeKind::YulModifierKeyword_Unreserved,
        L_YulMutableKeyword_Reserved => LexemeKind::YulMutableKeyword_Reserved,
        L_YulMutableKeyword_Unreserved => LexemeKind::YulMutableKeyword_Unreserved,
        L_YulNewKeyword_Reserved => LexemeKind::YulNewKeyword_Reserved,
        L_YulNewKeyword_Unreserved => LexemeKind::YulNewKeyword_Unreserved,
        L_YulNullKeyword_Reserved => LexemeKind::YulNullKeyword_Reserved,
        L_YulNullKeyword_Unreserved => LexemeKind::YulNullKeyword_Unreserved,
        L_YulOfKeyword_Reserved => LexemeKind::YulOfKeyword_Reserved,
        L_YulOfKeyword_Unreserved => LexemeKind::YulOfKeyword_Unreserved,
        L_YulOverrideKeyword_Reserved => LexemeKind::YulOverrideKeyword_Reserved,
        L_YulOverrideKeyword_Unreserved => LexemeKind::YulOverrideKeyword_Unreserved,
        L_YulPartialKeyword_Reserved => LexemeKind::YulPartialKeyword_Reserved,
        L_YulPartialKeyword_Unreserved => LexemeKind::YulPartialKeyword_Unreserved,
        L_YulPayableKeyword_Reserved => LexemeKind::YulPayableKeyword_Reserved,
        L_YulPayableKeyword_Unreserved => LexemeKind::YulPayableKeyword_Unreserved,
        L_YulPragmaKeyword_Reserved => LexemeKind::YulPragmaKeyword_Reserved,
        L_YulPragmaKeyword_Unreserved => LexemeKind::YulPragmaKeyword_Unreserved,
        L_YulPrivateKeyword_Reserved => LexemeKind::YulPrivateKeyword_Reserved,
        L_YulPrivateKeyword_Unreserved => LexemeKind::YulPrivateKeyword_Unreserved,
        L_YulPromiseKeyword_Reserved => LexemeKind::YulPromiseKeyword_Reserved,
        L_YulPromiseKeyword_Unreserved => LexemeKind::YulPromiseKeyword_Unreserved,
        L_YulPublicKeyword_Reserved => LexemeKind::YulPublicKeyword_Reserved,
        L_YulPublicKeyword_Unreserved => LexemeKind::YulPublicKeyword_Unreserved,
        L_YulPureKeyword_Reserved => LexemeKind::YulPureKeyword_Reserved,
        L_YulPureKeyword_Unreserved => LexemeKind::YulPureKeyword_Unreserved,
        L_YulReceiveKeyword_Reserved => LexemeKind::YulReceiveKeyword_Reserved,
        L_YulReceiveKeyword_Unreserved => LexemeKind::YulReceiveKeyword_Unreserved,
        L_YulReferenceKeyword_Reserved => LexemeKind::YulReferenceKeyword_Reserved,
        L_YulReferenceKeyword_Unreserved => LexemeKind::YulReferenceKeyword_Unreserved,
        L_YulRelocatableKeyword_Reserved => LexemeKind::YulRelocatableKeyword_Reserved,
        L_YulRelocatableKeyword_Unreserved => LexemeKind::YulRelocatableKeyword_Unreserved,
        L_YulReturnsKeyword_Reserved => LexemeKind::YulReturnsKeyword_Reserved,
        L_YulReturnsKeyword_Unreserved => LexemeKind::YulReturnsKeyword_Unreserved,
        L_YulSealedKeyword_Reserved => LexemeKind::YulSealedKeyword_Reserved,
        L_YulSealedKeyword_Unreserved => LexemeKind::YulSealedKeyword_Unreserved,
        L_YulSecondsKeyword_Reserved => LexemeKind::YulSecondsKeyword_Reserved,
        L_YulSecondsKeyword_Unreserved => LexemeKind::YulSecondsKeyword_Unreserved,
        L_YulSizeOfKeyword_Reserved => LexemeKind::YulSizeOfKeyword_Reserved,
        L_YulSizeOfKeyword_Unreserved => LexemeKind::YulSizeOfKeyword_Unreserved,
        L_YulStaticKeyword_Reserved => LexemeKind::YulStaticKeyword_Reserved,
        L_YulStaticKeyword_Unreserved => LexemeKind::YulStaticKeyword_Unreserved,
        L_YulStorageKeyword_Reserved => LexemeKind::YulStorageKeyword_Reserved,
        L_YulStorageKeyword_Unreserved => LexemeKind::YulStorageKeyword_Unreserved,
        L_YulStringKeyword_Reserved => LexemeKind::YulStringKeyword_Reserved,
        L_YulStringKeyword_Unreserved => LexemeKind::YulStringKeyword_Unreserved,
        L_YulStructKeyword_Reserved => LexemeKind::YulStructKeyword_Reserved,
        L_YulStructKeyword_Unreserved => LexemeKind::YulStructKeyword_Unreserved,
        L_YulSuperKeyword_Reserved => LexemeKind::YulSuperKeyword_Reserved,
        L_YulSuperKeyword_Unreserved => LexemeKind::YulSuperKeyword_Unreserved,
        L_YulSupportsKeyword_Reserved => LexemeKind::YulSupportsKeyword_Reserved,
        L_YulSupportsKeyword_Unreserved => LexemeKind::YulSupportsKeyword_Unreserved,
        L_YulSwitchKeyword_Reserved => LexemeKind::YulSwitchKeyword_Reserved,
        L_YulSzaboKeyword_Reserved => LexemeKind::YulSzaboKeyword_Reserved,
        L_YulSzaboKeyword_Unreserved => LexemeKind::YulSzaboKeyword_Unreserved,
        L_YulThisKeyword_Reserved => LexemeKind::YulThisKeyword_Reserved,
        L_YulThisKeyword_Unreserved => LexemeKind::YulThisKeyword_Unreserved,
        L_YulThrowKeyword_Reserved => LexemeKind::YulThrowKeyword_Reserved,
        L_YulThrowKeyword_Unreserved => LexemeKind::YulThrowKeyword_Unreserved,
        L_YulTrueKeyword_Reserved => LexemeKind::YulTrueKeyword_Reserved,
        L_YulTryKeyword_Reserved => LexemeKind::YulTryKeyword_Reserved,
        L_YulTryKeyword_Unreserved => LexemeKind::YulTryKeyword_Unreserved,
        L_YulTypeDefKeyword_Reserved => LexemeKind::YulTypeDefKeyword_Reserved,
        L_YulTypeDefKeyword_Unreserved => LexemeKind::YulTypeDefKeyword_Unreserved,
        L_YulTypeKeyword_Reserved => LexemeKind::YulTypeKeyword_Reserved,
        L_YulTypeKeyword_Unreserved => LexemeKind::YulTypeKeyword_Unreserved,
        L_YulTypeOfKeyword_Reserved => LexemeKind::YulTypeOfKeyword_Reserved,
        L_YulTypeOfKeyword_Unreserved => LexemeKind::YulTypeOfKeyword_Unreserved,
        L_YulUfixedKeyword_Reserved => LexemeKind::YulUfixedKeyword_Reserved,
        L_YulUfixedKeyword_Unreserved => LexemeKind::YulUfixedKeyword_Unreserved,
        L_YulUintKeyword_Reserved => LexemeKind::YulUintKeyword_Reserved,
        L_YulUintKeyword_Unreserved => LexemeKind::YulUintKeyword_Unreserved,
        L_YulUncheckedKeyword_Reserved => LexemeKind::YulUncheckedKeyword_Reserved,
        L_YulUncheckedKeyword_Unreserved => LexemeKind::YulUncheckedKeyword_Unreserved,
        L_YulUsingKeyword_Reserved => LexemeKind::YulUsingKeyword_Reserved,
        L_YulUsingKeyword_Unreserved => LexemeKind::YulUsingKeyword_Unreserved,
        L_YulVarKeyword_Reserved => LexemeKind::YulVarKeyword_Reserved,
        L_YulVarKeyword_Unreserved => LexemeKind::YulVarKeyword_Unreserved,
        L_YulViewKeyword_Reserved => LexemeKind::YulViewKeyword_Reserved,
        L_YulViewKeyword_Unreserved => LexemeKind::YulViewKeyword_Unreserved,
        L_YulVirtualKeyword_Reserved => LexemeKind::YulVirtualKeyword_Reserved,
        L_YulVirtualKeyword_Unreserved => LexemeKind::YulVirtualKeyword_Unreserved,
        L_YulWeeksKeyword_Reserved => LexemeKind::YulWeeksKeyword_Reserved,
        L_YulWeeksKeyword_Unreserved => LexemeKind::YulWeeksKeyword_Unreserved,
        L_YulWeiKeyword_Reserved => LexemeKind::YulWeiKeyword_Reserved,
        L_YulWeiKeyword_Unreserved => LexemeKind::YulWeiKeyword_Unreserved,
        L_YulWhileKeyword_Reserved => LexemeKind::YulWhileKeyword_Reserved,
        L_YulWhileKeyword_Unreserved => LexemeKind::YulWhileKeyword_Unreserved,
        L_YulYearsKeyword_Reserved => LexemeKind::YulYearsKeyword_Reserved,
        L_YulYearsKeyword_Unreserved => LexemeKind::YulYearsKeyword_Unreserved,
        
    }
}
